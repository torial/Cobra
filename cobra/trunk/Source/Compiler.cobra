

enum ProblemAction
	Exit
	Throw


class Compiler
	implements ITypeProvider
	"""
	General notes:

	To cope with nesting, the compiler keeps a stack of the three types of things that can be nested. Items are pushed and popped off these stacks during each of the "bind interface" and "bind implementation" phases. The three stacks are:
		* nameSpaceStack - namespaces
		* boxStack - boxes are classes, structs and interfaces
		* codeMemberStack - methods, properties and constructors
	"""

	var _nextSerialNum as int is shared
	var _serialNum as int
	var _verbosity as int
	var _whenError as ProblemAction
	var _options as Dictionary<of String, Object>
	var _globalNS as NameSpace
	var _modules as List<of Module>

	var _curModule as Module?  # set during bindInt() and bindImp()
	var _nameSpaceStack as Stack<of NameSpace>
	var _boxStack as Stack<of Box>
	var _codeMemberStack as Stack<of ICodePart>

	def construct(verbosity as int)
		.construct(verbosity, ProblemAction.Exit)

	def construct(verbosity as int, whenError as ProblemAction)
		_nextSerialNum += 1
		_serialNum = _nextSerialNum
		_verbosity = verbosity
		_modules = List<of Module>()
		_whenError = whenError
		_globalNS = NameSpace(Token.empty, '(global)')
		_nameSpaceStack = Stack<of NameSpace>()
		_boxStack = Stack<of Box>()
		_codeMemberStack = Stack<of ICodePart>()

	def toString as String is override
		return '[.getType().name]([_serialNum])'

	get globalNS from var

	get modules from var

	pro whenError from var

	pro options from var

	get nameSpaceStack from var

	get boxStack from var

	get curBox as Box
		require .boxStack
		return _boxStack.peek() to Box  # CC: axe typecast

	get codeMemberStack from var

	def parseFilesNamed(filenames as List<of String>) as List<of Module>
		"""
		Returns the modules for the newly parsed files.
		Also, extends self.modules with those modules.
		"""
		require
			filenames
		ensure
			true
		code
			if _modules.count == 0
				# python: path = os.path.join(os.path.dirname(__file__), 'SystemInterfaces.cobra')
				path = r'C:\All\echuck\Projects\Cobra\Workspace\Source\SystemInterfaces.cobra'  # TODO: locate this next to cobra.exe
				assert File.exists(path), path
				filenames.insert(0, path)
			modules = List<of Module>()
			for filename in filenames
				# TODO: support C# code
#				if filename.endsWith('.cs')
#					if _verbosity>1
#						print 'Noting [filename]'
#					modules.add(SharpModule(filename))
#				else
				if 1
					if _verbosity>1
						print 'Parsing [filename]'
					parser = Parser()
					parser.verbosity = _verbosity
					parser.whenError = if(_whenError==ProblemAction.Exit, Parser.WhenErrorEnum.exit, Parser.WhenErrorEnum.throww)
					parser.typeProvider = this
					# TODO: parser.whenWarning = whenWarning
					assert _globalNS
					parser.globalNS = _globalNS
					# @@ TODO: assert _globalNS is parser.nameSpaceStack[0]
					module = parser.parseFileNamed(filename)
					assert module
					modules.add(module)
			assert modules
			_modules.addRange(modules)
			return modules


	##
	## ITypeProvider
	##

	var _boolType as BoolType?
	var _charType as CharType?
	var _decimalType as DecimalType?
	var _dynamicType as DynamicType?
	var _floatType as FloatType?
	var _intType as IntType?
	var _passThroughType as PassThroughType?
	var _typeType as TypeType?
	var _voidType as VoidType?
	var _variTypes as Dictionary<of INode, VariType>

	def typeForName(name as String) as IType
		assert false, 'TODO'
		return CobraType()

	def typeOrNilForName(name as String) as IType?
		assert false, 'TODO'
		return nil

	get boolType as BoolType
		if _boolType is nil
			_boolType = BoolType()
		return _boolType to BoolType  # CC: to ! | CC: axe to !

	get charType as CharType
		if _charType is nil
			_charType = CharType()
		return _charType to CharType  # CC: to! | CC: axe to !

	get decimalType as DecimalType
		if _decimalType is nil
			_decimalType = DecimalType()
		return _decimalType to DecimalType  # CC: to! | CC: axe to !

	get dynamicType as DynamicType
		if _dynamicType is nil
			_dynamicType = DynamicType()
		return _dynamicType to DynamicType

	get intType as IntType
		if _intType is nil
			_intType = IntType()
		return _intType to IntType  # CC: to! | CC: axe to !

	get floatType as FloatType
		if _floatType is nil
			_floatType = FloatType()
		return _floatType to FloatType  # CC: to! | CC: axe to !

	get passThroughType as PassThroughType
		if _passThroughType is nil
			_passThroughType = PassThroughType()
		return _passThroughType to PassThroughType  # CC: to ! | CC: axe to !

	get typeType as TypeType
		if _typeType is nil
			_typeType = TypeType()
		return _typeType to TypeType  # CC: to ! | CC: axe to !

	get voidType as VoidType
		if _voidType is nil
			_voidType = VoidType()
		return _voidType to VoidType  # CC: to ! | CC: axe to !

	def variType(type as IType) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of INode, VariType>()
		else if _variTypes.containsKey(type)
			return _variTypes[type]
		_variTypes[type] = vt = VariType(type)
		return vt

	def variType(typeNode as INode) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of INode, VariType>()
		else if _variTypes.containsKey(typeNode)
			return _variTypes[typeNode]
		_variTypes[typeNode] = vt = VariType(typeNode)
		return vt


	##
	## Binding
	##

	def bindInt
		# TODO: bindInt to all existing types
		Node.setCompiler(this)
		try
			for module in _modules  # CC: make that _curModule and axe following assignment statement
				_curModule = module
				_curModule.bindInt()
		finally
			Node.setCompiler(nil)

	def bindImp
		# TODO: bindImp to all existing types
		Node.setCompiler(this)
		try
			for module in _modules  # CC: make that _curModule and axe following assignment statement
				_curModule = module
				_curModule.bindImp()
		finally
			Node.setCompiler(nil)

	def symbolForName(name as String, canBeMember as bool, haveThis as bool) as IMember?
		"""
		name - obvious.
		canBeMember - the symbol can be a member of the current box
			TODO: can this be retired now that there is findLocal()?
		haveThis - if false, symbols like methods, properties, etc. will not be returned while enums, nested classes, etc. could be.
		"""
		require
			name
		code
			assert _curModule

			# TODO: is canBeMember ever false?

			if name[0].toString().toLower()==name[0] and name[0]>=c'a' and name[0]<=c'z'  # TODO: cut out first part of expr?
				assert false, 'use findLocal() instead. [name]'
				return nil

			boxStack = Stack<of Box>(_boxStack)
			while boxStack
				box = boxStack.pop()
				x = box.symbolForName(name, canBeMember, haveThis)
				if x is not nil
					return x

			nameSpaceStack = Stack<of NameSpace>(_nameSpaceStack)
			while nameSpaceStack
				ns = nameSpaceStack.pop()
				assert ns.superNameSpace is nil or ns.superNameSpace is not nil
				x = ns.symbolForName(name)
				if x is not nil
					return x

			x = _curModule.symbolForName(name)
			if x is not nil
				return x

			return _globalNS.symbolForName(name)


	##
	## Services to nodes
	##

	def libraryType(names as vari String) as IType
		"""
		Used to retrieve types such as System.String.
		Example:
			.compiler.libraryType('System', 'String')
		"""
		ns as IContainer = _globalNS
		thing as IContainer? = nil
		for name in names
			possible = (thing ? ns).declForName(name)
			if possible inherits IContainer
				thing = possible
			else
				assert false, possible
		if thing inherits IType
			return thing
		else
			assert false, 'found [name], but it is not an IType. it is [thing]'


	##
	## Generating C#
	##

	def genCS
		pass

	def compileCS
		pass
