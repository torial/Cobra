use System.Reflection


class StopCompilation
	inherits Exception
	"""
	Thrown by the compiler when it must stop compilation due to errors. This can happen at the end
	of the phases:
		* parsing
		* bind interface
		* bind implementation
		* code gen
	"""

	var _comp as Compiler

	def init(comp as Compiler)
		_comp = comp


class UnexpectedInvocationException
	inherits SystemException
	"""
	Throw this when a class is not expecting a particular method to be invoked at runtime
	(even though it inherits it or must implement it for an interface).
	"""

	def init(obj as Object)
		base.init('Not expecting invocation.')


enum PlatformEnum
	Microsoft
	Novell


class Compiler
	implements ITypeProvider, IWarningRecorder
	"""
	General notes:

	To cope with nesting, the compiler keeps a stack of the three types of things that can be nested. Items are pushed and popped off these stacks during each of the "bind interface" and "bind implementation" phases. The three stacks are:
		* nameSpaceStack - namespaces
		* boxStack - boxes are classes, structs and interfaces
		* codeMemberStack - methods, properties and constructors
	"""

	var _nextSerialNum as int is shared
	var _serialNum as int
	var _verbosity as int
	var _options as Dictionary<of String, Object>
	var _willPrintSuccessMsg = true
	var _htmlWriter as HtmlWriter?
	
	var _globalNS as NameSpace
	var _modules as List<of Module>
	var _firstUserModuleIndex as int

	var _curModule as Module?  # set during bindInt and bindImp
	var _nameSpaceStack as Stack<of NameSpace>
	var _boxStack as Stack<of Box>
	var _codeMemberStack as Stack<of AbstractMethod>

	var _isBindingUse as bool
	var _isBindingInt as bool
	var _isBindingImp as bool

	var _errors as List<of SourceException>
	var _warnings as List<of SourceException>
	var _messages as List<of SourceException>  # all errors and warnings

	var _intermediateFileNames as List<of String>
	var _baseExeFileName as String = ''
	var _fullExeFileName as String = ''


	def init(verbosity as int)
		.init(verbosity, nil)

	def init(verbosity as int, initialModules as IList<of Module>?)
		_nextSerialNum += 1
		_serialNum = _nextSerialNum
		_verbosity = verbosity
		_modules = List<of Module>()
		_options = Dictionary<of String, Object>()
		_globalNS = NameSpace(Token.empty, '(global)')
		_nameSpaceStack = Stack<of NameSpace>()
		_boxStack = Stack<of Box>()
		_codeMemberStack = Stack<of AbstractMethod>()
		_errors = List<of SourceException>()
		_messages = List<of SourceException>()
		_warnings = List<of SourceException>()
		_intermediateFileNames = List<of String>()
		if initialModules
			if false  # TODO: the idea is to cache modules during testify, but it's not working right now
				for mod in initialModules
					if mod inherits AssemblyModule
						ns = mod.topNameSpace
						assert not ns.superNameSpace
						ns.reassignTo(_globalNS)
					# TODO: handle CobraModule too
					_modules.add(mod)

	def toString as String is override
		return '[.getType.name]([_serialNum])'

	get verbosity from var

	get isBindingUse from var

	get isBindingInt from var

	get isBindingImp from var

	get globalNS from var

	get modules from var

	pro options from var

	pro willPrintSuccessMsg from var
	
	get nameSpaceStack from var

	get boxStack from var

	get curBox as Box
		require .boxStack and .boxStack.count
		return _boxStack.peek

	get curCodeMember as AbstractMethod
		require .codeMemberStack.count
		return _codeMemberStack.peek

	get codeMemberStack from var

	get errors from var

	get warnings from var

	pro htmlWriter from var
		"""
		Set this to support the output-html command line option.
		"""

	get hasDetailedStackTraceOption as bool
		# CC: return _options.get('detailed-stack-trace', false) to bool
		if _options.containsKey('detailed-stack-trace')
			return if(_options['detailed-stack-trace'], true, false)
		else
			return false

	get willTrackLocals as bool
		require .boxStack.count
		# the code member stack can be empty due to class variables (ex: var _x = 1)
		return .hasDetailedStackTraceOption and (.codeMemberStack.count == 0 or .curCodeMember.box.name <> 'CobraFrame')

	get hasExceptionReportOption as bool
		# CC: return _options.get('exception-report', false) to bool
		if _options.containsKey('exception-report')
			return if(_options['exception-report'], true, false)
		else
			return false

	def recordError(error as SourceException)
		"""
		Node call this to record errors.
		"""
		if error inherits NodeMultiException
			for exc in error.exceptions
				_addMessage(exc)
		else
			_addMessage(error)

	def addIntermediateFile(path as String)
		_intermediateFileNames.add(path)
		
	get cobraExeDir as String
		"""
		Returns the directory where cobra.exe is residing.
		Related resources such as CobraLang.cs reside there.
		"""
		return Path.getDirectoryName(Assembly.getEntryAssembly.location)

	def parseFilesNamed(filenames as List<of String>) as List<of Module>
		"""
		Returns the modules for the newly parsed files.
		Also, extends _modules with those modules.
		"""
		require
			filenames
		ensure
			true
		body
			if _modules.count == 0  # attempt at caching modules during testify. incomplete.
				.writeSharpInfoClass
				.readSystemTypes
			if true # _modules.count == 0
				path = Path.combine(.cobraExeDir, 'SystemInterfaces.cobra')
				assert File.exists(path), path
				filenames.insert(0, path)
				path = Path.combine(.cobraExeDir, 'CobraLang.cobra')
				assert File.exists(path), path
				filenames.insert(1, path)
				path = Path.combine(.cobraExeDir, 'CobraInfo.cs')
				assert File.exists(path), path
				filenames.insert(2, path)
				_firstUserModuleIndex = 3
			modules = List<of Module>()
			for filename in filenames
				if filename.endsWith('.cs')
					if _verbosity>1
						print 'Noting [filename]'
					modules.add(SharpModule(filename, _verbosity))
				else
					parser = Parser()
					parser.verbosity = _verbosity
					parser.typeProvider = this
					parser.warningRecorder = this
					assert _globalNS
					parser.globalNS = _globalNS
					# @@ TODO: assert _globalNS is parser.nameSpaceStack[0]
					try
						module = parser.parseFileNamed(filename)
					catch ce as SourceException
						.recordError(ce)
					success
						assert module
						modules.add(module)
			assert modules
			_modules.addRange(modules)
			if _errors.count
				_exitFromErrors
			return modules


	##
	## ITypeProvider
	##

	var _boolType as BoolType?
	var _charType as CharType?
	var _decimalType as DecimalType?
	var _dynamicType as DynamicType?
	var _floatType as FloatType?
	var _intType as IntType?
	var _nilType as NilType?
	var _numberType as NumberType?
	var _passThroughType as PassThroughType?
	var _typeType as TypeType?
	var _unspecifiedType as UnspecifiedType?
	var _voidType as VoidType?
	var _variTypes as Dictionary<of INode, VariType>?

	def typeForName(name as String) as IType
		assert false, 'TODO'
		return CobraType()

	def typeOrNilForName(name as String) as IType?
		assert false, 'TODO'
		return nil

	get boolType as BoolType
		if _boolType is nil
			_boolType = BoolType()
		return _boolType to BoolType  # CC: to ! | CC: axe to !

	get charType as CharType
		if _charType is nil
			_charType = CharType()
		return _charType to CharType  # CC: to! | CC: axe to !

	get decimalType as DecimalType
		if _decimalType is nil
			_decimalType = DecimalType()
		return _decimalType to DecimalType  # CC: to! | CC: axe to !

	get dynamicType as DynamicType
		if _dynamicType is nil
			_dynamicType = DynamicType()
		return _dynamicType to DynamicType

	get intType as IntType
		if _intType is nil
			_intType = IntType()
		return _intType to IntType  # CC: to! | CC: axe to !

	get floatType as FloatType
		if _floatType is nil
			_floatType = FloatType()
		return _floatType to FloatType  # CC: to! | CC: axe to !

	get nilType as NilType
		if _nilType is nil
			_nilType = NilType()
		return _nilType to NilType  # CC: to! | CC: axe to !

	get numberType as NumberType
		if _numberType is nil
			_numberType = NumberType()
		return _numberType to NumberType  # CC: to! | CC: axe to !

	get passThroughType as PassThroughType
		if _passThroughType is nil
			_passThroughType = PassThroughType()
		return _passThroughType to PassThroughType  # CC: to ! | CC: axe to !

	get typeType as TypeType
		if _typeType is nil
			_typeType = TypeType()
		return _typeType to TypeType  # CC: to ! | CC: axe to !

	get unspecifiedType as UnspecifiedType
		if _unspecifiedType is nil
			_unspecifiedType = UnspecifiedType()
		return _unspecifiedType to UnspecifiedType  # CC: to ! | CC: axe to !

	get voidType as VoidType
		if _voidType is nil
			_voidType = VoidType()
		return _voidType to VoidType  # CC: to ! | CC: axe to !

	def variType(type as IType) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of INode, VariType>()
		else if _variTypes.containsKey(type)
			return _variTypes[type]
		_variTypes[type] = vt = VariType(type)
		return vt

	def variType(typeNode as INode) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of INode, VariType>()
		else if _variTypes.containsKey(typeNode)
			return _variTypes[typeNode]
		_variTypes[typeNode] = vt = VariType(typeNode)
		return vt

	## More type stuff

	def nilableType(t as IType) as NilableType
		"""
		Returns a NilableType wrapper for t, unless t is already a NilableType in which case
		it is returned directly.
		"""
		if t inherits NilableType
			return t
		else
			# CC: after supporting "as this" for return types, the following 3 lines can be:
			# return NilableType(t).bindAll
			t = NilableType(t)
			t.bindAll
			return t to NilableType  # CC: axe cast after code flow picks up on assignments

	def readSystemTypes
		# TODO: should pick up mscorlib.dll instead and based on what CLR version we're targeting. but that can wait for much later.
		t = Object
		.readSystemTypes(t.assembly) # mscorlib.dll
		t = $sharp('typeof(System.Diagnostics.Process)')
		.readSystemTypes(t.assembly) # System.dll
		.fixNonNilableMemberSigs  # TODO: this needs to happen after bindInh or before bindInt. unfortunately, bindInh isn't implemented yet!

	def readSystemTypes(ass as Assembly)
		namespaceQualNameToNameSpaceObject = Dictionary<of String, NameSpace>()
		module = AssemblyModule(ass, .globalNS)
		_modules.add(module)
		for type in ass.getExportedTypes
			if type.namespace == 'System.Configuration'
				# TODO
				# having various problems with System.Configuration
				continue
			if type.baseType and 'System.Configuration.dll' in type.baseType.assembly.location
				# TODO
				# this class is in System.dll but its base class is not there nor in mscorlib
				# instead its in an optional DLL called System.Configuration.dll that you don't even have to reference/link to 
				# one example class that is like this is ApplicationSettingsGroup
				# how does that work???
				continue
			if '__CompilerGenerated' in type.name  # TODO: does that work in .NET?
				continue
			if type.isNested or type.declaringType
				# TODO: nested types
				# print '### skipping [type.name] in [type.namespace]. isNested=[type.isNested], declaringType=[type.declaringType]'
				continue
			if '`' in type.name
				continue
			if namespaceQualNameToNameSpaceObject.containsKey(type.namespace)
				curNameSpace = namespaceQualNameToNameSpaceObject[type.namespace]
			else
				curNameSpace = module.topNameSpace
				for name in type.namespace.split(c'.')
					curNameSpace = curNameSpace.getOrMakeNameSpaceNamed(Token.empty, name)
					assert not curNameSpace.isUnified
				namespaceQualNameToNameSpaceObject[type.namespace] = curNameSpace
			if type.isClass
				curNameSpace.addDecl(Class(type))
			else if type.isInterface
				curNameSpace.addDecl(Interface(type))
			else if type.isEnum
				curNameSpace.addDecl(EnumDecl(curNameSpace, type, List<of String>(), ''))  # TODO: isNames; docString?
			else if type.isValueType
				curNameSpace.addDecl(Struct(type))
			else if type.isAnsiClass
				# The Enum class is an example that returns false for .isClass but true for .isAnsiClass
				curNameSpace.addDecl(Class(type))
			else
				throw FallThroughException(type)

	def fixNonNilableMemberSigs
		# TODO: look to see if what the Spec# team put together can be leveraged instead of recreating all this work!
		# fix up member sigs regarding nilable
		# hard coded below. TODO: read from a Cobra config file
		_fix('System.Object', 'toString getType memberwiseClone')
			# ^ regarding .toString, not technically true, but common enough and life is too painful when the return type is nilable
		_fix('System.String', 'replace toLower toUpper trim')
		_fix('System.Type', 'name')
		_fix('System.Environment', 'commandLine currentDirectory newLine version')
		_fix('System.IO.TextWriter', 'newLine')
		_fix('System.IO.Path', 'combine')
		# args: System.IO.Path.combine(arg1 as String, arg2 as String) as String
		_fix('System.Text.StringBuilder', 'toString')
		_fix('System.Diagnostics.Process', 'processName')
		_fix('System.Reflection.MemberInfo', 'name')

		# TODO: String really has no indexer? wtf? it has a char enumerator so why didn't they give it an indexer?
		stringClass = .libraryType('System', 'String') to Class
		stringClass.addDecl(Indexer(TokenFix.empty, stringClass, r'[]', [Param('index', .intType)], .charType, ['public'], ''))

		# TODO: axe these when .fixNonNilableMemberSigs is invoked after bindInh and before bindInterface
		_fix('System.IO.StringWriter', 'toString')

	def _fix(className as String, memberNames as String)
		_fix(.libraryType(className), memberNames)

	def _fix(t as IType, memberNames as String)
		for name in memberNames.split
			m = t.memberForName(name)
			if m
				m.unNilReturnType
				if t inherits Class
					if m inherits BoxMember
						if 'virtual' in m.isNames
							for sub in t.subclasses
								if sub.declForName(name)
									_fix(sub, name)
			else
				# TODO: print 'Cobra warning: Cannot find "[name]" in [t.name]'
				pass

	##
	## Binding
	##

	def bindUse
		require
			not .isBindingUse
			not .isBindingInt
			not .isBindingImp
		body
			_isBindingUse = true
			try
				Node.setCompiler(this)
				try
					for _curModule in _modules
						try
							_curModule.bindUse
						catch ce as SourceException
							.recordError(ce)
				finally
					Node.setCompiler(nil)
			finally
				_isBindingUse = false
			if _errors.count
				_exitFromErrors

	def bindInt
		require
			not .isBindingUse
			not .isBindingInt
			not .isBindingImp
		body
			# TODO: bindInt to all existing types
			_isBindingInt = true
			try
				Node.setCompiler(this)
				try
					for _curModule in _modules
						try
							_curModule.bindInt
						catch ce as SourceException
							.recordError(ce)
				finally
					Node.setCompiler(nil)
			finally
				_isBindingInt = false
			if _errors.count
				_exitFromErrors

	def bindImp
		require
			not .isBindingUse
			not .isBindingInt
			not .isBindingImp
		body
			# TODO: bindImp to all existing types
			_isBindingImp = true
			try
				Node.setCompiler(this)
				try
					for _curModule in _modules
						try
							_curModule.bindImp
						catch ce as SourceException
							.recordError(ce)
				finally
					Node.setCompiler(nil)
			finally
				_isBindingImp = false
			if _errors.count
				_exitFromErrors

	def symbolForName(name as String, canBeMember as bool, haveThis as bool) as IMember?
		"""
		name - obvious.
		canBeMember - the symbol can be a member of the current box
			TODO: can this be retired now that there is findLocal?
		haveThis - if false, symbols like methods, properties, etc. will not be returned while enums, nested classes, etc. could be.
		"""
		require
			name
		body
			# TODO: remove canBeMember arg
			assert _curModule
			if _boxStack.count
				#print '>> .compiler.symbolForName([name], [canBeMember], [haveThis])'
				if name[0].toString.toLower==name[0] and name[0]>=c'a' and name[0]<=c'z'  # CC: if name[0].isLower
					assert false, 'use findLocal instead. [name]'
					return nil
				m = _boxStack.peek.symbolForName(name, haveThis)
				#print '<< .compiler.symbolForName returning', m
				#print
				return m
			else
				# example is an enum directly in a namespace with a ClrType instance created from clrType.getUnderlyingType
				return ((_curModule to dynamic).topNameSpace).symbolForName(name)  # TODO: cast is kind of weird, but SharpModule has no .topNameSpace

	def dumpModulesForTestify(output as IndentedWriter)
		.dumpModulesForTestify(output, 'Modules')

	def dumpModulesForTestify(output as IndentedWriter, title as String)
		print '[title]:'
		output.indent
		try
			for module in _modules
				if module.isCobraLibrary
					continue
				module.writeDeepString(output)
		finally
			output.dedent

	def _exitFromErrors
		require _errors
		.printMessages
		throw StopCompilation(this)

	def printMessages
		if .htmlWriter
			.printHtmlMessages
		else
			.printConsoleMessages
		Environment.exitCode = if(.errors.count, 1, 0)

	def printHtmlMessages
		require .htmlWriter
		dest = .htmlWriter to HtmlWriter
		dest.writeHtml('<table class=messages cellpadding=2 cellspacing=2>[dest.newLine]\n')
		dest.writeHtml('<tr class=headings> <td class=heading> File </td> <td class=heading> Line </td> <td class=heading> Type </td> <td class=heading> Message </td> </tr>\n')
		for msg in _messages
			msg.writeHtmlTo(dest)
		dest.writeHtml('</table>[dest.newLine]')
		if _errors.count
			dest.writeHtml('<span class=compilationFailed>[_compilationFailedMessage()]</span><br>\n')  # CC: axe ()s
		else
			dest.writeHtml('<span class=compilationSucceeded>Compilation succeeded - [_warnings.count] warning[if(_warnings.count==1,'','s')]</span><br>\n')

	def printConsoleMessages
		if _options.containsKey('color')
			assert _options['color'] in [true, false]
			willColor = _options['color'] to bool
		else
			willColor = false
		savedColor = Console.foregroundColor
		if CobraCore.isRunningOnMono  # bug on mono: the initial Console.foregroundColor is not necessarily accurate (at least in bash on Terminal.app on Mac OS X 10.4.10 on Mono 1.2.4)
			savedColor = ConsoleColor.Black  # this is really just a guess and possibly a bad one. should be controllable via a cmd line option or argument
		for obj in _messages
			if willColor and obj.isError
				Console.foregroundColor = ConsoleColor.Red
				restoreColor = true
			print obj.consoleString
			if restoreColor
				Console.foregroundColor = savedColor
				restoreColor = false
		if _errors.count
			if willColor
				Console.foregroundColor = ConsoleColor.Red
			print _compilationFailedMessage()  # CC: axe ()s
			if willColor
				Console.foregroundColor = savedColor
		else
			didPrint = false
			if willColor
				Console.foregroundColor = ConsoleColor.Blue
			if _willPrintSuccessMsg or _warnings.count
				print 'Compilation succeeded' stop
				didPrint = true
			if _warnings.count
				print ' - [_warnings.count] warning[if(_warnings.count==1,'','s')]'
			else
				if didPrint
					print
			if willColor
				Console.foregroundColor = savedColor
	
	def _compilationFailedMessage as String
		return 'Compilation failed - [_errors.count] error[if(_errors.count==1,'','s')], [_warnings.count] warning[if(_warnings.count==1,'','s')]'
	
	##
	## Services to nodes
	##

	def canNameBeUndottedMember(name as String) as bool
		"""
		Returns true if the given name is the kind of name that can reference a box member without
		using the dot operator. Returns true if the name starts with an underscore or capital
		letter. The underscored names are typically protected data fields or methods while the
		uppercase names would be enums or (in the future) nested boxes.
		"""
		return name.startsWith('_') or Utils.isCapped(name)

	def findLocal(name as String) as AbstractLocalVar?
		"""
		Finds a local parameter or variable in the current code member.
		"""
		require
			.isBindingImp
			.codeMemberStack
		body
			return .codeMemberStack.peek.findLocal(name)

	def libraryType(names as vari String) as IType
		"""
		Used to retrieve types such as System.String.
		Example:
			.compiler.libraryType('System', 'String')
		TODO: In retrospect, the argument should just be 'System.String'
		"""
		ns as IContainer = _globalNS
		thing as IContainer? = nil
		for name in names
			possible = (thing ? ns).declForName(name)
			assert possible, name
			if possible inherits IContainer
				thing = possible
			else
				assert false, [name, possible.getType.name, possible]
		if thing inherits IType
			if thing.name<>names[names.length-1] # TODO: add this as an ensure as well
				print 'names=' stop
				print CobraCore.toTechString(names)
				print 'thing=[thing]'
				assert false
			return thing
		else
			throw FallThroughException('found [name], but it is not an IType. it is [thing]')
	
	def libraryType(qualifiedName as String) as IType
		names = qualifiedName.split(c'.')
		return .libraryType(names to passthrough)

	def classType(names as vari String) as Class
		return .libraryType(names) to Class

	def suggestionFor(name as String) as String?
		require name
		# CC: return _unknownSuggestions.getDefault(name, nil)
		if _unknownSuggestions.containsKey(name)
			return _unknownSuggestions[name]
		else
			return nil

	def warning(node as ISyntaxNode, msg as String)
		require msg
		.warning(CobraWarning(node.token, msg))

	def warning(cw as CobraWarning)
		require not cw.isError
		_warnings.add(cw)
		_messages.add(cw)

	var _unknownSuggestions = {
		# literals
		'null':		'nil',
		'NULL':		'nil',
		'None':		'nil',
		'Nothing':	'nil',
		'True':		'true',
		'False':	'false',

		# special
		'self':		'this',
		'super':	'base',

		# operators (word ones anyway)
		'isa':		'inherits',
		'new':		'SomeClass() or SomeClass(arg1,arg2) without new',

		# constructs
		#'lambda':	'def(args) ...',  # TODO

		# statements
		'do':		'post while <condition>',
		'elif':		'else if',
		'elseif':	'else if',
		'foreach':	'for',
		'throw':	'raise',

		# types
		'boolean':	'bool',
		'double':	'float',
		'single':	'float32',
		'str':		'string',
		# TODO: various int types like short, byte, long
	}

	get unknownSuggestions from var


	##
	## Services to this
	##

	def _addMessage(message as SourceException)
		_messages.add(message)
		if message.isError
			_errors.add(message)
		else
			_warnings.add(message)


	##
	## Generating and compiling C#
	##

	var _moduleFileName_to_sharpToCobraLineNum as Dictionary<of String, Dictionary<of int, int>>?

	def writeSharp
		Node.setCompiler(this)
		try
			_moduleFileName_to_sharpToCobraLineNum = Dictionary<of String, Dictionary<of int, int>>()
			for module in _modules  # CC: make that _curModule and axe following assignment statement
				if not module.fileName.endsWith('SystemInterfaces.cobra')
					_curModule = module
					sharpToCobraLineNum = _curModule.writeSharpDef
					_moduleFileName_to_sharpToCobraLineNum[module.fileName] = sharpToCobraLineNum
					_moduleFileName_to_sharpToCobraLineNum[Path.getFullPath(module.fileName)] = sharpToCobraLineNum
		finally
			Node.setCompiler(nil)

	def writeSharpTestInvocation
		dt = DateTime.now
		fileName = 'test-[dt.year][dt.month][dt.day][dt.hour][dt.minute].cs'  # TODO: format the numbers to have leading zeros
		using f = SharpWriter(File.createText(fileName))
			print to f
				print 'using System;'
				print 'using Cobra.Lang;'
				print ''
				print 'class RunTests {'
				print ''
				print '	public static void Main() {'
				print '		CobraImp.ShowTestProgress = true;'
				if .hasExceptionReportOption
					print '		bool success = false;'
					print '		try {'
				for module in _modules
					module.writeSharpTestInvocation(f)
				if .hasExceptionReportOption
					print '		success = true;'
					print '		} catch (Exception e) {'
					print '			CobraCore.HandleUnhandledException(e);'
					print '		}'
					print '		if (success)'
				print '		CobraImp.TestProgressWriter.WriteLine("\\nSuccess!  All tests pass.\\n");'
				print '	}'
				print '}'
		_modules.add(SharpModule(fileName, _verbosity))

	var _didWriteSharpInfoClass as bool

	def writeSharpInfoClass
		"""
		The Cobra.Lang.Info class is compiled into the program and contains, at least, the path to the cobra.exe.
		This is used for, at least, the implementation of CobraCore.findCobra.
		"""
		if _didWriteSharpInfoClass
			return
		cobraExePath = CobraCore.exePath
		assert File.exists(cobraExePath)
		infoPath = Path.combine(Path.getDirectoryName(cobraExePath), 'CobraInfo.cs')
		using sw = File.createText(infoPath)
			print to sw
				print 'using System;'
				print 'namespace Cobra.Lang {'
				print '    class CobraInfo {'
				print '        static public String CobraPath {'
				print '            get { return @"[cobraExePath]"; }'
				print '        }'
				print '    }'
				print '}'
		_didWriteSharpInfoClass = true

	var _cscExecPaths = [
		[r'\WINDOWS\Microsoft.NET\Framework\v2.0.50727\csc', 'ms'],  # common
		[r'\WINNT\Microsoft.NET\Framework\v2.0.50727\csc', 'ms'],
		[r'/usr/bin/gmcs', 'novell'],  # common
		[r'/bin/gmcs', 'novell'],
		[r'/usr/local/bin/gmcs', 'novell'],
	]

	get baseExeFileName from var
		"""
		Returns the exe file name sans extension.
		"""

	get fullExeFileName from var
		"""
		Returns the exe file name with extension.
		"""

	var _platform as PlatformEnum

	get platform from var

	def compileCS
		.compileCS('')

	def compileCS(extraCscOptions as String)  # TODO: rename to compileSharp
		require
			.options
			.modules
			# CC: why does the folowing expression generate C# errors? 2007-11-21 Novell Mono 1.2.4. Could be code gen problem
			# 'SystemInterfaces' in (for mod in .modules get mod.fileName)  # TODO: food for thought: this is inefficent because all fileNames are collected when we could just get out upon hitting the first SystemInterfaces
#			.modules[0].fileName.endsWith('SystemInterfaces.cobra')  # no longer the first module
		body
			# locate the C# compiler
			found = false
			for execPathSpec in _cscExecPaths
				cscPath = execPathSpec[0]
				platform = execPathSpec[1]
				if File.exists(cscPath) or File.exists(cscPath+'.exe')
					found = true
					break
			if not found
				print 'Looked for C# compiler at:'
				for execPathSpec in _cscExecPaths
					cscPath = execPathSpec[0]
					print '  [cscPath]'
				print 'But cannot find a C# compiler from Microsoft .NET or Novell Mono.'
				throw StopCompilation(this)

			assert platform in ['ms', 'novell']
			_platform = if(platform=='ms', PlatformEnum.Microsoft, PlatformEnum.Novell)
			optChar = if(platform=='ms', '/', '-')  # option prefix character

			# exe names
			# CC: exe = if(Utils.getSO(_options, 'test', nil), _modules[_modules.count-1].csFileName, _modules[_firstUserModuleIndex].csFileName)
			outName = if(Utils.getSO(_options, 'test', nil), _modules[_modules.count-1].csFileName, _modules[_firstUserModuleIndex].csFileName)
			if outName.endsWith('.cs')
				outName = outName.substring(0, outName.length-3)  # CC: cannot slice nilable, [:-3]
			if outName.endsWith('.cobra')
				outName = outName.substring(0, outName.length-6)  # CC: cannot slice nilable, [:-6]
			_baseExeFileName = outName to String  # CC: to !  CC: axe cast

			# options
			options = ''

			target = Utils.getSO(_options, 'target', '') to String
			if target and target.length
				if target=='lib'
					target = 'library'
				options += ' [optChar]target:[target]'
				# TODO: what is the output for a module?
				branch target
					on 'exe', 'winexe': outName += '.exe'
					on 'library': outName += '.dll'
					on 'module': outName += '.netmodule'  # http://msdn2.microsoft.com/en-us/library/58scf68s(VS.80).aspx
					else: throw FallThroughException(target)
			else
				outName += '.exe'
			_fullExeFileName = outName to String  # CC: to !  CC: axe cast

			thing = Utils.getSO(_options, 'reference', List<of String>()) to List<of String>  # CC: cleanup
			for refer in thing
				options += ' [optChar]r:[refer]'

			debug = Utils.getSO(_options, 'debug', '') to String
			if debug.length
				# TODO: mono does not support full and pdbonly afaik
				assert debug in ['-', '+', 'full', 'pdbonly'], debug
				options += ' [optChar]debug' + if(debug.length==1, debug, ':[debug]')

			options += ' "[optChar]out:[outName]"'  # TODO: mono?

			if _verbosity<3
				options += ' [optChar]nologo'  # TODO: mono?

			options += ' ' + extraCscOptions

			# .cs files
			csFileNameList = List<of String>()
			for module in _modules.getRange(1, _modules.count-1)  # CC: use range
				csFileNameList.add('"' + module.csFileName to String + '"')  # CC: shouldn't need cast
			csFileNames = Utils.join(' ', csFileNameList)

			# compilation command
			cobraLangPath = Path.combine(.cobraExeDir, 'CobraLang.cs')
			assert File.exists(cobraLangPath), cobraLangPath

			if _verbosity
				print 'Compiling to produce [outName]'
			p as System.Diagnostics.Process = $sharp('new System.Diagnostics.Process()')
			p.startInfo.fileName = cscPath
			p.startInfo.arguments = '[options] [csFileNames] "[cobraLangPath]"'
			if _verbosity >= 2
				print '[p.startInfo.fileName] [p.startInfo.arguments]'
			output = CobraCore.runAndCaptureAllOutput(p)
			# TODO: check p.exitCode, especially if output is empty

			for line as String in output.split(c'\n')  # CC: axe as
				line = line.trim
				if not line.length
					continue
				if SharpCompilationMessage.willSkipMessage(line)
					continue
				if 'Unreachable code detected' in line
					# because Cobra forces you to put in a "return" stmt even though you have a "throw" and then C# warns about that  TODO: fix
					pass
				else if 'is assigned but its value' in line
					# Cobra catches this one itself
					pass
				else if line.startsWith('Compilation succeeded')
					# Novell Mono gmcs ends with this
					pass
				else if line.startsWith('Compilation failed')
					# Novell Mono
					pass
				else
					_addMessage(SharpCompilationMessage(line, this))
			if .errors.count
				_exitFromErrors

			# remove intermediate files such as *.cobra.cs
			if _intermediateFileNames.count == 0
				if _verbosity >= 1
					print 'No intermediate files to keep or delete.'
			else
				if Utils.getSO(_options, 'keep-intermediate-files', 0)
					if _verbosity >= 1
						print 'Keeping intermediate files.'
				else
					if _verbosity >= 1
						print 'Deleting intermediate files.'
					for fileName in _intermediateFileNames
						if _verbosity >= 3
							print 'Deleting', fileName
						File.delete(fileName)

	def cobraLineNumForSharp(fileName as String, lineNum as int) as int
		"""
		Returns the source cobra line number given a filename (sans ".cs") and line number in the
		generated C#. Used by SharpCompilationMessage.
		"""
		# for some reason the C# filenames come in with a lower case drive letter,
		# and in 2006 strings are *still* case sensitive.
		# *sigh*
		if fileName.length>=2 and fileName[1]==c':'
			fileName = Utils.capped(fileName)

		# TODO: handle relative paths like ..\foo.cobra which C# spells out as absolute paths

		# TODO: take out next 3 lines someday. was put in 2006-11-12
		if not _moduleFileName_to_sharpToCobraLineNum.containsKey(fileName)
			if 'CobraLang.cs' not in fileName
				print '<> Cannot find fileName "[fileName]" in:'
				for obj in _moduleFileName_to_sharpToCobraLineNum
					print '   [obj]'
			return lineNum  # better than not getting the error message
		sharpToCobraLineNum = _moduleFileName_to_sharpToCobraLineNum[fileName]
		if sharpToCobraLineNum.containsKey(lineNum)
			return sharpToCobraLineNum[lineNum]
		else
			# TODO: take this out someday. was put in 2006-11-12
			print '<> Cannot map C# location back to cobra.'
			print '   fileName = [fileName]'
			print '   lineNum = [lineNum]'
			print '   sharpToCobraLineNum = [CobraCore.toTechString(sharpToCobraLineNum)]'
			return sharpToCobraLineNum[lineNum]


class SharpCompilationMessage
	inherits SourceException

	def willSkipMessage(msg as String) as bool is shared
		# comes up on Novell Mono: '/Library/Frameworks/Mono.framework/Versions/1.2.4/lib/mono/2.0/mscorlib.dll (Location of the symbol related to previous error)'
		if '.dll' in msg
			if msg.endsWith(' (Location of the symbol related to previous error)')
				return true
			if msg.endsWith(' (Location of the symbol related to previous warning)')
				return true
		return false
		
	var _message as String
	var _fileName as String?
	var _lineNum as int?
	var _isError as bool
	
	def init(line as String, compiler as Compiler)
		require not .willSkipMessage(line)
		base.init(line)
		# example lines:
		# foo.cobra.cs(14,14): error CS0535: `Foo' does not implement interface member `IFoo.Baz()'
		# error CS5001: Program `bugs/bugs-no-main.exe' does not contain a static `Main' method suitable for an entry point
		# trace line
		line = line.trim
		_isError = 'error ' in line
		if line.startsWith('error CS')
			i = line.indexOf(': ')
			line = line[i+2:]
		else
			i = line.indexOf('(')
			if i <> -1
				fileName = line[:i-3]
				j1 = line.indexOf(',', i)
				j2 = line.indexOf(')', i)
				j = if(j1 < j2, j1, j2)
				lineStr = line[i+1:j]
				try  # CC: use tryParse
					sharpLineNum as int = int.parse(lineStr)  # CC: axe cast
				catch
					if compiler.verbosity or .isDevMachine
						line += ' (C#)'
				success
					_fileName = fileName
					_lineNum = compiler.cobraLineNumForSharp(_fileName to String, sharpLineNum)  # CC: axe cast
					i = line.indexOf(':')
					if i <> -1
						line = line[i+1:].trim
						_isError = line.startsWith('error')
						i = line.indexOf(':')
						if i <> -1 and i < line.length and line[i+1] == ' '
							line = line[i+1:].trim
					# add (sharp)
					if compiler.verbosity or .isDevMachine
						line += ' (C# [sharpLineNum])'
		_message = line

	get isDevMachine as bool
		return Environment.getEnvironmentVariable('COBRA_IS_DEV_MACHINE') == '1'

	get isError as bool is override
		return _isError
		
	get message as String is override
		return _message

	get hasSourceSite as bool is override
		return _fileName is not nil

	get fileName as String is override
		return _fileName to String  # CC: to !

	get lineNum as int is override
		return _lineNum to int  # CC: to !
