use System.Reflection


class UnexpectedInvocationException
	inherits SystemException
	"""
	Throw this when a class is not expecting a particular method to be invoked at runtime
	(even though it inherits it or must implement it for an interface).
	"""

	def init(obj as Object)
		base.init('Not expecting invocation.')


class Compiler
	implements ITypeProvider
	"""
	General notes:

	To cope with nesting, the compiler keeps a stack of the three types of things that can be nested. Items are pushed and popped off these stacks during each of the "bind interface" and "bind implementation" phases. The three stacks are:
		* nameSpaceStack - namespaces
		* boxStack - boxes are classes, structs and interfaces
		* codeMemberStack - methods, properties and constructors
	"""

	var _nextSerialNum as int is shared
	var _serialNum as int
	var _verbosity as int
	var _whenError as ErrorActionEnum
	var _whenWarning as WarningActionEnum
	var _options as Dictionary<of String, Object>
	var _globalNS as NameSpace
	var _modules as List<of Module>

	var _curModule as Module?  # set during bindInt() and bindImp()
	var _nameSpaceStack as Stack<of NameSpace>
	var _boxStack as Stack<of Box>
	var _codeMemberStack as Stack<of ICodePart>

	var _isBindingInt as bool
	var _isBindingImp as bool

	var _errors as List<of Exception>
	var _warnings as List<of CobraWarning>

	def init(verbosity as int)
		.init(verbosity, ErrorActionEnum.Exit)

	def init(verbosity as int, whenError as ErrorActionEnum)
		.init(verbosity, whenError, WarningActionEnum.Print)

	def init(verbosity as int, whenError as ErrorActionEnum, whenWarning as WarningActionEnum)
		_nextSerialNum += 1
		_serialNum = _nextSerialNum
		_verbosity = verbosity
		_modules = List<of Module>()
		_whenError = whenError
		_whenWarning = whenWarning
		_options = Dictionary<of String, Object>()
		_globalNS = NameSpace(Token.empty, '(global)')
		_nameSpaceStack = Stack<of NameSpace>()
		_boxStack = Stack<of Box>()
		_codeMemberStack = Stack<of ICodePart>()
		_errors = List<of Exception>()
		_warnings = List<of CobraWarning>()

	def toString as String is override
		return '[.getType().name]([_serialNum])'

	get verbosity from var

	get isBindingInt from var

	get isBindingImp from var

	get globalNS from var

	get modules from var

	pro whenError from var

	pro whenWarning from var

	pro options from var

	get nameSpaceStack from var

	get boxStack from var

	get curBox as Box
		require .boxStack
		return _boxStack.peek() to Box  # CC: axe typecast

	get codeMemberStack from var

	get errors from var

	get warnings from var

	get hasSuperStackTraceOption as bool
		# CC: return _options.get('superstacktrace', false) to bool
		if _options.containsKey('superstacktrace')
			return if(_options['superstacktrace'], true, false)
		else
			return false

	def recordErrorAndThrow(ce as CobraException) as bool
		"""
		Node call this to record errors which will actually be thrown if .whenError is ErrorActionEnum.Exit.
		"""
		_errors.add(ce)
		branch _whenError
			on ErrorActionEnum.Exit
				if _verbosity>1
					print 'About to throw node error: [ce]'
				return true
			on ErrorActionEnum.Record
				return false
			else
				throw FallThroughException(_whenError)

	get cobraExeDir as String
		"""
		Returns the directory where cobra.exe is residing.
		Related resources such as CobraLang.cs reside there.
		"""
		return Path.getDirectoryName(Assembly.getEntryAssembly().location)

	def parseFilesNamed(filenames as List<of String>) as List<of Module>
		"""
		Returns the modules for the newly parsed files.
		Also, extends self.modules with those modules.
		"""
		require
			filenames
		ensure
			true
		body
			if _modules.count == 0
				path = Path.combine(.cobraExeDir, 'SystemInterfaces.cobra')
				assert File.exists(path), path
				filenames.insert(0, path)
			modules = List<of Module>()
			for filename in filenames
				# TODO: support C# code
#				if filename.endsWith('.cs')
#					if _verbosity>1
#						print 'Noting [filename]'
#					modules.add(SharpModule(filename))
#				else
				if 1
					if _verbosity>1
						print 'Parsing [filename]'
					parser = Parser()
					parser.verbosity = _verbosity
					parser.whenError = _whenError
					parser.whenWarning = _whenWarning
					parser.typeProvider = this
					assert _globalNS
					parser.globalNS = _globalNS
					# @@ TODO: assert _globalNS is parser.nameSpaceStack[0]
					try
						module = parser.parseFileNamed(filename)
					catch ce as CobraException
						if .recordErrorAndThrow(ce)
							throw
					assert module
					modules.add(module)
			assert modules
			_modules.addRange(modules)
			if _errors
				_exitFromErrors()
			return modules


	##
	## ITypeProvider
	##

	var _boolType as BoolType?
	var _charType as CharType?
	var _decimalType as DecimalType?
	var _dynamicType as DynamicType?
	var _floatType as FloatType?
	var _intType as IntType?
	var _nilType as NilType?
	var _numberType as NumberType?
	var _passThroughType as PassThroughType?
	var _typeType as TypeType?
	var _unspecifiedType as UnspecifiedType?
	var _voidType as VoidType?
	var _variTypes as Dictionary<of INode, VariType>

	def typeForName(name as String) as IType
		assert false, 'TODO'
		return CobraType()

	def typeOrNilForName(name as String) as IType?
		assert false, 'TODO'
		return nil

	get boolType as BoolType
		if _boolType is nil
			_boolType = BoolType()
		return _boolType to BoolType  # CC: to ! | CC: axe to !

	get charType as CharType
		if _charType is nil
			_charType = CharType()
		return _charType to CharType  # CC: to! | CC: axe to !

	get decimalType as DecimalType
		if _decimalType is nil
			_decimalType = DecimalType()
		return _decimalType to DecimalType  # CC: to! | CC: axe to !

	get dynamicType as DynamicType
		if _dynamicType is nil
			_dynamicType = DynamicType()
		return _dynamicType to DynamicType

	get intType as IntType
		if _intType is nil
			_intType = IntType()
		return _intType to IntType  # CC: to! | CC: axe to !

	get floatType as FloatType
		if _floatType is nil
			_floatType = FloatType()
		return _floatType to FloatType  # CC: to! | CC: axe to !

	get nilType as NilType
		if _nilType is nil
			_nilType = NilType()
		return _nilType to NilType  # CC: to! | CC: axe to !

	get numberType as NumberType
		if _numberType is nil
			_numberType = NumberType()
		return _numberType to NumberType  # CC: to! | CC: axe to !

	get passThroughType as PassThroughType
		if _passThroughType is nil
			_passThroughType = PassThroughType()
		return _passThroughType to PassThroughType  # CC: to ! | CC: axe to !

	get typeType as TypeType
		if _typeType is nil
			_typeType = TypeType()
		return _typeType to TypeType  # CC: to ! | CC: axe to !

	get unspecifiedType as UnspecifiedType
		if _unspecifiedType is nil
			_unspecifiedType = UnspecifiedType()
		return _unspecifiedType to UnspecifiedType  # CC: to ! | CC: axe to !

	get voidType as VoidType
		if _voidType is nil
			_voidType = VoidType()
		return _voidType to VoidType  # CC: to ! | CC: axe to !

	def variType(type as IType) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of INode, VariType>()
		else if _variTypes.containsKey(type)
			return _variTypes[type]
		_variTypes[type] = vt = VariType(type)
		return vt

	def variType(typeNode as INode) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of INode, VariType>()
		else if _variTypes.containsKey(typeNode)
			return _variTypes[typeNode]
		_variTypes[typeNode] = vt = VariType(typeNode)
		return vt

	## More type stuff

	def nilableType(t as IType) as NilableType
		"""
		Returns a NilableType wrapper for t, unless t is already a NilableType in which case
		it is returned directly.
		"""
		if t inherits NilableType
			return t
		else
			# CC: after supporting "as this" for return types, the following 3 lines can be:
			# return NilableType(t).bindAll()
			t = NilableType(t)
			t.bindAll()
			return t to NilableType  # CC: axe cast after code flow picks up on assignments

	##
	## Binding
	##

	def bindInt
		# TODO: bindInt to all existing types
		_isBindingInt = true
		try
			Node.setCompiler(this)
			try
				for module in _modules  # CC: make that _curModule and axe following assignment statement
					try
						_curModule = module
						_curModule.bindInt()
					catch ce as CobraException
						if .recordErrorAndThrow(ce)
							throw
			finally
				Node.setCompiler(nil)
		finally
			_isBindingInt = false
		if _errors
			_exitFromErrors()

	def bindImp
		# TODO: bindImp to all existing types
		_isBindingImp = true
		try
			Node.setCompiler(this)
			try
				for module in _modules  # CC: make that _curModule and axe following assignment statement
					try
						_curModule = module
						_curModule.bindImp()
					catch ce as CobraException
						if .recordErrorAndThrow(ce)
							throw
			finally
				Node.setCompiler(nil)
		finally
			_isBindingImp = false
		if _errors
			_exitFromErrors()

	def symbolForName(name as String, canBeMember as bool, haveThis as bool) as IMember?
		"""
		name - obvious.
		canBeMember - the symbol can be a member of the current box
			TODO: can this be retired now that there is findLocal()?
		haveThis - if false, symbols like methods, properties, etc. will not be returned while enums, nested classes, etc. could be.
		"""
		require
			name
		body
			assert _curModule

			# TODO: is canBeMember ever false?

			if name[0].toString().toLower()==name[0] and name[0]>=c'a' and name[0]<=c'z'  # TODO: cut out first part of expr?
				assert false, 'use findLocal() instead. [name]'
				return nil

			boxStack = Stack<of Box>(_boxStack)
			while boxStack
				box = boxStack.pop()
				x = box.symbolForName(name, canBeMember, haveThis)
				if x is not nil
					return x

			nameSpaceStack = Stack<of NameSpace>(_nameSpaceStack)
			while nameSpaceStack
				ns = nameSpaceStack.pop()
				assert ns.superNameSpace is nil or ns.superNameSpace is not nil
				x = ns.symbolForName(name)
				if x is not nil
					return x

			x = _curModule.symbolForName(name)
			if x is not nil
				return x

			return _globalNS.symbolForName(name)

	def dumpModulesForTestify(output as IndentedWriter)
		.dumpModulesForTestify(output, 'Modules')

	def dumpModulesForTestify(output as IndentedWriter, title as String)
		print '[title]:'
		output.indent()
		try
			for module as Module in _modules.getRange(1, _modules.count-1)  # CC: axe "as Module"
				module.writeDeepString(output)
		finally
			output.dedent()

	def _exitFromErrors
		require _errors
		for error in _errors
			print error.message
		throw CobraException(_errors[0].message)  # CommandLine's testify may want the first error message


	##
	## Services to nodes
	##

	def findLocal(name as String) as AbstractLocalVar?
		"""
		Finds a local parameter or variable in the current code member.
		"""
		require
			.isBindingImp
			.codeMemberStack
		body
			return .codeMemberStack.peek().findLocal(name)

	def libraryType(names as vari String) as IType
		"""
		Used to retrieve types such as System.String.
		Example:
			.compiler.libraryType('System', 'String')
		"""
		ns as IContainer = _globalNS
		thing as IContainer? = nil
		for name in names
			possible = (thing ? ns).declForName(name)
			if possible inherits IContainer
				thing = possible
			else
				assert false, possible
		if thing inherits IType
			if thing.name<>names[names.length-1] # TODO: add this as an ensure as well
				print 'names=' stop
				print $sharp(r"CobraCore.ToTechString(names)")
				print 'thing=[thing]'
				assert false
			return thing
		else
			assert false, 'found [name], but it is not an IType. it is [thing]'

	def suggestionFor(name as String) as String?
		require name
		# CC: return _unknownSuggestions.getDefault(name, nil)
		if _unknownSuggestions.containsKey(name)
			return _unknownSuggestions[name]
		else
			return nil

	def warning(node as ISyntaxNode, msg as String)
		require
			node
			msg
		body
			cw = CobraWarning(node.token, msg)
			_warnings.add(cw)
			# TODO: shouldn't this take action based on _whenError?
			print cw

	var _unknownSuggestions = {
		# literals
		'null':		'nil',
		'NULL':		'nil',
		'None':		'nil',
		'Nothing':	'nil',
		'True':		'true',
		'False':	'false',

		# special
		'self':		'this',
		'super':	'base',

		# operators (word ones anyway)
		'isa':		'inherits',
		'new':		'SomeClass() or SomeClass(arg1,arg2) without new',

		# constructs
		#'lambda':	'def(args) ...',  # TODO

		# statements
		'do':		'post while <condition>',
		'elif':		'else if',
		'elseif':	'else if',
		'foreach':	'for',
		'throw':	'raise',

		# types
		'boolean':	'bool',
		'double':	'float',
		'single':	'float32',
		'str':		'string',
		# TODO: various int types like short, byte, long
	}

	get unknownSuggestions from var

	##
	## Generating C#
	##

	var _moduleFileName_to_sharpToCobraLineNum as Dictionary<of String, Dictionary<of int, int> >

	def writeSharp
		Node.setCompiler(this)
		try
			_moduleFileName_to_sharpToCobraLineNum = Dictionary<of String, Dictionary<of int, int> >()
			for module in _modules  # CC: make that _curModule and axe following assignment statement
				if not module.fileName.endsWith('SystemInterfaces.cobra')
					_curModule = module
					sharpToCobraLineNum = _curModule.writeSharpDef()
					_moduleFileName_to_sharpToCobraLineNum[module.fileName] = sharpToCobraLineNum
		finally
			Node.setCompiler(nil)

	var _exeFileName as String

	var _cscExecPath = r'\WINDOWS\Microsoft.NET\Framework\v2.0.50727\csc'

	get exeFileName from var

	def compileCS
		require
			.options is not nil
			.modules
			.modules[0].fileName.endsWith('SystemInterfaces.cobra')
		body
			# exe names
			# CC: exe = if(Utils.getSO(_options, 'test', nil), _modules[_modules.count-1].csFileName, _modules[1].csFileName)
			exe = if(Utils.getSO(_options, 'test', nil), _modules[_modules.count-1].csFileName to passthrough, _modules[1].csFileName to passthrough) to String
			if exe.endsWith('.cs')
				exe = exe.substring(0, exe.length-3) # CC: [..-3]
			if exe.endsWith('.cobra')
				exe = exe.substring(0, exe.length-6) # CC: [..-6]
			exe += '.exe'
			_exeFileName = exe

			# options
			options = ''
			# CC: cleanup
			thing = Utils.getSO(_options, 'reference', [])
			if thing
				for refer in thing to List<of String>
					options += ' /r:' + refer
			debug = Utils.getSO(_options, 'debug', nil) to String
			if debug is nil
				pass
			else if debug==1
				options += ' /debug'
			else if debug==0
				options += ' /debug-'
			else
				assert debug in ['full', 'pdbonly'], debug
				options += ' /debug: [debug]'

			options += ' /out:' + exe

			options += ' /nologo'

			# .cs files
			csFileNameList = List<of String>()
			for module in _modules.getRange(1, _modules.count-1)  # CC: use range
				csFileNameList.add(module.csFileName to String)  # CC: shouldn't need cast
			csFileNames = Utils.join(' ', csFileNameList)

			# compilation command
			cobraLangPath = Path.combine(.cobraExeDir, 'CobraLang.cs')
			assert File.exists(cobraLangPath), cobraLangPath

			if _verbosity
				print 'Compiling to produce [exe]'
			p as System.Diagnostics.Process = $sharp('new System.Diagnostics.Process()')
			p.startInfo.fileName = _cscExecPath
			p.startInfo.arguments = options + ' ' + csFileNames + ' ' + cobraLangPath
			#if _verbosity >= 2  # TODO: restore
			if true
				print '[p.startInfo.fileName] [p.startInfo.arguments]'
			p.startInfo.redirectStandardOutput = true
			p.startInfo.useShellExecute = false
			p.start()
			output = p.standardOutput.readToEnd()
			p.waitForExit()

			hadError = false
			for line as String in output.split(c'\n')  # CC: axe as
				if line.indexOf('error ')<>-1
					_errors.add(SharpCompilationError(line, this))
					hadError = true
				else if line.indexOf('Unreachable code detected')<>-1  # because Cobra forces you to put in a "return" stmt even though you have a "throw" and then C# warns about that  TODO: fix
					print line
			if hadError
				_exitFromErrors()

			# remove C#
			if Utils.getSO(_options, 'deletegen', 0)
				for csFileName in csFileNameList
					File.delete(csFileName)

	def cobraLineNumForSharp(fileName as String, lineNum as int) as int
		"""
		Returns the source cobra line number given a filename (sans ".cs") and line number in the
		generated C#. Used by SharpCompilationError.
		"""
		return _moduleFileName_to_sharpToCobraLineNum[fileName][lineNum]


class SharpCompilationError
	inherits CobraException

	var _msg as String

	def init(line as String, compiler as Compiler)
		base.init(line)
		line = line.trim()
		i = line.indexOf(': error')
		if i<>-1
			# kill the " error CS0234" part
			j = line.indexOf(':', i+1)
			line = line.substring(0, i+': error'.length) + line.substring(j)
			# kill the ".cs"
			line = line.replace('.cs', '')
			# translate the line number
			i = line.indexOf('(')
			fileName = line.substring(0, i)
			j = line.indexOf(',', i)
			lineStr = line.substring(i+1, j-i-1)
			lineNum as int = int.parse(lineStr)  # CC: axe cast
			lineNum = compiler.cobraLineNumForSharp(fileName, lineNum)
			end = line.indexOf(')', j)
			line = line.substring(0, i+1) + lineNum.toString() + line.substring(end)
			# add (sharp)
			if compiler.verbosity
				line += ' (sharp)'
		_msg = line

	get message as String is override
		return _msg


namespace System

	namespace Reflection

		class Assembly
			is fake

			shared
				def getEntryAssembly as Assembly
					return nil to passthrough

			get location as String
				return ''
