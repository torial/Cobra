class Module
	inherits Node

	var _fileName as String
	var _csFileName as String?
	var _declsInOrder as List<of IMember>
	var _declsByName as Dictionary<of String, IMember>
	var _declsByNameCI as Dictionary<of String, IMember>
	var _docString as String?

	def init(fileName as String, verbosity as int, docString as String)
		require fileName
		base.init()
		_fileName = fileName
		_declsInOrder = List<of IMember>()
		_declsByName = Dictionary<of String, IMember>()
		_declsByNameCI = Dictionary<of String, IMember>()
		_docString = docString
		# TODO: what's going on with verbosity?

	get docString from var

	get fileName from var

	get csFileName from var

	get declsInOrder as List<of IMember>
		return _declsInOrder

	def addDecl(decl as IMember)
		require decl.name
		if decl in _declsInOrder
			# happens with double "namespace Foo" in the same module
			assert decl inherits NameSpace
			return
		if _declsByName.containsKey(decl.name)
			duplicate = true
			suffix = ''
			other = _declsByName[decl.name]
		else if _declsByNameCI.containsKey(decl.name.toLower())
			duplicate = true
			suffix = ' Declaration names must be unique (beyond just case).'
			other = _declsByNameCI[decl.name.toLower()]
		else
			_declsByName[decl.name] = decl
			_declsByNameCI[decl.name.toLower()] = decl
		if duplicate
			msg = 'The name "[decl.name]" was already declared'
			if other inherits ISyntaxNode
				msg += ' at line [other.token.lineNum]'
			msg += '. [suffix]'
			decl.throwError(msg)
		else
			_declsInOrder.add(decl)

	get csSource as String
		if _csFileName
			return File.readAllText(_csFileName to String)  # CC: axe cast
		else
			throw FallThroughException(_csFileName)

	def addSubFields is override
		.addField('declsInOrder', _declsInOrder)

	def symbolForName(name as String) as IMember?
		# TODO: make faster?
		for decl in _declsInOrder
			if decl.name==name
				return decl
		for decl in _declsInOrder
			if decl inherits UseDirective
				x = decl.findSymbol(name)
				if x
					return x
		return nil

	def addMinFields is override
		base.addMinFields()
		.addField('fileName', _fileName)

	def _bindInt is override
		base._bindInt()
		for decl in _declsInOrder
			try
				decl.bindInt()
			catch ne as NodeException
				.compiler.recordError(ne)

	def _bindImp is override
		base._bindImp()
		assert .didBindInt
		for decl in _declsInOrder
			try
				decl.bindImp()
			catch ne as NodeException
				.compiler.recordError(ne)

	def writeSharpDef as Dictionary<of int, int>
		# CC: mark abstract
		return nil to passthrough

	def writeSharpTestInvocation(sw as SharpWriter)
		for decl in _declsInOrder
			decl.writeSharpTestInvocation(sw)

class SharpModule
	inherits Module
	"""
	The purpose of a C# module is to allow the programmer to include .cs command for Cobra to
	incorporate in the final compilation.
	"""

	def init(fileName as String, verbosity as int)
		base.init(fileName, verbosity, '')
		_csFileName = fileName

	def writeSharpDef as Dictionary<of int, int> is override
		# kind of silly, but it works:
		d = Dictionary<of int, int>()
		for i = 1 .. Utils.countChars(File.readAllText(_csFileName to String), c'\n')+1  # CC: to !
			d[i] = i
		return d


class CobraModule
	inherits Module

	def init(fileName as String, verbosity as int, docString as String)
		base.init(fileName, verbosity, docString)

	def writeSharpDef as Dictionary<of int, int> is override
		base.writeSharpDef()
		_csFileName = _fileName + '.cs'
		file = File.createText(_csFileName to String)  # CC: axe cast
		using sw = SharpWriter(file)
			sw.write('// [_csFileName]\n')
			sw.write('// Generated by Cobra\n')  # TODO: put version number here
			sw.write('// on [DateTime.now]\n')
			# TODO: list op sys
			sw.write('\n')

			for decl in _declsInOrder
				decl.writeSharpDef(sw)
			d = sw.sharpToCobraLineNum
		return d
