class Property
	inherits ClassMember

	var _getPart as PropertyGetter?
	var _setPart as PropertySetter?
	var _coverVar as ClassMember  # TODO: should be ClassVar
	var _coverAccess as String
	var _returnType as IType?
	var _returnTypeNode as INode?

	def construct(token as IToken, box as Box, name as String, isNames as List<of String>, coverVar as ClassMember, coverAccess as String, docString as String)
		base.construct(token, box, name)
		# TODO: isNames
		# TODO: docString
		assert false, 'TODO'

	def construct(token as IToken, box as Box, name as String, returnTypeOrNode as INode, isNames as List<of String>, docString as String)
		base.construct(token, box, name)
		if returnTypeOrNode
			if returnTypeOrNode inherits IType
				_returnType = returnTypeOrNode
				_returnTypeNode = nil
			else if returnTypeOrNode inherits INode
				_returnType = nil
				_returnTypeNode = returnTypeOrNode
			else
				throw FallThroughException(returnTypeOrNode)
		_isNames = isNames
		# TODO: .defaultToVirtual()

	get returnType from var

	get returnTypeNode from var

	get resultType as IType is override
		assert .didBindInt
		assert _returnType
		return _returnType to IType  # CC: axe when code flow understands the assert

	get getPart from var

	get setPart from var

	def addRefFields is override
		base.addRefFields()
		if _coverVar
			.addField('coverVar', _coverVar)
		if _returnType
			.addField('returnType', _returnType)
		else
			.addField('returnTypeNode', _returnTypeNode)

	def addSubFields is override
		base.addSubFields()
		if _getPart
			.addField('getPart', _getPart)
		if _setPart
			.addField('setPart', _setPart)


# TODO:
#	def defaultToVirtual is override
#		if .isClassMember
#			base.defaultToVirtual()

	get defaultAccessLevel as String is override
		if .isClassMember
			return 'public'
		else
			return ''

	get isCallable as bool is override
		return false

	get englishName as String is override
		return 'property'

	def _bindInt is override
		base._bindInt()
		for param in .params
			param.bindInt()
		if _returnType is nil
			if _coverVar
				_coverVar.bindInt()
				assert _coverVar.resultType, _coverVar
				_returnType = _coverVar.resultType
			else
				assert _returnTypeNode
				_returnTypeNode.bindInt()
				_returnType = _returnTypeNode.namedType
		_returnType.bindInt()
		assert _returnType  # properties always have a return type
		if _getPart
			_getPart.bindInt()
		if _setPart
			_setPart.bindInt()

	def _bindImp is override
		base._bindImp()
		if _getPart
			_getPart.bindImp()
		if _setPart
			_setPart.bindImp()

	def makeGetPart(token as IToken) as PropertyGetter
		require .getPart is nil
		ensure .getPart!
		_getPart = PropertyGetter(token, this)
		return _getPart to PropertyGetter  # CC: to ! | CC: shouldn't need because of assignment

	def makeSetPart(token as IToken) as PropertySetter
		require .setPart is nil
		ensure .setPart!
		_setPart = PropertySetter(token, this)
		return _setPart to PropertySetter  # CC: to ! | CC: shouldn't need because of assignment

#	def genCS(out)
#		if .params
#			assert .name=='[]'
#			out.write('\n%s %s this' % (.isNamesCS(), .returnType.asCS()))
#			.genCSParams(out, parens='[]')
#			out.write(' {\n')
#		else
#			out.write('\n%s %s %s {\n' % (.isNamesCS(), .returnType.asCS(), capped(.name)))
#		out.indent()
#		if .coverVar
#			if .coverAccess in ('getset', 'get')
#				out.write('get { return %s; }' % .coverVar.csName)
#			if .coverAccess in ('getset', 'set')
#				out.write('set { %s = value; }' % .coverVar.csName)
#		else
#			if .getPart
#				if .isClassMember
#					.getPart.genCS(out)
#				else if .isInterfaceMember
#					out.write('\tget;\n')
#				else
#					throw FallThroughException()
#			if .setPart
#				if .isClassMember
#					.setPart.genCS(out)
#				else if .isInterfaceMember
#					out.write('\tset;\n')
#				else
#					throw FallThroughException()
#		out.dedent()
#		out.write('}\n')
#		.genCSTest(out)


class PropertyXetter
	inherits OneCodeBlockMember
	"""
	Base class for PropertyGetter and PropertySetter.
	"""

	var _prop as Property

	def construct(token as IToken, prop as Property)
		base.construct(token, prop.box, prop.name, '', List<of Param>())
		_name = prop.name + '.' + .propPartName  # CC: somewhat awkward. belongs in the base.construct() call
		_prop = prop

	get propPartName as String
		throw OverrideException(.getType())
		return '(override propPartName)'

	get isShared as bool is override
		return _prop.isShared

#	def genCS(out)
#		out.write(self.propPartName)
#		self.genCSImp(out)


class PropertyGetter
	inherits PropertyXetter

	def construct(token as IToken, prop as Property)
		base.construct(token, prop)

	get propPartName as String is override
		return 'get'

	def _bindInt is override
		base._bindInt()
		_returnType = _prop.returnType
		assert _returnType


class PropertySetter
	inherits PropertyXetter

	def construct(token as IToken, prop as Property)
		base.construct(token, prop)

		# make a token for the Param()
		t = token.copy
		t.which = 'ID'
		t.text = 'value'
		t.value = 'value'

		if prop.returnType
			p = Param(t, prop.returnType, true)
		else if prop.returnTypeNode
			p = Param(t, prop.returnTypeNode, true)
		else
			throw FallThroughException(prop)
		_params.add(p)

	get propPartName as String is override
		return 'set'

	def _bindInt is override
		base._bindInt()
		_returnType = .compiler.voidType
		assert _returnType
