"""
The Cobra Parser
"""


class Parser
	"""
	Notes:

		* The tokenizer's verbosity is set to 4 less than the parser's. In other words, the
		  tokenizer will not print messages unless the parser's verbosity is 5 or greater.

	"""

	test
		p = Parser()
		module = p.parseSource('class Test\n\tpass\n')
		assert module
		decls = module.declsInOrder
		decl = decls[decls.count-1]
		if decl inherits Class
			assert decl.name == 'Test'
		else
			assert false, decl

		module = Parser().parseSource('class Test\n\tdef main is shared\n\t\treturn\n')

	enum WhenError
		exit

	enum WhenWarning
		emit
		throww

	var _lowercaseLetters = 'abcdefghijklmnopqrstuvwxyz'
	var _uppercaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

	var _fileName as String?
	var _willShowTokens = false
	var _verbosity = 0

	var _tokens as List<of IToken>?
	var _curTokenIndex as int

	var _isNamesStack as Stack<of String>?
	var _boxStack as Stack<of Box>?


	def construct
		_boxStack = Stack<of Box>()

	def parseFileNamed(fileName as String) as Module
		_fileName = fileName
		source = File.readAllText(_fileName to String)  # CC: axe "to String" when "if" gets smart about non-nil
		return .parseSource(source)

	def parseSource(source as String) as Module
		"""
		Parses module source code and returns resulting module.
		"""
		if not _fileName
			_fileName = '(no file name)'
		tokVerbosity = _verbosity - 4  # in order words, tokenizer does not spew unless our verbosity is 5 or greater
		if tokVerbosity<0
			tokVerbosity = 0

		_isNamesStack = Stack<of String>()  # for `shared` for example

		_tokens = nil
		try
			_tokens = CobraTokenizer(tokVerbosity).startSource(source).allTokens()
		catch te as TokenizerError
			print '<> Caught TokenizerError'
			print te
			assert false
		_curTokenIndex = 0

		return .parseTokens()


	## Tokens

	def grab as IToken?
		"""
		Returns the next token or nil if there are none left.
		"""
		if _curTokenIndex >= _tokens.count
			return nil
		token = _tokens[_curTokenIndex]
		_curTokenIndex += 1
		if _willShowTokens
			print 'grab    --> [token]'
		return token

	def undo
		"""
		Undoes the last token() call. Often called "push" in parser examples.
		"""
		require _curTokenIndex>0
		_curTokenIndex -= 1
		if _willShowTokens
			print 'undo'

	def peek as IToken?
		return .peek(0)

	def peek(offset as int) as IToken?
		"""
		Returns a token without changing the current token, or nil if none left.
		With no offset, returns the current token, otherwise peeks ahead.
		"""
		i = _curTokenIndex + offset
		if i < _tokens.count
			token = _tokens[i]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'peek([offset]) --> [token]'
		return token

	get last as IToken?
		"""
		Returns the last token returned by get() or nil if get() was never invoked.
		"""
		if _curTokenIndex > 0
			token = _tokens[_curTokenIndex]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'last    --> [token]'
		return token

	def expect(whatTypes as vari String) as IToken?
		"""
		Gets a token and complains if its type does not match whatType(s).
		Returns the token.
		"""
		t = .grab()
		if _willShowTokens
			print 'expect([whatTypes]) --> [t]'
		if t is nil
			_error('Expecting [.join(" or ",whatTypes)], but source ended suddenly.')
		# CC: support "not in" on vari type
		#if t.which not in whatTypes
		#	_error('Expecting [whatTypes], but got [t] instead.')
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if not found
			_error('Expecting [.join(" or ",whatTypes)], but got [t] instead.')
		return t

	def join(sep as String, stuff as vari String) as String
		# CC: have a join() method for vari, List, IEnumerable, array, etc.; use that and axe this helper method
		sb = StringBuilder()
		sep2 = ''
		for x in stuff
			sb.append(sep2)
			sb.append(x)
			sep2 = sep
		return sb.toString()

	def optional(whatTypes as vari String) as IToken?
		"""
		Gets a token, but only if it matches whatTypes.
		Does not complain or consume a token if there is no match.
		"""
		t = .peek()
		if _willShowTokens
			print 'optional([whatTypes]) --> [t]'
		if t is nil
			return nil
		# CC: support "in" on vari type
		#if t.which in whatTypes
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if found
			return .grab()
		else
			return nil

	def oneOrMore(which as String)
		"""
		Consumes the expected token and any other additional contiguous ones.
		Returns nothing.
		Example:  .oneOrMore('EOL')
		"""
		.expect(which)
		while .peek().which == which
			.grab()


	## Parsing

	var _module as Module

	def parseTokens as Module
		"""
		Parses and then returns an instance of Module.
		"""
		_module = CobraModule(_fileName, _verbosity)  # TODO: does module really need verbosity?
		if not _fileName.endsWith('SystemInterfaces.cobra')
			# default use directives
			_module.addDecl(UseDirective(nil, ['System']))
			_module.addDecl(UseDirective(nil, ['System', 'Collections', 'Generic']))
			_module.addDecl(UseDirective(nil, ['System', 'IO']))
			_module.addDecl(UseDirective(nil, ['System', 'Text']))
			_module.addDecl(UseDirective(nil, ['Cobra', 'Lang']))
		# TODO: _module.docString = .docString()
		what as Node?
		while true
			what = nil
			addToNS = true
			tok = .peek()
			if tok is nil
				break
			branch tok.which
				on 'USE':       what = .useDirective()
				on 'IMPORT':    what = .importDirective()
				on 'CLASS':     what = .classDecl()
				on 'INTERFACE': what = .interfaceDecl()
				on 'STRUCT':    what = .structDecl()
				on 'ENUM':      what = .enumDecl()
				on 'EOL':       .grab()
				on 'NAMESPACE'
					.nameSpaceDecl()
					addToNS = false
				else
					_error('Expecting use, import, namespace, class, interface or enum, but got [tok]')
					break
			if what
				_module.addDecl(what to Node)  # CC: axe typecast
# TODO:
#				if addToNS
#					_globalNS.addDecl(what)

		return _module

	def useDirective as Node
		return Node()

	def importDirective as Node
		return Node()

	def classDecl as Node
		.expect('CLASS')
		peek = .peek().which
		if peek == 'ID'
			token = .expect('ID')
			name = token.value to String
		else if peek == 'OPEN_GENERIC'
			token = .expect('OPEN_GENERIC')
			name = token.value to String
		else
			_error('Expecting a class name.')
		if name[0] not in _uppercaseLetters
			_error('Class names must start with an uppercase letter in order to avoid collisions with other identifiers such as arguments and local variables.')

#		params = []
#		if token.which=='OPEN_GENERIC'
#			expectComma = false
#			while 1
#				if .peek().which=='GT'
#					.get()
#					break
#				if expectComma
#					.expect('COMMA')
#				ident = .expect('ID').value
#				params.append(GenericParam(ident))
#				expectComma = true

		.indent()

		isNames = .isDeclNames()

#		while .optional('WHERE')
#			if token.which!='OPEN_GENERIC'
#				_error('Unexpected where clause for non-generic class.')
#			paramName = .expect('ID').value
#			found = false
#			for param in params
#				if param.name==paramName
#					found = true
#					break
#			if not found
#				_error('Unknown generic parameter "%s".' % name)
#			if param.constraints
#				_error('Already specified constraints for "%s".' % name)
#			.expect('MUST')
#			.expect('BE')
#			expectComma = false
#			while 1
#				if expectComma
#					.expect('COMMA')
#				param.constraints.append(.genericConstraint())
#				if .optional('EOL')
#					break
#				expectComma = true
		paramList = List<of Node>() # TODO: axe

		baseName as String?
		if .optional('INHERITS')
			baseName = .expect('ID').text
			.expect('EOL')
		else
			baseName = nil

#		interfaceNames = []
#		if .optional('IMPLEMENTS')
#			expectComma = false
#			while 1
#				if .peek().which=='EOL'
#					.get()
#					break
#				if expectComma
#					.expect('COMMA')
#				interfaceName = .type()  # using .type since interface could be a generic like IEnumerable(of T)
#				interfaceNames.append(interfaceName)
#				expectComma = true
		interfaceNames = List<of String>()  # TODO: axe

		docString = .docString()

		theClass = Class(name, paramList, isNames, baseName, interfaceNames, docString)

		# TODO when supporting nested classes, look at the clintDeclStack and set a back pointer here
		_boxStack.push(theClass)
#		.isNamesStack = Stack(str)
		.classMemberDecls(theClass)
		_boxStack.pop()

		return theClass

	def docString as String?
		return nil  # TODO

	def indent
		if .optional('COLON')
			_warning('Colons are not used to start indented blocks.')
		.expect('EOL')
		while .optional('EOL')
			pass
		.expect('INDENT')

	var _validIsNames as List<of String>?

	def isDeclNames as List<of String>
		"""
		Example source:
			# The | below is not literal--it's where this method starts parsing.
			def Compute()
				|is virtual, protected
		Example return values:
			[]
			['shared']
			['private', 'shared']
		Errors:
			TODO
		Used by: classDecl, interfaceDecl, enumDecl, indentIsDeclNames
		"""
		if _validIsNames is nil
			_validIsNames = ['fake', 'shared', 'virtual', 'nonvirtual', 'override', 'public', 'protected', 'private', 'internal']
		names = List<of String>()
		if _isNamesStack
			names.add(_isNamesStack.peek())
#		names = if(_isNamesStack, [_isNamesStack.peek()], List<of String>())
		isWord = .optional('IS')
		if isWord is nil
			return names
		while true
			what = .grab().text
			if what in _validIsNames
				names.add(what)
			else
				_error('Not expecting "[what]".')
			comma = .optional('COMMA')
			if comma is nil
				break
		.oneOrMore('EOL')
		# TODO: error on virtual and override
		# TODO: error on virtual and shared
		# TODO: error if 2 or more of 'public', 'protected', 'private', 'internal'
		return names

	def interfaceDecl as Node
		return Node()

	def structDecl as Node
		return Node()

	def enumDecl as Node
		return Node()

	def nameSpaceDecl as Node
		return Node()

	def classMemberDecls(theClass as Class)
		.expect('PASS')
		.expect('EOL')
		.expect('DEDENT')

	def _error(msg as String)
		assert false, 'to do'

	def _warning(msg as String)
		assert false, 'to do'


class Node
	pass


class Module
	inherits Node

	var _declsInOrder as List<of Node>

	def construct(fileName as String, verbosity as int)
		_declsInOrder = List<of Node>()

	get declsInOrder as List<of Node>
		return _declsInOrder

	def addDecl(decl as Node)
		_declsInOrder.add(decl)

class CobraModule
	inherits Module

	def construct(fileName as String, verbosity as int)
		base.construct(fileName, verbosity)

class UseDirective
	inherits Node

	def construct(obj as Object?, nameParts as List<of String>)
		pass

class Box
	inherits Node

	var _name as String

	def construct(name as String)
		_name = name

	get name from var


class Class
	inherits Box

	def construct(name as String, paramList as List<of Node>, isNames as List<of String>, baseName as String?, interfaceNames as List<of String>, docString as String?)
		base.construct(name)
