"""
The Cobra Parser
"""


class ParserException
	inherits SystemException

	var _token as IToken
	var _msg as String

	def construct(token as IToken, msg as String)
		#base.construct(msg)  # CC:
		_token = token
		_msg = msg

	get message as String is override
		return _msg


class Parser
	"""
	Notes:

		* The tokenizer's verbosity is set to 4 less than the parser's. In other words, the
		  tokenizer will not print messages unless the parser's verbosity is 5 or greater.

	"""

	test
		p = Parser()
		p.globalNS = NameSpace(Token.empty, '(global)')
		module = p.parseSource('test1', 'class Test\n\tpass\n')
		assert module
		decls = module.declsInOrder
		decl = decls[decls.count-1]
		if decl inherits Class
			assert decl.name == 'Test'
		else
			assert false, decl

		p = Parser()
		p.globalNS = NameSpace(Token.empty, '(global)')
		p.parseSource('test2', 'class Test\n\tdef main is shared\n\t\treturn\n')

	enum WhenErrorEnum
		exit
		throww

	enum WhenWarningEnum
		emit
		throww

	var _whenError as WhenErrorEnum

	var _lowercaseLetters = 'abcdefghijklmnopqrstuvwxyz'
	var _uppercaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

	var _fileName as String?
	var _willShowTokens = false
	var _verbosity = 0

	var _tokens as List<of IToken>?
	var _nextTokenIndex as int

	var _isNamesStack as Stack<of String>?
	var _boxStack as Stack<of Box>?

	var _globalNS as NameSpace
	var _nameSpaceStack as Stack<of NameSpace>

	var _codeParts as Stack<of ICodePart>
	var _curCodePart as ICodePart?

	var _isContractOnSameLine as bool

	var _leftStack as Stack<of Expr>
	var _opStackStack as Stack<of Stack<of String> >  # CC: should be able to say >> at the end instead of > >
		"""
		Used by expression parts so the last operator can be examined.
		A stack of stacks is needed for CallExpr's args.
		"""

	def construct
		_boxStack = Stack<of Box>()
		_nameSpaceStack = Stack<of NameSpace>()
		_codeParts = Stack<of ICodePart>()

	pro verbosity from var

	pro whenError from var

	pro globalNS as NameSpace
		get
			return _globalNS
		set
			require _globalNS is nil
			_globalNS = value
			_nameSpaceStack.push(_globalNS)

	get curBox as Box
		# yes there is only one box at the moment, but when nested classes and structs are supported there could by many.
		return _boxStack.peek() to Box  # CC: axe typecast

	def parseFileNamed(fileName as String) as Module
		_fileName = fileName
		source = File.readAllText(_fileName to String)  # CC: axe "to String" when "if" gets smart about non-nil
		return .parseSource(fileName, source)

	def parseSource(source as String) as Module
		return .parseSource('(no file name)', source)

	def parseSource(fileName as String, source as String) as Module
		"""
		Parses module source code and returns resulting module.
		"""
		.preParseSource(fileName, source)
		return .parseTokens()

	def preParseSource(fileName as String, source as String)
		"""
		Sets up for parsing, but does not invoke parseTokens().
		Used by parseSource() and various test sections.
		"""
		_fileName = fileName
		tokVerbosity = _verbosity - 4  # in order words, tokenizer does not spew unless our verbosity is 5 or greater
		if tokVerbosity<0
			tokVerbosity = 0

		_isNamesStack = Stack<of String>()  # for `shared` for example
		_leftStack = Stack<of Expr>()
		_opStackStack = Stack<of Stack<of String> >()
		.newOpStack()

		_tokens = nil
		try
			_tokens = CobraTokenizer(tokVerbosity).startSource(_fileName, source).allTokens()
		catch te as TokenizerError
			print '<> Caught TokenizerError'
			print te
			assert false
		_nextTokenIndex = 0


	##
	## Tokens
	##

	def grab as IToken?
		"""
		Returns the next token or nil if there are none left.
		"""
		if _nextTokenIndex >= _tokens.count
			return nil
		token = _tokens[_nextTokenIndex]
		_nextTokenIndex += 1
		if _willShowTokens
			print 'grab    --> [token]'
		return token

	def undo
		"""
		Undoes the last token() call. Often called "push" in parser examples.
		"""
		require _nextTokenIndex>0
		_nextTokenIndex -= 1
		if _willShowTokens
			print 'undo'

	def peek as IToken?
		return .peek(0)

	def peek(offset as int) as IToken?
		"""
		Returns a token without changing the current token, or nil if none left.
		With no offset, returns the current token, otherwise peeks ahead.
		"""
		i = _nextTokenIndex + offset
		if i < _tokens.count
			token = _tokens[i]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'peek([offset]) --> [token]'
		return token

	get last as IToken?
		"""
		Returns the last token returned by get() or nil if get() was never invoked.
		"""
		if _nextTokenIndex > 0
			token = _tokens[_nextTokenIndex-1]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'last    --> [token]'
		return token

	def lastN(n as int) as List<of NumberedToken>  # CC: use List<of Pair<of int, IToken>>
		"""
		Returns a list of NumberedTokens.
		"""
		test
			p = Parser()
			s = 'namespace class Foo def'
			p.preParseSource('(no filename)', s)
			p.grab()
			p.grab()
			p.grab()
			t = p.lastN(2)
			assert t[0].token.which=='CLASS', t
			assert t[1].token.which=='ID', t
			assert t.count==2, t
		code
			tokens = List<of NumberedToken>()
			if _nextTokenIndex > 0
				while true
					n -= 1
					if n == -1
						break
					i = _nextTokenIndex - n - 1
					if i >= 0 and i < _tokens.count
						tokens.add(NumberedToken(i, _tokens[i]))
			return tokens

	def expect(whatTypes as vari String) as IToken
		"""
		Gets a token and complains if its type does not match whatType(s).
		Returns the token.
		"""
		t = .grab()
		if _willShowTokens
			print 'expect([whatTypes]) --> [t]'
		if t is nil
			_error('Expecting [.join(" or ",whatTypes)], but source ended suddenly.')
		# CC: support "not in" on vari type
		#if t.which not in whatTypes
		#	_error('Expecting [whatTypes], but got [t] instead.')
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if not found
			_error('Expecting [.join(" or ",whatTypes)], but got [t] instead.')
		return t to IToken  # CC: to !

	def join(sep as String, stuff as vari String) as String
		# CC: have a join() method for vari, List, IEnumerable, array, etc.; use that and axe this helper method
		sb = StringBuilder()
		sep2 = ''
		for x in stuff
			sb.append(sep2)
			sb.append(x)
			sep2 = sep
		return sb.toString()

	def optional(whatTypes as vari String) as IToken?
		"""
		Gets a token, but only if it matches whatTypes.
		Does not complain or consume a token if there is no match.
		"""
		t = .peek()
		if _willShowTokens
			print 'optional([whatTypes]) --> [t]'
		if t is nil
			return nil
		# CC: support "in" on vari type
		#if t.which in whatTypes
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if found
			return .grab()
		else
			return nil

	def oneOrMore(which as String)
		"""
		Consumes the expected token and any other additional contiguous ones.
		Returns nothing.
		Example:  .oneOrMore('EOL')
		"""
		.expect(which)
		while .peek().which == which
			.grab()


	## Common parsing bits (docString, indent, dedent, ...)

	def docString as String?
		return nil  # TODO

	def indent
		if .optional('COLON')
			_warning('Colons are not used to start indented blocks.')
		.expect('EOL')
		while .optional('EOL')
			pass
		.expect('INDENT')

	def dedent
		while .optional('EOL')
			pass
		.expect('DEDENT')

	def indentIsDeclNames as List<of String>
		"""
		Parses indentation followed by "is" names, or "is" names followed by indentation.
		Example 1:
			def main is shared
				pass
		Example 2:
			def main
				is shared
				pass
		In either case, returns the list of "is" names or nil if there were none.
		"""
		if .peek().which=='IS'
			isNames = .isDeclNames()
			.expect('INDENT')
			return isNames
		else
			if .optionalIndent()
				return .isDeclNames()
			else
				return List<of String>()

	def optionalIndent as IToken?
		if .optional('COLON')
			_warning('Colons are not used to start indented blocks.')
		.oneOrMore('EOL')
		return .optional('INDENT')


	##
	## Parsing
	##

	var _module as Module

	def parseTokens as Module
		"""
		Parses and then returns an instance of Module.
		"""
		require
			.globalNS
		code
			_module = CobraModule(_fileName, _verbosity)  # TODO: does module really need verbosity?
			if not _fileName.endsWith('SystemInterfaces.cobra')
				# TODO: make an "implicit" token
				useToken = Token(_fileName, 1, 1, 1, 'USE', 'use', nil)
				# default use directives
				_module.addDecl(UseDirective(useToken, nil, ['System']))
				_module.addDecl(UseDirective(useToken, nil, ['System', 'Collections', 'Generic']))
				_module.addDecl(UseDirective(useToken, nil, ['System', 'IO']))
				_module.addDecl(UseDirective(useToken, nil, ['System', 'Text']))
				_module.addDecl(UseDirective(useToken, nil, ['Cobra', 'Lang']))
			# TODO: _module.docString = .docString()
			what as NamedNode?
			while true
				what = nil
				addToNS = true
				tok = .peek()
				if tok is nil
					break
				branch tok.which
					on 'USE':       what = .useDirective()
					on 'IMPORT':    what = .importDirective()
					on 'CLASS':     what = .classDecl()
					on 'INTERFACE': what = .interfaceDecl()
					on 'STRUCT':    what = .structDecl()
					on 'ENUM':      what = .enumDecl()
					on 'EOL':       .grab()
					on 'NAMESPACE'
						.nameSpaceDecl()
						addToNS = false
					else
						_error('Expecting use, import, namespace, class, interface or enum, but got [tok]')
						break
				if what
					_module.addDecl(what to Node)  # CC: axe typecast
					if addToNS
						_globalNS.addDecl(what to NamedNode)  # CC: axe "to NamedNode"

			return _module

	def useDirective as NamedNode
		return NamedNode(Token.empty, 'TODO')

	def importDirective as NamedNode
		return NamedNode(Token.empty, 'TODO')

	def classDecl as NamedNode
		token = .expect('CLASS')
		peek = .peek().which
		if peek == 'ID'
			token = .expect('ID')
			name = token.value to String
		else if peek == 'OPEN_GENERIC'
			token = .expect('OPEN_GENERIC')
			name = token.value to String
		else
			_error('Expecting a class name.')
		if name[0] not in _uppercaseLetters
			_error('Class names must start with an uppercase letter in order to avoid collisions with other identifiers such as arguments and local variables.')

		# CC: rename paramsList to params (can't do it now because it's a C# reserved word and Cobra needs to generate IL or 'escape' these)
#		paramsList = []
#		if token.which=='OPEN_GENERIC'
#			expectComma = false
#			while 1
#				if .peek().which=='GT'
#					.grab()
#					break
#				if expectComma
#					.expect('COMMA')
#				ident = .expect('ID').value
#				paramsList.append(GenericParam(ident))
#				expectComma = true

		.indent()

		isNames = .isDeclNames()

#		while .optional('WHERE')
#			if token.which!='OPEN_GENERIC'
#				_error('Unexpected where clause for non-generic class.')
#			paramName = .expect('ID').value
#			found = false
#			for param in params
#				if param.name==paramName
#					found = true
#					break
#			if not found
#				_error('Unknown generic parameter "%s".' % name)
#			if param.constraints
#				_error('Already specified constraints for "%s".' % name)
#			.expect('MUST')
#			.expect('BE')
#			expectComma = false
#			while 1
#				if expectComma
#					.expect('COMMA')
#				param.constraints.append(.genericConstraint())
#				if .optional('EOL')
#					break
#				expectComma = true
		paramList = List<of Node>() # TODO: axe

		baseName as String?
		if .optional('INHERITS')
			baseName = .expect('ID').text
			.expect('EOL')
		else
			baseName = nil

#		interfaceNames = []
#		if .optional('IMPLEMENTS')
#			expectComma = false
#			while 1
#				if .peek().which=='EOL'
#					.grab()
#					break
#				if expectComma
#					.expect('COMMA')
#				interfaceName = .type()  # using .type since interface could be a generic like IEnumerable(of T)
#				interfaceNames.append(interfaceName)
#				expectComma = true
		interfaceNames = List<of String>()  # TODO: axe

		docString = .docString()

		theClass = Class(token, name, paramList, isNames, baseName, interfaceNames, docString)

		# TODO when supporting nested classes, look at the clintDeclStack and set a back pointer here
		_boxStack.push(theClass)
#		.isNamesStack = Stack(str)
		.classMemberDecls(theClass)
		_boxStack.pop()

		return theClass



	var _validIsNames as List<of String>?

	def isDeclNames as List<of String>
		"""
		Example source:
			# The | below is not literal--it's where this method starts parsing.
			def Compute()
				|is virtual, protected
		Example return values:
			[]
			['shared']
			['private', 'shared']
		Errors:
			TODO
		Used by: classDecl, interfaceDecl, enumDecl, indentIsDeclNames
		"""
		if _validIsNames is nil
			_validIsNames = ['fake', 'shared', 'virtual', 'nonvirtual', 'override', 'public', 'protected', 'private', 'internal']
		names = List<of String>()
		if _isNamesStack
			names.add(_isNamesStack.peek())
#		names = if(_isNamesStack, [_isNamesStack.peek()], List<of String>())
		isWord = .optional('IS')
		if isWord is nil
			return names
		while true
			what = .grab().text
			if what in _validIsNames
				names.add(what)
			else
				_error('Not expecting "[what]".')
			comma = .optional('COMMA')
			if comma is nil
				break
		.oneOrMore('EOL')
		# TODO: error on virtual and override
		# TODO: error on virtual and shared
		# TODO: error if 2 or more of 'public', 'protected', 'private', 'internal'
		return names

	def interfaceDecl as NamedNode
		return NamedNode(Token.empty, 'TODO')

	def structDecl as NamedNode
		return NamedNode(Token.empty, 'TODO')

	def enumDecl as NamedNode
		return NamedNode(Token.empty, 'TODO')

	def nameSpaceDecl as NameSpace
		require _nameSpaceStack
		.expect('NAMESPACE')
		curNameSpace = _nameSpaceStack.peek() to NameSpace  # CC: remove "as Node"
		tok = .expect('ID')
		name = tok.value to String  # CC: .value should probably be dynamic
		curNameSpace = curNameSpace.getOrMakeNameSpaceNamed(tok, name)
		_nameSpaceStack.push(curNameSpace)
		.indent()
		while true
			peek = .peek()
			if peek is nil
				_error('expecting a namespace member, but source code ended')
			tok = peek to IToken  # CC: to !
			if tok.which=='DEDENT'
				break
			branch tok.which
				on 'CLASS':  curNameSpace.addDecl(.classDecl())
				on 'INTERFACE': curNameSpace.addDecl(.interfaceDecl())
				on 'STRUCT': curNameSpace.addDecl(.structDecl())
				on 'USE': curNameSpace.addDecl(.useDirective())
				on 'NAMESPACE': .nameSpaceDecl()
				else: _error('expecting a namespace member but got [tok]')
		.dedent()
		_nameSpaceStack.pop()
		return curNameSpace

	def classMemberDecls(theClass as Class)
		decl as Node?
		breakLoop = false  # cannot use 'break' to stop a 'while' loop in a branch statement. CC?
		while not breakLoop
			decl = nil
			branch .peek().which
				on 'PASS'
					.classPass()
					breakLoop = true
				on 'DEDENT': breakLoop = true
				on 'DEF': .declareMethod()
				on 'EOL': .oneOrMore('EOL')
				else
					_error('Got [.peek()] when expecting var, def, pro, get, set, enum or shared')
			if decl!
				theClass.addDecl(decl to Node)  # CC: axe typecast when if gets smart about not nil
		.dedent()

	def classPass
		if .curBox.declsInOrder
			_warning('Encountered "pass" in a class that already has declared members.')  # TODO: change to an error
		.grab()
		.oneOrMore('EOL')

	def declareMethod as Method
		token = .expect('DEF')
		opener = .grab()
		if opener.which not in ['ID', 'OPEN_CALL']
			_error('Encountered [opener.which] when expecting an identifier.')
		name = opener.value to String
		curClass = .curBox
		if name==curClass.name or Utils.capped(name)==curClass.name
			_error('Method names cannot be the same as their enclosing [curClass.specificName]. Use `def construct` for creating a constructor or choose another name.')  # TODO list the enclosing types location
# TODO
#		overload = nil
#		other = curClass.symbolForName(name, true)
#		if other
#			if name=='destruct'
#				.error('Cannot define more than one destruct method.')  # TODO give reference to the other one
#			if inherits(other, MemberOverload)
#				overload = other
#			else if inherits(other, DefOneCodeBlockMember)
#				overload = MemberOverload(token, other)
#				curClass.registerOverload(overload)
#			else
#				.error('There is already another class member with the name "%s".' % name)  # TODO list its location and possibly what it is
#		else
#			other = curClass.symbolForNameCI(name, true)
#			if other
#				.error('There is already another class member with the name "%s". You must differentiate member names by more than just case.' % other.name)
#			if name[0] in .uppercaseLetters
#				.error('%s names must start with lowercase letters. (%s)' % ('Method', name))

#		if opener.which=='OPEN_CALL'
#			params = .paramDecls(skipParen=true)
#		else
#			params = []
		paramsList = List<of Param>()

#		if .optional('AS')
#			returnType = .type()
#		else
#			returnType = tvoid
#		assert returnType

		if curClass inherits Class
			isNames = .indentIsDeclNames()
#			implements = .optional('IMPLEMENTS') and .type() or nil
#			if implements
#				.oneOrMore('EOL')
#			docString = .docString()
			docString = ''

#			assert returnType
#			if name=='construct'
#				if returnType is not tvoid
#					.error('Cannot declare a return type for construct.')
#				defMethod = DefConstruct(token, .curBox, params, isNames, docString)
#			else if name=='destruct'
#				if returnType is not tvoid
#					.error('Cannot declare a return type for destruct.')
#				if params
#					.error('Cannot declare parameters for destruct.')
#				if 'shared' in isNames
#					.error('Cannot declare a shared destructor.')
#				defMethod = DefDestruct(token, .curBox, isNames, docString)
#			else
#				if name=='constructor'
#					.warning('Did you mean to say `construct`?')
#				else if name=='destructor'
#					.warning('Did you mean to say `destruct`?')
			returnType = CobraType(Token.empty)
			implementsList = List<of Node>()
			if true
				method = Method(token, .curBox, name, paramsList, returnType, isNames, implementsList, docString)
			.statementsFor(method)
		else if curClass inherits Interface
			if .optionalIndent()
				isNames = .isDeclNames()
#				docString = .docString()
				docString = ''
				.dedent()
			else
				isNames = List<of String>()
				docString = ''
			implementsList = List<of Node>()
			if name=='construct'
				_error('Cannot declare "construct" in an interface.')
			else if name=='destruct'
				_error('Cannot declare "destruct" in an interface.')
			else
				method = Method(token, .curBox, name, paramsList, returnType, isNames, implementsList, docString)
		else
			throw Exception('Unhandled containing type [curClass]')
		assert method
#		if overload
#			overload.addMember(defMethod)
		return method

	def statementsFor(codePart as ICodePart)
		.statementsFor(codePart, nil)

	def statementsFor(codePart as ICodePart, codePartContainingTest as ICodePart?)
		"""
		Example source
			<any statement 1>
			<any statement 2>
			<any statement N>
		Example source
			test
				<any statement 1>
				<any statement 2>
				<any statement N>
			code
				<any statement 1>
				<any statement 2>
				<any statement N>
		Returns
			Nothing.
		Errors
			Already encountered "code" block.
			Already encountered "test" block.
		"""
		_pushCodePart(codePart)
		if codePartContainingTest is nil
			codePartContainingTest = codePart
		try
			if .peek().which in ['CODE', 'TEST', 'REQUIRE', 'ENSURE']
				# sectional
				# not flexible. sequence is signature, contract, test, implementation
				_isContractOnSameLine = false
#				if .peek().which=='REQUIRE'
#					.require(codePart)
#				if .peek().which=='ENSURE'
#					.ensure(codePart)
#				if .peek().which=='TEST'
#					.testSection(codePartContainingTest)
#				if .peek().which=='CODE'
#					.grab()
#					codePart.setBlock(.block())
#				else
				if true
					if _isContractOnSameLine
						_statementsFor(codePart)
					else
						_error('Expecting `code` section.')
				if not _isContractOnSameLine
					.dedent()
			else
				# non-sectional
				_statementsFor(codePart)
		finally
			_curCodePart = nil

	def _statementsFor(codePart as ICodePart)
		"""
		Utility method for .statementsFor.
		"""
		while .peek().which<>'DEDENT'
			stmt = .stmt()
			if stmt is not nil
				codePart.addStmt(stmt to Stmt)  # CC: axe "to Stmt"
		.dedent()

	def stmt as Stmt?
		token = .peek()
		which = token.which
		s as Stmt? # the statement (node)
		expectEOL = true
		branch token.which
			on 'ASSERT'
				s = .assertStmt()
			on 'BRANCH'
				s = .branchStmt()
				expectEOL = false
			on 'BREAK'
				s = .breakStmt()
			on 'CONTINUE'
				s = .continueStmt()
			on 'EXPECT'
				s = .expectStmt()
				expectEOL = false
			on 'FOR'
				s = .forStmt()
				expectEOL = false
#			on 'DEF'
#				s = .declareMethod()
			on 'IF'
				s = .ifStmt()
				expectEOL = false
			on 'GET'
				_error('Cannot use "get" for a statement. If you mistakenly started a property above with "def", "get" or "set", then use "pro" instead.')
			on 'PASS'
				s = .passStmt()
			on 'POST'
				s = .postWhileStmt()
				expectEOL = false
			on 'PRINT'
				s = .printStmt()
				expectEOL = false
			on 'RETURN'
				s = .returnStmt()
			on 'THROW'
				s = .throwStmt()
			on 'TRY'
				s = .tryStmt()
				expectEOL = false
			on 'USING'
				s = .usingStmt()
				expectEOL = false
			on 'WHILE'
				s = .whileStmt()
				expectEOL = false
			on 'EOL'
				.grab()  # ignore stray EOL (can especially come up at the end of a file)
				expectEOL = false
			else
				s = .expression()
				s.afterParserRecognizesStatement()
		if expectEOL
			if .verbosity>=5
				print '<> last statement start token=[token]'
				print '<> s = [s]'
			.expect('EOL')
		_finishSpaceAgnostic()
		return s


	##
	## Individual Statements
	##

	def assertStmt as Stmt
		token = .expect('ASSERT')
		expr = .expression()
		# CC: could the following 5 lines be: info = if(.optional('COMMA'), .expression(), nil)
		info as Expr?
		if .optional('COMMA')
			info = .expression()
		else
			info = nil
		return AssertStmt(token, expr, info)

	def branchStmt as Stmt
		return Stmt(.grab())

	def breakStmt as Stmt
		return Stmt(.grab())

	def continueStmt as Stmt
		return Stmt(.grab())

	def expectStmt as Stmt
		return Stmt(.grab())

	def forStmt as Stmt
		return Stmt(.grab())

	def ifStmt as Stmt
		return Stmt(.grab())

	def passStmt as Stmt
		return Stmt(.grab())

	def postWhileStmt as Stmt
		return Stmt(.grab())

	def printStmt as Stmt
		return Stmt(.grab())

	def returnStmt as Stmt
		token = .expect('RETURN')
		expr as Expr?  # axe this decl when Cobra looks at the second assignment in after "x = nil"
		if .peek().which=='EOL'
			expr = nil
		else
			expr = .expression()
		return ReturnStmt(token, expr)

	def throwStmt as Stmt
		return Stmt(.grab())

	def tryStmt as Stmt
		return Stmt(.grab())

	def usingStmt as Stmt
		return Stmt(.grab())

	def whileStmt as Stmt
		return Stmt(.grab())


	##
	## Expressions
	##

	shared
		var _binaryOpPrec = {
			# CANNOT USE 0 AS A VALUE IN THIS DICTIONARY
			'DOT':				80,
			'LBRACKET':			80,
			'LPAREN':			80,

			'STARSTAR':			70,  # right associative

			'QUESTION':			68,
			'BANG':				68,

			'TO':				65,
			'TOQ':				65,

			'STAR':				60,
			'SLASH':			60,
			'SLASHSLASH':		60,
			'PERCENT':			60,

			'PLUS':				50,
			'MINUS':			50,

			'EQ':				40,
			'NE':				40,
			'LT':				40,
			'GT':				40,
			'LE':				40,
			'GE':				40,
			'IS':				40,
			'ISNOT':			40,
			'INHERITS':			40,
			'IMPLEMENTS':		40,

			'IN':				35,
			'NOTIN':			35,

			'AND':				30,
			'OR':				30,
			'IMPLIES':			20,

			'ASSIGN':			20,
			'PLUS_EQUALS':		20,
			'MINUS_EQUALS':		20,
			'STAR_EQUALS':		20,
			'SLASH_EQUALS':		20,
			'PERCENT_EQUALS':	20,
			'QUESTION_EQUALS':	20,
			'BANG_EQUALS':		20,
		}

		var _unaryOpPrec = {
			'MINUS': _binaryOpPrec['MINUS']+1,
			'NOT': _binaryOpPrec['AND']+1,
			'OLD': _binaryOpPrec['STARSTAR']+1,
		}

	def expression as Expr
		test
			# CC: neither of these work and both should

			#assert 0 not in _binaryOpPrec.values

			#for v in _binaryOpPrec.values
			#	assert v<>0

			pass

		code
			return .expression(0, nil)


	def expression(precedence as int) as Expr
		return .expression(precedence, nil)


	def expression(precedence as int, left as Expr?) as Expr
		if left is nil
			left = .expression2()
		while true
			peek = .peek().which
			# handle multi-word operators
			op as String? = nil
			if peek=='IS' and .peek(1).which=='NOT'  # CC: change to .peek(+1)
				# 'is not' is a 2 keyword operator
				op = 'ISNOT'
			else if peek=='NOT' and .peek(1).which=='IN'  # CC: change to .peek(+1)
				op = 'NOTIN'
			# handle precedence (and detect non-binary operators)
			binaryOpPrec = Utils.getSI(_binaryOpPrec, op ? peek, -1)
			if binaryOpPrec==-1 or binaryOpPrec<precedence
				break
			# continue...
			if peek=='LBRACKET'
				# requires special handling - IndexExpr
				token = .grab()
				exprs = .commaSepExprs('RBRACKET')
				return .expression(precedence, IndexExpr(token, left, exprs))
			else if peek=='LPAREN'
				# requires special handling - PostCallExpr
				token = .grab()
				exprs = .commaSepExprs('RPAREN')
				assert false, 'TODO'
#				return .expression(precedence, PostCallExpr(token, left, exprs))
			else
				# most operators are one-word affairs
				if op is nil
					opToken = .grab()
					op = opToken.which
				else
					# op was set earlier for a two word operator. ISNOT NOTIN
					opToken = .grab()
					.grab()
				# TODO: axe the following section
#				if op=='QUESTION'
					# ? can be a binary operator, or a unary postfix operator
#					if .peek().which in ['COMMA', 'EOL', 'RPAREN']
#						return IsNilExpr(opToken, left)
#					if _binaryOpPrec.containsKey(.peek().which) and .peek().which!<>'DOT'
#						# keep chugging
#						left = IsNilExpr(opToken, left)
#						opToken = .grab()
#						op = opToken.which
				if op=='BANG'
					if .peek().which in ['COMMA', 'EOL', 'RPAREN']
						return IsNotNilExpr(opToken, left)
					if _binaryOpPrec.containsKey(.peek().which) and .peek().which<>'DOT'
						# keep chugging
						left = IsNotNilExpr(opToken, left)
						opToken = .grab()
						op = opToken.which
			assert _binaryOpPrec.containsKey(op)
			_leftStack.push(left)
			.opStack.push(op)
			try
				prec = if(OperatorSpecs.rightAssoc().containsKey(op), binaryOpPrec, binaryOpPrec+1)
				right = .expression(prec)
#				if right inherits IdentifierExpr
#					if right.definition is UnknownId
#						_errorUnknownId(right.text)  # TODO this seems wrong since the name might not be available until later
				if .peek().which=='QUESTION'
					# ? unary postfix is higher precedence than any binary operator
					right = IsNilExpr(.grab(), right)
				else if .peek().which=='BANG'
					# ! unary postfix is higher precedence than any binary operator
					right = IsNotNilExpr(.grab(), right)
				left = BinaryOpExpr(opToken, op, left, right)
			finally
				.opStack.pop()
				_leftStack.pop()
#		if left inherits IdentifierExpr and left.definition is UnknownId
#			.errorUnknownId(left.text)  # TODO this seems wrong since the name might not be available until later
		assert left
		return left to Expr  # CC: to !

	def expression2 as Expr
		peek = .peek().which
		if _unaryOpPrec.containsKey(peek)
			token = .grab()
			prec = _unaryOpPrec[peek]
			if token.which=='OLD'
				return OldExpr(token, .expression(prec))
			else
				return UnaryOpExpr(token, peek, .expression(prec))
		# TODO: make a branch statement
		else if peek=='LPAREN'
			.grab()
			node = .expression(0, nil)
			.expect('RPAREN')
			return node
		else if peek=='DOT'
			# leading dot
			token = .grab()
			peek = .peek().which
			if peek=='ID'
				token = .expect('ID')
				assert false, 'TODO'
#				expr = MemberExpr(token, token.text, nil, nil)
			else if peek=='OPEN_CALL'
				assert false, 'TODO'
#				expr = .callExpr()
			else
				_error('Syntax error after "."')
			expr = Expr(Token.empty)  # TODO: axe this when the above are fixed
			return BinaryOpExpr(token, 'DOT', ThisLit(token, .curBox), expr)
		else if peek=='NIL'
			return NilLiteral(.grab())
		else if peek=='TRUE'
			return BoolLiteral(.grab())
		else if peek=='FALSE'
			return BoolLiteral(.grab())
		else if peek=='THIS'
			return ThisLit(.grab(), .curBox)
		else if peek=='BASE'
			return BaseLit(.grab(), .curBox)
# TODO
#		else if peek=='VAR'
#			return VarLit(.grab(), .curCodeMember)
#		else if peek=='CHAR_LIT_SINGLE'
#			return CharLit(.grab())
#		else if peek=='CHAR_LIT_DOUBLE'
#			return CharLit(.grab())
# TODO
#		else if peek=='STRING_START_SINGLE'
#			return .stringWithSubstitutionLit('STRING_START_SINGLE', 'STRING_PART_SINGLE', 'STRING_STOP_SINGLE')
#		else if peek=='STRING_START_DOUBLE'
#			return .stringWithSubstitutionLit('STRING_START_DOUBLE', 'STRING_PART_DOUBLE', 'STRING_STOP_DOUBLE')
#		else if peek=='STRING_SINGLE'
#			return StringLit(.grab())
#		else if peek=='STRING_DOUBLE'
#			return StringLit(.grab())
		else if peek=='INTEGER_LIT'
			return IntegerLit(.grab())
#		else if peek=='DECIMAL_LIT'
#			return DecimalLit(.grab())
#		else if peek=='FLOAT_LIT'
#			return FloatLit(.grab())
# TODO
#		else if peek=='LBRACKET'
#			return .literalList()
#		else if peek=='LCURLY'
#			return .literalDict()
#		else if peek=='OPEN_IF'
#			return .ifExpr()
#		else if peek=='OPEN_CALL'
#			return .callExpr()
#		else if peek=='OPEN_GENERIC'
#			return TypeExpr(.type())
		else if peek=='ID'
			return .identifierExpr()
# TODO
#		else
#			try
#				return TypeExpr(.nonqualifiedType('throw'))
#			catch ParserError, pe
#				if pe.errorMessage==.expectingAType
#					.error('Expecting an expression.')
#				else
#					throw
		else
			return Expr(Token.empty)  # TODO: axe this

	def commaSepExprs(terminator as String) as List<of Expr>
		# TODO
		return List<of Expr>()

	def identifierExpr as Expr
		nameToken = .expect('ID')
		name = nameToken.text  # TODO? use to be .value instead of .text
		if .opStack and .opStack.peek()=='DOT'
			assert false, 'TODO'
			#return MemberExpr(token, name, UnknownId, tunknown)
#			return MemberExpr(nameToken, name, nil, nil)
		if .peek().which=='AS'
# TODO
#			if name[0] not in .lowercaseLetters
#				.error(TidBits.localVarLowercaseError)
			asToken = .grab()
			type = .type()
			assert type
			return AsExpr(asToken, nameToken, type)
		else
			return IdentifierExpr(nameToken, name, nil)


	##
	## Types
	##

	def type as Node
		token = .grab()
		# TODO: use typeForName()
		if token.text=='int'
			return IntType(Token.empty)
		else if token.text=='bool'
			return BoolType(Token.empty)
		else
			_error('Unrecognized type: [token]')
			assert false
			return CobraType(Token.empty)


	##
	## Op stack
	##

	def newOpStack
		require _opStackStack!
		_opStackStack.push(Stack<of String>())

	def delOpStack
		require _opStackStack
		_opStackStack.pop()

	get opStack as Stack<of String>
		"""
		Returns the current opStack.
		"""
		return _opStackStack.peek() to Stack<of String>  # CC: axe to String


	##
	## Protected self utility
	##

	def _error(msg as String)
		token = .last
		if token
			msg = '[token.fileName]([token.lineNum],[token.colNum]): error: [msg]'
		else
			msg = '[token.fileName](1, 1): error: [msg]'
		if _whenError==WhenErrorEnum.exit
			print msg
			if _verbosity>=1
				print 'Last tokens:'
				print '    ...'
				for pair in .lastN(9)
					s = '    [pair.i]. [pair.token]'
					s = s.padRight(25) + 'line [pair.token.lineNum]'
					print s
			if _verbosity<2
				Environment.exit(1)
				# otherwise raise an exception in order to be more verbose
		throw ParserException(.last, msg)

	def _warning(msg as String)
		assert false, 'to do'

	def _pushCodePart(codePart as ICodePart)
		_codeParts.push(codePart)
		_curCodePart = codePart

	def _popCodePart
		require _codeParts
		_codeParts.pop()
		# CC: _curCodePart = if(_codeParts, _codeParts.peek(), nil)
		if _codeParts
			_curCodePart = _codeParts.peek() to ICodePart  # CC: axe "to ICodePart"
		else
			_curCodePart = nil

	def _finishSpaceAgnostic
		pass


class UseDirective
	inherits Node

	def construct(token as IToken, obj as Object?, nameParts as List<of String>)
		base.construct(token)


class Box
	inherits NamedNode
	"""
	The abstract base class for:
		* Class
		* Interface
		* Struct
	These are collectively known as "boxes".
	"""

	var _declsInOrder as List<of Node>  # TODO: can the inner list type be narrowed more? say to IClassMemberDecl or ClassMemberDecl

	def construct(token as IToken, name as String)
		base.construct(token, name)
		_declsInOrder = List<of Node>()

	get declsInOrder from var

	def addDecl(decl as Node)
		_declsInOrder.add(decl)

	get specificName as String
		"""
		Return the specific name of this type of box: class, interface, struct.
		"""
		return ''


class Class
	inherits Box

	def construct(token as IToken, name as String, paramList as List<of Node>, isNames as List<of String>, baseName as String?, interfaceNames as List<of String>, docString as String?)
		base.construct(token, name)

	get specificName as String is override
		return 'class'


class Interface
	inherits Box

	def construct(token as IToken, name as String, paramList as List<of Node>, isNames as List<of String>, baseName as String?, interfaceNames as List<of String>, docString as String?)
		base.construct(token, name)

	get specificName as String is override
		return 'interface'


class ClassMember
	inherits NamedNode

	var _box as Box

	def construct(token as IToken, box as Box, name as String)
		base.construct(token, name)
		_box = box



interface ICodePart
	"""
	The common interface to:
		- methods
		- inits (special methods)
		- property getter
		- property setter
		- nested method
		- anonymous method
	"""

	def addStmt(stmt as Stmt)



class Method
	inherits ClassMember
	implements ICodePart

	var _params as List<of Param>
	var _returnTypeNode as Node
	var _isNames as List<of String>
	var _implementsList as List<of Node>
	var _docString as String
	var _stmts as List<of Stmt>

	def construct(token as IToken, box as Box, name as String, paramsList as List<of Param>, returnTypeNode as Node, isNames as List<of String>, implementsList as List<of Node>, docString as String)
		base.construct(token, box, name)
		_params = paramsList
		_returnTypeNode = returnTypeNode
		_isNames = isNames
		_implementsList = implementsList
		_docString = docString
		_stmts = List<of Stmt>()

	def addStmt(stmt as Stmt)
		_stmts.add(stmt)


class Param
	inherits NamedNode

	def construct(token as IToken, name as String)
		base.construct(token, name)


class LocalVar
	inherits NamedNode

	def construct(token as IToken, type as IType)
		base.construct(token, token.text)



class NumberedToken
	"""
	In support of Parser.lastN.
	# TODO: Replace this with Pair<T1, T2>
	"""

	var _i as int
	var _token as IToken

	def construct(i as int, token as IToken)
		_i = i
		_token = token

	get i from var
	get token from var

	def toString as String is override
		return '([_i], [_token])'
