"""
The Cobra Parser
"""


class Parser
	"""
	Notes:

		* The tokenizer's verbosity is set to 4 less than the parser's. In other words, the
		  tokenizer will not print messages unless the parser's verbosity is 5 or greater.

	"""

	test
		p = Parser()

	enum WhenError
		exit

	enum WhenWarning
		emit
		throww

	var _lowercaseLetters = 'abcdefghijklmnopqrstuvwxyz'
	var _uppercaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

	var _fileName as String?
	var _willShowTokens = false
	var _verbosity = 0

	var _tokens as List<of IToken>?
	var _curTokenIndex as int


	def construct
		pass

	def parseFileNamed(fileName as String) as Node
		_fileName = fileName
		source = File.readAllText(_fileName to String)  # CC: axe "to String" when "if" gets smart about non-nil
		return .parseSource(source)

	def parseSource(source as String) as Node
		"""
		Parses module source code and returns resulting module.
		"""
		tokVerbosity = _verbosity - 4  # in order words, tokenizer does not spew unless our verbosity is 5 or greater
		if tokVerbosity<0
			tokVerbosity = 0

		_tokens = nil
		try
			_tokens = CobraTokenizer(tokVerbosity).startSource(source).allTokens()
		catch te as TokenizerError
			print '<> Caught TokenizerError'
			print te
			assert false
		_curTokenIndex = 0

		return .parseTokens()


	## Tokens

	get grab as IToken?
		"""
		Returns the next token or nil if there are none left.
		"""
		if _curTokenIndex >= _tokens.count
			return nil
		token = _tokens[_curTokenIndex]
		_curTokenIndex += 1
		if _willShowTokens
			print 'grab    --> [token]'
		return token

	def undo
		"""
		Undoes the last token() call. Often called "push" in parser examples.
		"""
		require _curTokenIndex>0
		_curTokenIndex -= 1
		if _willShowTokens
			print 'undo'

	def peek as IToken?
		return .peek(0)

	def peek(offset as int) as IToken?
		"""
		Returns a token without changing the current token, or nil if none left.
		With no offset, returns the current token, otherwise peeks ahead.
		"""
		i = _curTokenIndex + offset
		if i < _tokens.count
			token = _tokens[i]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'peek([offset]) --> [token]'
		return token

	get last as IToken?
		"""
		Returns the last token returned by get() or nil if get() was never invoked.
		"""
		if _curTokenIndex > 0
			token = _tokens[_curTokenIndex]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'last    --> [token]'
		return token

	def expect(whatTypes as vari String) as IToken?
		"""
		Gets a token and complains if its type does not match whatType(s).
		Returns the token.
		"""
		t = .grab
		if _willShowTokens
			print 'expect([whatTypes]) --> [t]'
		# TODO: join whatTypes by ' or ' in 2 following errors to make them more readable
		if t is nil
			_error('Expecting [whatTypes], but source ended suddenly.')
		# CC: support "not in" on vari type
		#if t.which not in whatTypes
		#	_error('Expecting [whatTypes], but got [t] instead.')
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if not found
			_error('Expecting [whatTypes], but got [t] instead.')
		return t

	def optional(whatTypes as vari String) as IToken?
		"""
		Gets a token, but only if it matches whatTypes.
		Does not complain or consume a token if there is no match.
		"""
		t = .peek()
		if _willShowTokens
			print 'optional([whatTypes]) --> [t]'
		if t is nil
			return nil
		# CC: support "in" on vari type
		#if t.which in whatTypes
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if found
			return .grab
		else
			return nil


	## Parsing

	def parseTokens as Node
		return Node()

	def _error(msg as String)
		throw Exception()

class Node
	pass
