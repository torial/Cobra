"""
The Cobra Parser
"""


class ParserException
	inherits SystemException

	var _token as IToken

	def construct(token as IToken, msg as String)
		base.construct(msg)
		_token = token


class Parser
	"""
	Notes:

		* The tokenizer's verbosity is set to 4 less than the parser's. In other words, the
		  tokenizer will not print messages unless the parser's verbosity is 5 or greater.

	"""

	test
		p = Parser()
		p.globalNS = NameSpace(Token.empty, '(global)')
		p.typeProvider = BasicTypeProvider()
		module = p.parseSource('test1', 'class Test\n\tpass\n')
		assert module
		decls = module.declsInOrder
		decl = decls[decls.count-1]
		if decl inherits Class
			assert decl.name == 'Test'
		else
			assert false, decl

		p = Parser()
		p.globalNS = NameSpace(Token.empty, '(global)')
		p.typeProvider = BasicTypeProvider()
		p.parseSource('test2', 'class Test\n\tdef main is shared\n\t\treturn\n')

	enum WhenErrorEnum
		exit
		throww

	enum WhenWarningEnum
		emit
		throww

	var _whenError as WhenErrorEnum

	var _lowercaseLetters = 'abcdefghijklmnopqrstuvwxyz'
	var _uppercaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

	var _fileName as String?
	var _willShowTokens = false
	var _verbosity = 0

	var _tokens as List<of IToken>?
	var _nextTokenIndex as int

	var _isNamesStack as Stack<of String>?
	var _boxStack as Stack<of Box>?

	var _globalNS as NameSpace
	var _nameSpaceStack as Stack<of NameSpace>

	var _codeParts as Stack<of ICodePart>
	var _curCodePart as ICodePart?

	var _isContractOnSameLine as bool

	var _leftStack as Stack<of Expr>
	var _opStackStack as Stack<of Stack<of String> >  # CC: should be able to say >> at the end instead of > >
		"""
		Used by expression parts so the last operator can be examined.
		A stack of stacks is needed for CallExpr's args.
		"""

	var _typeProvider as ITypeProvider

	def construct
		_boxStack = Stack<of Box>()
		_nameSpaceStack = Stack<of NameSpace>()
		_codeParts = Stack<of ICodePart>()

	pro verbosity from var

	pro whenError from var

	pro typeProvider from var

	pro globalNS as NameSpace
		get
			return _globalNS
		set
			require _globalNS is nil
			_globalNS = value
			_nameSpaceStack.push(_globalNS)

	get curBox as Box
		# yes there is only one box at the moment, but when nested classes and structs are supported there could by many.
		return _boxStack.peek() to Box  # CC: axe typecast

	def parseFileNamed(fileName as String) as Module
		require .typeProvider
		_fileName = fileName
		source = File.readAllText(_fileName to String)  # CC: axe "to String" when "if" gets smart about non-nil
		return .parseSource(fileName, source)

	def parseSource(source as String) as Module
		require .typeProvider
		return .parseSource('(no file name)', source)

	def parseSource(fileName as String, source as String) as Module
		"""
		Parses module source code and returns resulting module.
		"""
		.preParseSource(fileName, source)
		return .parseTokens()

	def preParseSource(fileName as String, source as String)
		"""
		Sets up for parsing, but does not invoke parseTokens().
		Used by parseSource() and various test sections.
		"""
		_fileName = fileName
		tokVerbosity = _verbosity - 4  # in order words, tokenizer does not spew unless our verbosity is 5 or greater
		if tokVerbosity<0
			tokVerbosity = 0

		_isNamesStack = Stack<of String>()  # for `shared` for example
		_leftStack = Stack<of Expr>()
		_opStackStack = Stack<of Stack<of String> >()
		.newOpStack()

		_tokens = nil
		try
			_tokens = CobraTokenizer(tokVerbosity).startSource(_fileName, source).allTokens()
		catch te as TokenizerError
			print '<> Caught TokenizerError'
			print te
			assert false
		_nextTokenIndex = 0


	##
	## Tokens
	##

	def grab as IToken?
		"""
		Returns the next token or nil if there are none left.
		"""
		if _nextTokenIndex >= _tokens.count
			return nil
		token = _tokens[_nextTokenIndex]
		_nextTokenIndex += 1
		if _willShowTokens
			print 'grab    --> [token]'
		return token

	def undo
		"""
		Undoes the last token() call. Often called "push" in parser examples.
		"""
		require _nextTokenIndex>0
		_nextTokenIndex -= 1
		if _willShowTokens
			print 'undo'

	def peek as IToken?
		return .peek(0)

	def peek(offset as int) as IToken?
		"""
		Returns a token without changing the current token, or nil if none left.
		With no offset, returns the current token, otherwise peeks ahead.
		"""
		i = _nextTokenIndex + offset
		if i < _tokens.count
			token = _tokens[i]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'peek([offset]) --> [token]'
		return token

	get last as IToken?
		"""
		Returns the last token returned by get() or nil if get() was never invoked.
		"""
		if _nextTokenIndex > 0
			token = _tokens[_nextTokenIndex-1]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'last    --> [token]'
		return token

	def lastN(n as int) as List<of NumberedToken>  # CC: use List<of Pair<of int, IToken>>
		"""
		Returns a list of NumberedTokens.
		"""
		test
			p = Parser()
			s = 'namespace class Foo def'
			p.preParseSource('(no filename)', s)
			p.grab()
			p.grab()
			p.grab()
			t = p.lastN(2)
			assert t[0].token.which=='CLASS', t
			assert t[1].token.which=='ID', t
			assert t.count==2, t
		code
			tokens = List<of NumberedToken>()
			if _nextTokenIndex > 0
				while true
					n -= 1
					if n == -1
						break
					i = _nextTokenIndex - n - 1
					if i >= 0 and i < _tokens.count
						tokens.add(NumberedToken(i, _tokens[i]))
			return tokens

	def expect(whatTypes as vari String) as IToken
		"""
		Gets a token and complains if its type does not match whatType(s).
		Returns the token.
		"""
		t = .grab()
		if _willShowTokens
			print 'expect([whatTypes]) --> [t]'
		if t is nil
			_error('Expecting [.join(" or ",whatTypes)], but source ended suddenly.')
		# CC: support "not in" on vari type
		#if t.which not in whatTypes
		#	_error('Expecting [whatTypes], but got [t] instead.')
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if not found
			_error('Expecting [.join(" or ",whatTypes)], but got [t] instead.')
		return t to IToken  # CC: to !

	def join(sep as String, stuff as vari String) as String
		# CC: have a join() method for vari, List, IEnumerable, array, etc.; use that and axe this helper method
		sb = StringBuilder()
		sep2 = ''
		for x in stuff
			sb.append(sep2)
			sb.append(x)
			sep2 = sep
		return sb.toString()

	def optional(whatTypes as vari String) as IToken?
		"""
		Gets a token, but only if it matches whatTypes.
		Does not complain or consume a token if there is no match.
		"""
		t = .peek()
		if _willShowTokens
			print 'optional([whatTypes]) --> [t]'
		if t is nil
			return nil
		# CC: support "in" on vari type
		#if t.which in whatTypes
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if found
			return .grab()
		else
			return nil

	def oneOrMore(which as String)
		"""
		Consumes the expected token and any other additional contiguous ones.
		Returns nothing.
		Example:  .oneOrMore('EOL')
		"""
		.expect(which)
		while .peek().which == which
			.grab()


	## Common parsing bits (docString, indent, dedent, ...)

	def docString as String?
		return ''  # TODO

	def indent as IToken
		"""
		Consumes an option COLON (which generates a warning), 1 or more EOLs and an INDENT.
		Returns the INDENT.
		"""
		if .optional('COLON')
			_warning('Colons are not used to start indented blocks.')
		.expect('EOL')
		while .optional('EOL')
			pass
		return .expect('INDENT')

	def dedent
		while .optional('EOL')
			pass
		.expect('DEDENT')

	def indentIsDeclNames as List<of String>
		"""
		Parses indentation followed by "is" names, or "is" names followed by indentation.
		Example 1:
			def main is shared
				pass
		Example 2:
			def main
				is shared
				pass
		In either case, returns the list of "is" names or nil if there were none.
		"""
		if .peek().which=='IS'
			isNames = .isDeclNames()
			.expect('INDENT')
			return isNames
		else
			if .optionalIndent()
				return .isDeclNames()
			else
				return List<of String>()

	def optionalIndent as IToken?
		if .optional('COLON')
			_warning('Colons are not used to start indented blocks.')
		.oneOrMore('EOL')
		return .optional('INDENT')


	##
	## Parsing
	##

	var _module as Module

	def parseTokens as Module
		"""
		Parses and then returns an instance of Module.
		"""
		require
			.globalNS
		code
			_module = CobraModule(_fileName, _verbosity)  # TODO: does module really need verbosity?
			if not _fileName.endsWith('SystemInterfaces.cobra')
				# TODO: make an "implicit" token
				useToken = Token(_fileName, 1, 1, 1, 'USE', 'use', nil)
				# default use directives
				_module.addDecl(UseDirective(useToken, nil, ['System']))
				_module.addDecl(UseDirective(useToken, nil, ['System', 'Collections', 'Generic']))
				_module.addDecl(UseDirective(useToken, nil, ['System', 'IO']))
				_module.addDecl(UseDirective(useToken, nil, ['System', 'Text']))
				_module.addDecl(UseDirective(useToken, nil, ['Cobra', 'Lang']))
			# TODO: _module.docString = .docString()
			what as IMember?
			keepParsing = true
			while keepParsing
				what = nil
				addToNS = true
				tok = .peek()
				if tok is nil
					break
				branch tok.which
					on 'STOPSTOP':	keepParsing = false
					on 'USE':       what = .useDirective()
					on 'IMPORT':    what = .importDirective()
					on 'CLASS':     what = .classDecl()
					on 'INTERFACE': what = .interfaceDecl()
					on 'STRUCT':    what = .structDecl()
					on 'ENUM':      what = .enumDecl()
					on 'EOL':       .grab()
					on 'NAMESPACE'
						what = .nameSpaceDecl()
						addToNS = false
					else
						_error('Expecting use, import, namespace, class, interface or enum, but got [tok]')
						break
				if what
					_module.addDecl(what to IMember)  # CC: axe typecast
					if addToNS
						_globalNS.addDecl(what to IMember)  # CC: axe "to NamedNode"

			return _module

	def useDirective as IMember
		assert false
		return nil to passthrough

	def importDirective as IMember
		assert false
		return nil to passthrough

	def classDecl as Class
		token = .expect('CLASS')
		peek = .peek().which
		if peek == 'ID'
			token = .expect('ID')
			name = token.value to String
		else if peek == 'OPEN_GENERIC'
			token = .expect('OPEN_GENERIC')
			name = token.value to String
		else
			_error('Expecting a class name.')
		if name[0] not in _uppercaseLetters
			_error('Class names must start with an uppercase letter in order to avoid collisions with other identifiers such as arguments and local variables.')

		# CC: rename paramsList to params (can't do it now because it's a C# reserved word and Cobra needs to generate IL or 'escape' these)
#		paramsList = []
#		if token.which=='OPEN_GENERIC'
#			expectComma = false
#			while 1
#				if .peek().which=='GT'
#					.grab()
#					break
#				if expectComma
#					.expect('COMMA')
#				ident = .expect('ID').value
#				paramsList.append(GenericParam(ident))
#				expectComma = true

		.indent()

		isNames = .isDeclNames()

#		while .optional('WHERE')
#			if token.which!='OPEN_GENERIC'
#				_error('Unexpected where clause for non-generic class.')
#			paramName = .expect('ID').value
#			found = false
#			for param in params
#				if param.name==paramName
#					found = true
#					break
#			if not found
#				_error('Unknown generic parameter "%s".' % name)
#			if param.constraints
#				_error('Already specified constraints for "%s".' % name)
#			.expect('MUST')
#			.expect('BE')
#			expectComma = false
#			while 1
#				if expectComma
#					.expect('COMMA')
#				param.constraints.append(.genericConstraint())
#				if .optional('EOL')
#					break
#				expectComma = true
		paramList = List<of INode>() # TODO: axe

		baseName as String?
		if .optional('INHERITS')
			baseName = .expect('ID').text
			.expect('EOL')
		else
			baseName = nil

#		interfaceNames = []
#		if .optional('IMPLEMENTS')
#			expectComma = false
#			while 1
#				if .peek().which=='EOL'
#					.grab()
#					break
#				if expectComma
#					.expect('COMMA')
#				interfaceName = .type()  # using .type since interface could be a generic like IEnumerable(of T)
#				interfaceNames.append(interfaceName)
#				expectComma = true
		interfaceNames = List<of String>()  # TODO: axe

		docString = .docString()

		theClass = Class(token, name, paramList, isNames, baseName, interfaceNames, docString)

		# TODO when supporting nested classes, look at the clintDeclStack and set a back pointer here
		_boxStack.push(theClass)
#		.isNamesStack = Stack(str)
		.classMemberDecls(theClass)
		_boxStack.pop()

		return theClass



	var _validIsNames as List<of String>?

	def isDeclNames as List<of String>
		"""
		Example source:
			# The | below is not literal--it's where this method starts parsing.
			def Compute()
				|is virtual, protected
		Example return values:
			[]
			['shared']
			['private', 'shared']
		Errors:
			TODO
		Used by: classDecl, interfaceDecl, enumDecl, indentIsDeclNames
		"""
		if _validIsNames is nil
			_validIsNames = ['fake', 'shared', 'virtual', 'nonvirtual', 'override', 'public', 'protected', 'private', 'internal']
		names = List<of String>()
		if _isNamesStack
			names.add(_isNamesStack.peek())
#		CC: use this instead of above 3 lines: names = if(_isNamesStack, [_isNamesStack.peek()], List<of String>())
		isWord = .optional('IS')
		if isWord is nil
			return names
		while true
			what = .grab().text
			if what in _validIsNames
				names.add(what)
			else
				_error('Not expecting "[what]".')
			comma = .optional('COMMA')
			if comma is nil
				break
		.oneOrMore('EOL')
		# TODO: error on virtual and override
		# TODO: error on virtual and shared
		# TODO: error if 2 or more of 'public', 'protected', 'private', 'internal'
		return names

	def interfaceDecl as Class  # TODO: InterfaceDecl
		assert false, 'TO DO'
		return nil to passthrough

	def structDecl as Class  # TODO: StructDecl
		assert false, 'TO DO'
		return nil to passthrough

	def enumDecl as Class  # TODO: Enum
		assert false, 'TO DO'
		return nil to passthrough

	def nameSpaceDecl as NameSpace
		require _nameSpaceStack
		.expect('NAMESPACE')
		curNameSpace = _nameSpaceStack.peek() to NameSpace  # CC: remove "as INode"
		tok = .expect('ID')
		name = tok.value to String  # CC: .value should probably be dynamic
		curNameSpace = curNameSpace.getOrMakeNameSpaceNamed(tok, name)
		_nameSpaceStack.push(curNameSpace)
		.indent()
		while true
			peek = .peek()
			if peek is nil
				_error('expecting a namespace member, but source code ended')
			tok = peek to IToken  # CC: to !
			if tok.which=='DEDENT'
				break
			branch tok.which
				on 'CLASS':  curNameSpace.addDecl(.classDecl())
				on 'INTERFACE': curNameSpace.addDecl(.interfaceDecl())
				on 'STRUCT': curNameSpace.addDecl(.structDecl())
				on 'USE': curNameSpace.addDecl(.useDirective())
				on 'NAMESPACE': .nameSpaceDecl()
				else: _error('expecting a namespace member but got [tok]')
		.dedent()
		_nameSpaceStack.pop()
		return curNameSpace

	def classMemberDecls(theClass as Class)
		decl as INode?
		breakLoop = false  # cannot use 'break' to stop a 'while' loop in a branch statement. CC?
		while not breakLoop
			decl = nil
			branch .peek().which
				on 'PASS'
					.classPass()
					breakLoop = true
				on 'DEDENT': breakLoop = true
				on 'DEF': theClass.addDecl(.declareMethod())
				on 'GET': theClass.addDecl(.declarePropertyGet())
				on 'SET': theClass.addDecl(.declarePropertySet())
				on 'PRO': theClass.addDecl(.declareProperty())
				on 'EOL': .oneOrMore('EOL')
				on 'SHARED': .classMemberDeclsShared(theClass)
				else
					_error('Got [.peek()] when expecting var, def, pro, get, set, enum or shared')
			if decl!
				theClass.addDecl(decl to IMember)  # CC: axe typecast when if gets smart about not nil
		.dedent()

	def classMemberDeclsShared(theClass as Class)
		.expect('SHARED')
		.indent()
		_isNamesStack.push('shared')
		try
			.classMemberDecls(theClass)
		finally
			_isNamesStack.pop()

	def classPass
		if .curBox.declsInOrder
			_warning('Encountered "pass" in a class that already has declared members.')  # TODO: change to an error
		.grab()
		.oneOrMore('EOL')

	def declareMethod as Method
		require _typeProvider
		token = .expect('DEF')
		opener = .grab()
		if opener.which not in ['ID', 'OPEN_CALL']
			_error('Encountered [opener.which] when expecting an identifier.')
		name = opener.value to String
		curClass = .curBox
		if name==curClass.name or Utils.capped(name)==curClass.name
			_error('Method names cannot be the same as their enclosing [curClass.englishName]. Use `def construct` for creating a constructor or choose another name.')  # TODO list the enclosing types location
# TODO
#		overload = nil
#		other = curClass.symbolForName(name, true)
#		if other
#			if name=='destruct'
#				.error('Cannot define more than one destruct method.')  # TODO give reference to the other one
#			if inherits(other, MemberOverload)
#				overload = other
#			else if inherits(other, DefOneCodeBlockMember)
#				overload = MemberOverload(token, other)
#				curClass.registerOverload(overload)
#			else
#				.error('There is already another class member with the name "%s".' % name)  # TODO list its location and possibly what it is
#		else
#			other = curClass.symbolForNameCI(name, true)
#			if other
#				.error('There is already another class member with the name "%s". You must differentiate member names by more than just case.' % other.name)
#			if name[0] in .uppercaseLetters
#				.error('%s names must start with lowercase letters. (%s)' % ('Method', name))

		if opener.which=='OPEN_CALL'
			paramsList = .paramDecls(true)
		else
			paramsList = List<of Param>()

		if .optional('AS')
			returnType = .type()
		else
			returnType = _typeProvider.voidType
		assert returnType

		if curClass inherits Class
			isNames = .indentIsDeclNames()
#			implements = .optional('IMPLEMENTS') and .type() or nil
#			if implements
#				.oneOrMore('EOL')
#			docString = .docString()
			docString = ''

#			assert returnType
#			if name=='construct'
#				if returnType is not tvoid
#					.error('Cannot declare a return type for construct.')
#				defMethod = DefConstruct(token, .curBox, paramsList, isNames, docString)
#			else if name=='destruct'
#				if returnType is not tvoid
#					.error('Cannot declare a return type for destruct.')
#				if paramsList
#					.error('Cannot declare parameters for destruct.')
#				if 'shared' in isNames
#					.error('Cannot declare a shared destructor.')
#				defMethod = DefDestruct(token, .curBox, isNames, docString)
#			else
#				if name=='constructor'
#					.warning('Did you mean to say `construct`?')
#				else if name=='destructor'
#					.warning('Did you mean to say `destruct`?')
			implementsList = List<of INode>()
			if true
				method = Method(token, .curBox, name, paramsList, returnType, isNames, implementsList, docString)
			.statementsFor(method)
		else if curClass inherits Interface
			if .optionalIndent()
				isNames = .isDeclNames()
#				docString = .docString()
				docString = ''
				.dedent()
			else
				isNames = List<of String>()
				docString = ''
			implementsList = List<of INode>()
			if name=='construct'
				_error('Cannot declare "construct" in an interface.')
			else if name=='destruct'
				_error('Cannot declare "destruct" in an interface.')
			else
				method = Method(token, .curBox, name, paramsList, returnType, isNames, implementsList, docString)
		else
			throw Exception('Unhandled containing type [curClass]')
		assert method
#		if overload
#			overload.addMember(defMethod)
		return method

	def declareProperty as Property
		"""
		Example source
			pro age as int
				get
					return _age
				set
					assert value>0
					_age = value
		"""
		token = .expect('PRO')
		overload as MemberOverload? = nil  # CC: axe "as MemberOverload" when Cobra gets smarter about type inference of "x = nil"
		if .optional('LBRACKET')
			paramsList = .paramDecls(true, 'RBRACKET')
			name = r'[]'
			other = .curBox.declForName(name)
			if other
				if other inherits MemberOverload
					overload = other
				else if other inherits Property
					overload = MemberOverload(.curBox, other)
					.curBox.registerOverload(overload to MemberOverload)  # CC: axe typecast
		else
			name = .expect('ID').text
			.checkProperty(name)
			if .optional('FROM')
				return .declarePropertyFrom(token, name, 'getset')
			paramsList = List<of Param>()
		if .optional('AS')
			returnType = .type()
		else
			returnType = _typeProvider.dynamicType
		assert returnType
		if .curBox inherits Class
			isNames = .indentIsDeclNames()
			docString = .docString()
			if paramsList
				assert false, 'TODO: implement indexers'
			prop = Property(token, .curBox, name, returnType, isNames, docString)

# TODO:
#			if .peek().which=='TEST'
#				.testSection(defProperty)

			getWord = .optional('GET')
			if getWord
				.indent()
				.statementsFor(prop.makeGetPart(getWord to IToken))  # CC: axe to IToken

			setWord = .optional('SET')
			if setWord
				.indent()
				.statementsFor(prop.makeSetPart(setWord to IToken))  # CC: axe to IToken

			.dedent()
# TODO
#		else if .curBox inherits Interface
#			if .optionalIndent
#				isNames = .isDeclNames()
#				docString = .docString()
#				.dedent()
#			else
#				isNames = List<of String>()
#				docString = nil
#			defProperty = Property(token, .curBox, name, paramsList, returnType, isNames, docString)
#			defProperty.makeGetPart(token)
#			defProperty.makeSetPart(token)
		else
			throw FallThroughException(.curBox)
		if overload
			overload.addMember(prop)
		return prop

	def declarePropertyFrom(token as IToken, name as String, coverWhat as String) as Property
		require coverWhat in ['get', 'set', 'getset']
		if .optional('VAR')
			varName = '_' + name
		else
			varName = .expect('ID').text
		possibleVarDef = .curBox.declForName(varName)
		if not possibleVarDef inherits ClassVar
#TODO			if _verbosity>=3
#				.curBox.dumpNames(sys.stdout)
			_error('A property can only cover for variables. [varName] is a [possibleVarDef]')
		varDef = possibleVarDef to ClassVar
		if .curBox inherits Interface
			_error('Cannot use the "from" form of a property inside an interface declaration.')
		if .optionalIndent()
			docString = .docString()
			.dedent()
		else
			docString = nil
		isNames = List<of String>()  # TODO: cover isNames
		return Property(token, .curBox, name, isNames, varDef, coverWhat, docString)

	def declarePropertyGet as Property
		"""
		Example source
			get meaningOfLife as int
				return 42
		"""
		token = .expect('GET')
		overload as MemberOverload? = nil
		if .optional('LBRACKET')
			paramsList = .paramDecls(true, 'RBRACKET')
			name = r'[]'
			other = .curBox.declForName(name)
			if other
				if other inherits MemberOverload
					overload = other
				else if other inherits Property
					overload = MemberOverload(.curBox, other)
					.curBox.registerOverload(overload to MemberOverload)  # CC: axe typecast
		else
			name = .expect('ID').text
			.checkProperty(name)
			if .optional('FROM')
				return .declarePropertyFrom(token, name, 'get')
			paramsList = List<of Param>()
		if .optional('AS')
			returnType = .type()
		else
			returnType = _typeProvider.dynamicType
		assert returnType!

		if .curBox inherits Class
			isNames = .indentIsDeclNames()
			docString = .docString()
			prop = Property(token, .curBox, name, returnType, isNames, docString)
			.statementsFor(prop.makeGetPart(token), prop)
# TODO
#		else if .curBox inherits Interface
#			if .optionalIndent
#				isNames = .isDeclNames()
#				docString = .docString()
#				.dedent()
#			else
#				isNames = List<of String>()
#				docString = nil
#			prop = Property(token, .curBox, name, paramsList, returnType, isNames, docString)
#			prop.makeGetPart(token)
		else
			throw FallThroughException(.curBox)
		if overload
			overload.addMember(prop)
		return prop

	def declarePropertySet as Property
		"""
		Example source
			set foo as int
				_foo = value
		"""
		token = .expect('SET')
		name = .expect('ID').text
		.checkProperty(name)
		if .optional('FROM')
			return .declarePropertyFrom(token, name, 'set')
		if .optional('AS')
			returnType = .type()
			assert returnType
		else
			returnType = _typeProvider.dynamicType
		assert returnType

		if .curBox inherits Class
			isNames = .indentIsDeclNames()
			docString = .docString()
			defProperty = Property(token, .curBox, name, returnType, isNames, docString)
			.statementsFor(defProperty.makeSetPart(token), defProperty)
		else if .curBox inherits Interface
			if .optionalIndent()
				isNames = .isDeclNames()
				docString = .docString()
				.dedent()
			else
				isNames = List<of String>()
				docString = nil
			prop = Property(token, .curBox, name, returnType, isNames, docString)
			prop.makeSetPart(token)
		else
			throw FallThroughException(.curBox)

		return prop


	##
	## Parameter declarations
	##

	def paramDecls(skipParen as bool) as List<of Param>
		return .paramDecls(skipParen, 'RPAREN')

	def paramDecls(skipParen as bool, rightParen as String) as List<of Param>
		if not skipParen
			.expect('LPAREN')
		paramsList = List<of Param>()
		expectComma = false
		while true
			if .peek().which==rightParen
				.grab()
				break
			if expectComma
				.expect('COMMA')
			param = .paramDecl()
			paramsList.add(param)
			if paramsList.count==1 and param.name=='self' and param.type is _typeProvider.dynamicType
				_warning('The first parameter is "self" which may be a Python carry-over on your part. Cobra does not require that (and calls it "this" anyway).')
			expectComma = true
		return paramsList

	def paramDecl as Param
		return .paramDecl(_typeProvider.dynamicType)

	def paramDecl(defaultType as IType) as Param
		"""
		Example source:
			x as int
			x as int?
			x as vari object
			x   # default type is dynamic    # TODO: should be unspecified
		Arguments:
			theClass is typically ClassVarDecl, LocalVar or Param
			whatName could be set to 'Parameter' for example.
		Returns:
			A theClass(name, type)
		Errors:
			None
		"""
		token = .expect('ID')
		identifier = token.value to String
		.checkStartsLowercase(identifier, 'Parameter')
		type as INode?
		if .peek().which=='AS'
			.grab()
			varii = .optional('VARI')
			type = .type()
			if varii
				type = _typeProvider.variType(type)
		else
			type = nil
		if type inherits IType
			param = Param(token, type)
		else if type inherits INode
			param = Param(token, type)
		else
			throw FallThroughException(type)
		# print param
		return param


	##
	## Top Level Statement Entry
	##

	def statementsFor(codePart as ICodePart)
		.statementsFor(codePart, nil)

	def statementsFor(codePart as ICodePart, codePartContainingTest as ClassMember?)
		"""
		Example source
			<any statement 1>
			<any statement 2>
			<any statement N>
		Example source
			test
				<any statement 1>
				<any statement 2>
				<any statement N>
			code
				<any statement 1>
				<any statement 2>
				<any statement N>
		Returns
			Nothing.
		Errors
			Already encountered "code" block.
			Already encountered "test" block.
		"""
		_pushCodePart(codePart)
		if codePartContainingTest is nil
			codePartContainingTest = codePart to ClassMember  # TODO: figure out better typing for this assignement and the method sig of this method
		try
			if .peek().which in ['CODE', 'TEST', 'REQUIRE', 'ENSURE']
				# sectional
				# not flexible. sequence is signature, contract, test, implementation
				_isContractOnSameLine = false
#				if .peek().which=='REQUIRE'
#					.require(codePart)
#				if .peek().which=='ENSURE'
#					.ensure(codePart)
#				if .peek().which=='TEST'
#					.testSection(codePartContainingTest)
#				if .peek().which=='CODE'
#					.grab()
#					codePart.setBlock(.block())
#				else
				if true
					if _isContractOnSameLine
						_statementsFor(codePart)
					else
						_error('Expecting `code` section.')
				if not _isContractOnSameLine
					.dedent()
			else
				# non-sectional
				_statementsFor(codePart)
		finally
			_curCodePart = nil

	def _statementsFor(codePart as ICodePart)
		"""
		Utility method for .statementsFor.
		"""
		while .peek().which<>'DEDENT'
			stmt = .stmt()
			if stmt is not nil
				codePart.addStmt(stmt to Stmt)  # CC: axe "to Stmt"
		.dedent()

	def stmt as Stmt?
		token = .peek()
		which = token.which
		s as Stmt? # the statement (node)
		expectEOL = true
		branch token.which
			on 'ASSERT'
				s = .assertStmt()
			on 'BRANCH'
				s = .branchStmt()
				expectEOL = false
			on 'BREAK'
				s = .breakStmt()
			on 'CONTINUE'
				s = .continueStmt()
			on 'EXPECT'
				s = .expectStmt()
				expectEOL = false
			on 'FOR'
				s = .forStmt()
				expectEOL = false
#			on 'DEF'
#				s = .declareMethod()
			on 'IF'
				s = .ifStmt()
				expectEOL = false
			on 'GET'
				_error('Cannot use "get" for a statement. If you mistakenly started a property above with "def", "get" or "set", then use "pro" instead.')
			on 'PASS'
				s = .passStmt()
			on 'POST'
				s = .postWhileStmt()
				expectEOL = false
			on 'PRINT'
				s = .printStmt()
				expectEOL = false
			on 'RETURN'
				s = .returnStmt()
			on 'THROW'
				s = .throwStmt()
			on 'TRY'
				s = .tryStmt()
				expectEOL = false
			on 'USING'
				s = .usingStmt()
				expectEOL = false
			on 'WHILE'
				s = .whileStmt()
				expectEOL = false
			on 'EOL'
				.grab()  # ignore stray EOL (can especially come up at the end of a file)
				expectEOL = false
			else
				s = .expression()
				s.afterParserRecognizesStatement()
		if expectEOL
			if .verbosity>=5
				print '<> last statement start token=[token]'
				print '<> s = [s]'
			.expect('EOL')
		_finishSpaceAgnostic()
		return s


	##
	## Individual Statements
	##

	def assertStmt as Stmt
		token = .expect('ASSERT')
		expr = .expression()
		# CC: could the following 5 lines be: info = if(.optional('COMMA'), .expression(), nil)
		info as Expr?
		if .optional('COMMA')
			info = .expression()
		else
			info = nil
		return AssertStmt(token, expr, info)

	def branchStmt as Stmt
		return Stmt(.grab())

	def breakStmt as Stmt
		return Stmt(.grab())

	def continueStmt as Stmt
		return Stmt(.grab())

	def expectStmt as Stmt
		return Stmt(.grab())

	def forStmt as Stmt
		return Stmt(.grab())

	def ifStmt as Stmt
		return Stmt(.grab())

	def passStmt as Stmt
		return Stmt(.grab())

	def postWhileStmt as Stmt
		return Stmt(.grab())

	def printStmt as Stmt
		"""
		Example source:
			print arg
			print a, b, c
			print to sw, a, b
			print to sw, a, b stop
			print a, b, c stop
			print to sw
				code
		"""
		destination as Expr?
		block as BlockStmt?
		token = .expect('PRINT')
		args = List<of Expr>()
		stopp = false
		if .optional('TO')
			destination = .expression()
			peek = .peek().which
			if peek=='COMMA'
				.grab()
			else if peek=='EOL'
				block = .block()
			else
				_error('Expecting a comma and print arguments, or a code block.')
		if not block
			args = .commaSepExprs(['EOL', 'STOP'])
			terminator = .last
			if terminator.which=='STOP'
				stopp = true
				.expect('EOL')
		if block
			return PrintRedirectStmt(token, destination, block)
		else
			return PrintStmt(token, destination, args, stopp)

	def returnStmt as Stmt
		token = .expect('RETURN')
		expr as Expr?  # axe this decl when Cobra looks at the second assignment in after "x = nil"
		if .peek().which=='EOL'
			expr = nil
		else
			expr = .expression()
		return ReturnStmt(token, expr)

	def throwStmt as Stmt
		return Stmt(.grab())

	def tryStmt as Stmt
		return Stmt(.grab())

	def usingStmt as Stmt
		return Stmt(.grab())

	def whileStmt as Stmt
		return Stmt(.grab())


	##
	## Statement parts
	##

	get curCodeMember as String
		return ''

	def block as BlockStmt
		"""
		Used by if, while, print-to, etc.
		Consumes the (optional colon,) indent, statements and dedent.
		Returns a BlockStmt().
		"""
		assert false
		assert .curCodeMember
		token = .indent()
		stmts = List<of Stmt>()
		while true
			stmt = .stmt()
			if stmt is not nil
				stmts.add(stmt)
			if .peek().which=='DEDENT'
				break
		if not stmts
			_error('Missing statements in block. Add a real statement or a "pass".')
		.dedent()
		return BlockStmt(token, stmts)


	##
	## Expressions
	##

	shared
		var _binaryOpPrec = {
			# CANNOT USE 0 AS A VALUE IN THIS DICTIONARY
			'DOT':				80,
			'LBRACKET':			80,
			'LPAREN':			80,

			'STARSTAR':			70,  # right associative

			'QUESTION':			68,
			'BANG':				68,

			'TO':				65,
			'TOQ':				65,

			'STAR':				60,
			'SLASH':			60,
			'SLASHSLASH':		60,
			'PERCENT':			60,

			'PLUS':				50,
			'MINUS':			50,

			'EQ':				40,
			'NE':				40,
			'LT':				40,
			'GT':				40,
			'LE':				40,
			'GE':				40,
			'IS':				40,
			'ISNOT':			40,
			'INHERITS':			40,
			'IMPLEMENTS':		40,

			'IN':				35,
			'NOTIN':			35,

			'AND':				30,
			'OR':				30,
			'IMPLIES':			20,

			'ASSIGN':			20,
			'PLUS_EQUALS':		20,
			'MINUS_EQUALS':		20,
			'STAR_EQUALS':		20,
			'SLASH_EQUALS':		20,
			'PERCENT_EQUALS':	20,
			'QUESTION_EQUALS':	20,
			'BANG_EQUALS':		20,
		}

		var _unaryOpPrec = {
			'MINUS': _binaryOpPrec['MINUS']+1,
			'NOT': _binaryOpPrec['AND']+1,
			'OLD': _binaryOpPrec['STARSTAR']+1,
		}

	def expression as Expr
		test
			# CC: neither of these work and both should

			#assert 0 not in _binaryOpPrec.values

			#for v in _binaryOpPrec.values
			#	assert v<>0

			pass

		code
			return .expression(0, nil)


	def expression(precedence as int) as Expr
		return .expression(precedence, nil)


	def expression(precedence as int, left as Expr?) as Expr
		if left is nil
			left = .expression2()
		while true
			peek = .peek().which
			# handle multi-word operators
			op as String? = nil
			if peek=='IS' and .peek(1).which=='NOT'  # CC: change to .peek(+1)
				# 'is not' is a 2 keyword operator
				op = 'ISNOT'
			else if peek=='NOT' and .peek(1).which=='IN'  # CC: change to .peek(+1)
				op = 'NOTIN'
			# handle precedence (and detect non-binary operators)
			binaryOpPrec = Utils.getSI(_binaryOpPrec, op ? peek, -1)
			if binaryOpPrec==-1 or binaryOpPrec<precedence
				break
			# continue...
			if peek=='LBRACKET'
				# requires special handling - IndexExpr
				token = .grab()
				exprs = .commaSepExprs('RBRACKET')
				return .expression(precedence, IndexExpr(token, left, exprs))
			else if peek=='LPAREN'
				# requires special handling - PostCallExpr
				token = .grab()
				exprs = .commaSepExprs('RPAREN')
				assert false, 'TODO'
#				return .expression(precedence, PostCallExpr(token, left, exprs))
			else
				# most operators are one-word affairs
				if op is nil
					opToken = .grab()
					op = opToken.which
				else
					# op was set earlier for a two word operator. ISNOT NOTIN
					opToken = .grab()
					.grab()
				# TODO: axe the following section
#				if op=='QUESTION'
					# ? can be a binary operator, or a unary postfix operator
#					if .peek().which in ['COMMA', 'EOL', 'RPAREN']
#						return IsNilExpr(opToken, left)
#					if _binaryOpPrec.containsKey(.peek().which) and .peek().which!<>'DOT'
#						# keep chugging
#						left = IsNilExpr(opToken, left)
#						opToken = .grab()
#						op = opToken.which
				if op=='BANG'
					if .peek().which in ['COMMA', 'EOL', 'RPAREN']
						return IsNotNilExpr(opToken, left)
					if _binaryOpPrec.containsKey(.peek().which) and .peek().which<>'DOT'
						# keep chugging
						left = IsNotNilExpr(opToken, left)
						opToken = .grab()
						op = opToken.which
			assert _binaryOpPrec.containsKey(op)
			_leftStack.push(left)
			.opStack.push(op)
			try
				prec = if(OperatorSpecs.rightAssoc().containsKey(op), binaryOpPrec, binaryOpPrec+1)
				right = .expression(prec)
#				if right inherits IdentifierExpr
#					if right.definition is UnknownId
#						_errorUnknownId(right.text)  # TODO this seems wrong since the name might not be available until later
				if .peek().which=='QUESTION'
					# ? unary postfix is higher precedence than any binary operator
					right = IsNilExpr(.grab(), right)
				else if .peek().which=='BANG'
					# ! unary postfix is higher precedence than any binary operator
					right = IsNotNilExpr(.grab(), right)
				left = BinaryOpExpr(opToken, op, left, right)
			finally
				.opStack.pop()
				_leftStack.pop()
#		if left inherits IdentifierExpr and left.definition is UnknownId
#			.errorUnknownId(left.text)  # TODO this seems wrong since the name might not be available until later
		assert left
		return left to Expr  # CC: to !

	def expression2 as Expr
		peek = .peek().which
		if _unaryOpPrec.containsKey(peek)
			token = .grab()
			prec = _unaryOpPrec[peek]
			if token.which=='OLD'
				return OldExpr(token, .expression(prec))
			else
				return UnaryOpExpr(token, peek, .expression(prec))
		# TODO: make a branch statement
		else if peek=='LPAREN'
			.grab()
			node = .expression(0, nil)
			.expect('RPAREN')
			return node
		else if peek=='DOT'
			# leading dot
			token = .grab()
			peek = .peek().which
			if peek=='ID'
				token = .expect('ID')
				assert false, 'TODO'
#				expr = MemberExpr(token, token.text, nil, nil)
			else if peek=='OPEN_CALL'
				assert false, 'TODO'
#				expr = .callExpr()
			else
				_error('Syntax error after "."')
			expr = Expr(Token.empty)  # TODO: axe this when the above are fixed
			return BinaryOpExpr(token, 'DOT', ThisLit(token, .curBox), expr)
		else if peek=='NIL'
			return NilLiteral(.grab())
		else if peek=='TRUE'
			return BoolLiteral(.grab())
		else if peek=='FALSE'
			return BoolLiteral(.grab())
		else if peek=='THIS'
			return ThisLit(.grab(), .curBox)
		else if peek=='BASE'
			return BaseLit(.grab(), .curBox)
# TODO
#		else if peek=='VAR'
#			return VarLit(.grab(), .curCodeMember)
		else if peek=='CHAR_LIT_SINGLE'
			return CharLit(.grab())
		else if peek=='CHAR_LIT_DOUBLE'
			return CharLit(.grab())
		else if peek=='STRING_START_SINGLE'
			return .stringWithSubstitutionLit('STRING_START_SINGLE', 'STRING_PART_SINGLE', 'STRING_STOP_SINGLE')
		else if peek=='STRING_START_DOUBLE'
			return .stringWithSubstitutionLit('STRING_START_DOUBLE', 'STRING_PART_DOUBLE', 'STRING_STOP_DOUBLE')
		else if peek=='STRING_SINGLE'
			return StringLit(.grab())
		else if peek=='STRING_DOUBLE'
			return StringLit(.grab())
		else if peek=='INTEGER_LIT'
			return IntegerLit(.grab())
		else if peek=='DECIMAL_LIT'
			return DecimalLit(.grab())
		else if peek=='FLOAT_LIT'
			return FloatLit(.grab())
# TODO
#		else if peek=='LBRACKET'
#			return .literalList()
#		else if peek=='LCURLY'
#			return .literalDict()
#		else if peek=='OPEN_IF'
#			return .ifExpr()
		else if peek=='OPEN_CALL'
			return .callExpr()
#		else if peek=='OPEN_GENERIC'
#			return TypeExpr(.type())
		else if peek=='ID'
			return .identifierExpr()
		else
			return .typeExpr()
# TODO
#			try
#				return TypeExpr(.nonqualifiedType('throw'))
#			catch ParserError, pe
#				if pe.errorMessage==.expectingAType
#					.error('Expecting an expression.')
#				else
#					throw

	def callExpr as CallExpr
		"""
		Syntax:
			foo(args)
		"""
		token = .expect('OPEN_CALL')
		callName = token.value to String
		assert not callName.endsWith('(')
		exprs = .commaSepExprs('RPAREN')
		return CallExpr(token, callName, exprs)

	def commaSepExprs(terminator as String) as List<of Expr>
		return .commaSepExprs([terminator], false)

	def commaSepExprs(terminators as List<of String>) as List<of Expr>
		return .commaSepExprs(terminators, false)

	def commaSepExprs(terminators as List<of String>, isSpaceAgnostic as bool) as List<of Expr>
		"""
		Example source
			... expr TERMINATOR
			... expr, expr TERMINATOR
			... expr, expr, expr, TERMINATOR
		Returns
			A list of expressions.
		Notes
			Popular terminators are 'EOL' and 'RPAREN'.
			The terminator token is consumed, but can be examined with .last().
		"""
		expectComma = false
		exprs = List<of Expr>()
		while true
			if isSpaceAgnostic
				_spaceAgnostic()
			if .peek().which in terminators
				terminator = .grab()
				break
			if expectComma
				.expect('COMMA')
			if .peek().which in terminators
				terminator = .grab()
				break
			if isSpaceAgnostic
				_spaceAgnostic()
			if .peek().which in terminators
				terminator = .grab()
				break
			.newOpStack()
			try
				exprs.add(.expression())
			finally
				.delOpStack()
			expectComma = true
		return exprs

	def identifierExpr as Expr
		nameToken = .expect('ID')
		name = nameToken.text
		if .opStack and .opStack.peek()=='DOT'
			return MemberExpr(nameToken, name)
		if .peek().which=='AS'
# TODO
#			if name[0] not in .lowercaseLetters
#				.error(TidBits.localVarLowercaseError)
			asToken = .grab()
			type = .type()
			assert type
			return AsExpr(asToken, nameToken, type)
		else
			return IdentifierExpr(nameToken, name, nil)

	def stringWithSubstitutionLit(whichStart as String, whichPart as String, whichStop as String) as StringSubstLit
		# comment this mo-fo
		items = List<of Expr>()
		item = .expect(whichStart)
		items.add(StringLit(item))
		while true
			expr = .expression()
			fmt = .optional('STRING_PART_FORMAT')
			if fmt
				assert fmt.text.startsWith('')
				items.add(FormattedExpr(expr, fmt.text.substring(1)))
			else
				items.add(expr)
			peek = .peek().which
			if peek==whichPart
				items.add(StringLit(.grab()))
			else if peek==whichStop
				items.add(StringLit(.grab()))
				break
			else
				if _verbosity>=4
					print '<> stringWithSubstitutionLit([whichStart], [whichPart], [whichStop])'
				_error('Expecting more string contents or the string end after the expression.')
		return StringSubstLit(items)

	def typeExpr as TypeExpr
		t = .type()
		# Not expecting a TypeIdentifier() because the ID token case is
		# handled in expression parsing well before Cobra starts looking
		# for a type.
		if t inherits IType
			return TypeExpr(.last, t)
		else
			assert false, t

	##
	## Types
	##

	def type as INode
		token = .grab()
		# TODO: use typeForName()
		if token.text=='int'
			return IntType()
		else if token.text=='bool'
			return BoolType()
		else if token.text=='char'
			return CharType()
		else if token.text=='decimal'
			return DecimalType()
		else if token.text=='float'
			return FloatType()
		else if token.which=='ID'
			return TypeIdentifier(token)
		else
			_error('Unrecognized type: [token]')
			return CobraType()


	##
	## Op stack
	##

	def newOpStack
		require _opStackStack!
		_opStackStack.push(Stack<of String>())

	def delOpStack
		require _opStackStack
		_opStackStack.pop()

	get opStack as Stack<of String>
		"""
		Returns the current opStack.
		"""
		return _opStackStack.peek() to Stack<of String>  # CC: axe to String


	##
	## Protected self utility
	##

	def checkProperty(name as String)
		box = .curBox
		if name==box.name
			_error('Property names cannot be the same as their enclosing type.')  # TODO: list the enclosing types location
		other = box.declForName(name)
		if other
			_error('There is already another class member with the name "[name]".')  # TODO: list its location and possibly what it is
		other = box.declForNameCI(name)
		if other
			_error('There is already another class member with the name "[other.name]". You must differentiate member names by more than just case.')
		if Utils.startsNonLower(name)
			_error('Property names must start with lowercase letters. ([name])')

	def checkStartsLowercase(identifier as String, whatName as String)
		"""
		Makes an error if identifier does not match 'foo'.
		whatName should be capitalized.
		"""
		if identifier[0]=='_'
			sugg = identifier.substring(1, identifier.length-1)
			while sugg
				sugg = sugg.substring(1, sugg.length-1)
			sugg = sugg[0].toString().toLower() + sugg.substring(1, sugg.length-1)
			_error('[whatName] declarations cannot start with an underscore. Those are reserved for class variables. Try "[sugg]".')
		if Utils.startsNonLower(identifier)  # CC: should be char.isLower(identifier[0]), but cannot see members of char at this time
			sugg = identifier[0].toString().toLower() + identifier.substring(1, identifier.length-1)
			_error('[whatName] declarations must start with a lowercase letter to distinguish them from other types of identifiers. Try "[sugg]".')

	def _error(msg as String)
		token = .last
		if token
			msg = '[token.fileName]([token.lineNum],[token.colNum]): error: [msg]'
		else
			msg = '[token.fileName](1, 1): error: [msg]'
		if _whenError==WhenErrorEnum.exit
			print msg
			if _verbosity>=1
				print 'Last tokens:'
				print '    ...'
				for pair in .lastN(9)
					s = '    [pair.i]. [pair.token]'
					s = s.padRight(25) + 'line [pair.token.lineNum]'
					print s
			if _verbosity<2
				Environment.exit(1)
				# otherwise raise an exception in order to be more verbose
		throw ParserException(.last, msg)

	def _warning(msg as String)
		assert false, 'to do'

	def _pushCodePart(codePart as ICodePart)
		_codeParts.push(codePart)
		_curCodePart = codePart

	def _popCodePart
		require _codeParts
		_codeParts.pop()
		# CC: _curCodePart = if(_codeParts, _codeParts.peek(), nil)
		if _codeParts
			_curCodePart = _codeParts.peek() to ICodePart  # CC: axe "to ICodePart"
		else
			_curCodePart = nil

	def _spaceAgnostic
		pass

	def _finishSpaceAgnostic
		pass


class UseDirective
	inherits SyntaxNode
	implements IMember

	var _nameParts as List<of String>

	def construct(token as IToken, obj as Object?, nameParts as List<of String>)
		base.construct(token)
		_nameParts = nameParts

	get isCallable as bool
		return false

	## IMember

	get englishName as String
		return 'use directive'

	get name as String
		return CobraCore.toTechString(_nameParts)  # TODO: clean this up a bit and give this an impossible prefix so it can't actually be referred to from a Cobra program

	get resultType as IType
		assert false, 'should never use the result type of a UseDirective'


class NumberedToken
	"""
	In support of Parser.lastN.
	# TODO: Replace this with Pair<T1, T2>
	"""

	var _i as int
	var _token as IToken

	def construct(i as int, token as IToken)
		_i = i
		_token = token

	get i from var
	get token from var

	def toString as String is override
		return '([_i], [_token])'
