"""
The Cobra Parser
"""


class ParserException
	inherits CobraException

	var _token as IToken?

	def construct(token as IToken?, msg as String)
		base.construct(msg)
		_token = token


class Parser
	"""
	Notes:

		* The tokenizer's verbosity is set to 4 less than the parser's. In other words, the
		  tokenizer will not print messages unless the parser's verbosity is 5 or greater.

	"""

	test
		p = Parser()
		p.globalNS = NameSpace(Token.empty, '(global)')
		p.typeProvider = BasicTypeProvider()
		module = p.parseSource('test1', 'class Test\n\tpass\n')
		assert module
		decls = module.declsInOrder
		decl = decls[decls.count-1]
		if decl inherits Class
			assert decl.name == 'Test', decl.name
		else
			assert false, decl

		p = Parser()
		p.globalNS = NameSpace(Token.empty, '(global)')
		p.typeProvider = BasicTypeProvider()
		p.parseSource('test2', 'class Test\n\tdef main is shared\n\t\treturn\n')

	var _whenError as ErrorActionEnum
	var _whenWarning as WarningActionEnum

	var _lowercaseLetters = 'abcdefghijklmnopqrstuvwxyz'
	var _uppercaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

	var _fileName as String?
	var _willShowTokens = false
	var _verbosity = 0

	var _tokens as List<of IToken>?
	var _nextTokenIndex as int

	var _isNamesStack as Stack<of String>?
	var _boxStack as Stack<of Box>?

	var _globalNS as NameSpace
	var _nameSpaceStack as Stack<of NameSpace>

	var _codeParts as Stack<of ICodePart>
	var _curCodePart as ICodePart?

	var _spaceAgnosticIndentLevel as int
	var _isContractOnSameLine as bool

	var _leftStack as Stack<of Expr>
	var _opStackStack as Stack<of Stack<of String> >  # CC: should be able to say >> at the end instead of > >
		"""
		Used by expression parts so the last operator can be examined.
		A stack of stacks is needed for CallExpr's args.
		"""

	var _typeProvider as ITypeProvider

	def construct
		_boxStack = Stack<of Box>()
		_nameSpaceStack = Stack<of NameSpace>()
		_codeParts = Stack<of ICodePart>()

	pro verbosity from var

	pro whenError from var

	pro whenWarning from var

	pro typeProvider from var

	pro globalNS as NameSpace
		get
			return _globalNS
		set
			require _globalNS is nil
			_globalNS = value
			_nameSpaceStack.push(_globalNS)

	get curBox as Box
		# yes there is only one box at the moment, but when nested classes and structs are supported there could by many.
		return _boxStack.peek() to Box  # CC: axe typecast

	def parseFileNamed(fileName as String) as Module
		require .typeProvider
		_fileName = fileName
		source = File.readAllText(_fileName to String)  # CC: axe "to String" when "if" gets smart about non-nil
		return .parseSource(fileName, source)

	def parseSource(source as String) as Module
		require .typeProvider
		return .parseSource('(no file name)', source)

	def parseSource(fileName as String, source as String) as Module
		"""
		Parses module source code and returns resulting module.
		"""
		.preParseSource(fileName, source)
		return .parseTokens()

	def preParseSource(fileName as String, source as String)
		"""
		Sets up for parsing, but does not invoke parseTokens().
		Used by parseSource() and various test sections.
		"""
		_fileName = fileName
		tokVerbosity = _verbosity - 4  # in order words, tokenizer does not spew unless our verbosity is 5 or greater
		if tokVerbosity<0
			tokVerbosity = 0

		_isNamesStack = Stack<of String>()  # for `shared` for example
		_leftStack = Stack<of Expr>()
		_opStackStack = Stack<of Stack<of String> >()
		.newOpStack()

		_tokens = nil
		try
			_tokens = CobraTokenizer(tokVerbosity).startSource(_fileName, source).allTokens()
		catch te as TokenizerError
			msg = te.message
			if _verbosity>=5
				msg = 'Token error: ' + msg
			# TODO: may need to pass line and column number here
			_error(msg)

		_nextTokenIndex = 0


	##
	## Tokens
	##

	def grab as IToken?
		"""
		Returns the next token or nil if there are none left.
		"""
		if _nextTokenIndex >= _tokens.count
			return nil
		token = _tokens[_nextTokenIndex]
		_nextTokenIndex += 1
		if _willShowTokens
			print 'grab    --> [token]'
		return token

	def undo
		"""
		Undoes the last token() call. Often called "push" in parser examples.
		"""
		require _nextTokenIndex>0
		_nextTokenIndex -= 1
		if _willShowTokens
			print 'undo'

	def peek as IToken?
		return .peek(0)

	def peek(offset as int) as IToken?
		"""
		Returns a token without changing the current token, or nil if none left.
		With no offset, returns the current token, otherwise peeks ahead.
		"""
		i = _nextTokenIndex + offset
		if i < _tokens.count
			token = _tokens[i]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'peek([offset]) --> [token]'
		# TODO: resolve CUE
		if token is not nil and token.which=='CUE'
			token.which = 'DEF'
		return token

	get last as IToken?
		"""
		Returns the last token returned by get() or nil if get() was never invoked.
		"""
		if _nextTokenIndex > 0
			token = _tokens[_nextTokenIndex-1]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'last    --> [token]'
		return token

	def lastN(n as int) as List<of NumberedToken>  # CC: use List<of Pair<of int, IToken>>
		"""
		Returns a list of NumberedTokens.
		"""
		test
			p = Parser()
			s = 'namespace class Foo def'
			p.preParseSource('(no filename)', s)
			p.grab()
			p.grab()
			p.grab()
			t = p.lastN(2)
			assert t[0].token.which=='CLASS', t
			assert t[1].token.which=='ID', t
			assert t.count==2, t
		body
			tokens = List<of NumberedToken>()
			if _nextTokenIndex > 0
				while true
					n -= 1
					if n == -1
						break
					i = _nextTokenIndex - n - 1
					if i >= 0 and i < _tokens.count
						tokens.add(NumberedToken(i, _tokens[i]))
			return tokens

	def expect(whatTypes as vari String) as IToken
		"""
		Gets a token and complains if its type does not match whatType(s).
		Returns the token.
		"""
		t = .grab()
		if _willShowTokens
			print 'expect([whatTypes]) --> [t]'
		if t is nil
			_error('Expecting [.join(" or ",whatTypes)], but source ended suddenly.')
		# CC: support "not in" on vari type
		#if t.which not in whatTypes
		#	_error('Expecting [whatTypes], but got [t] instead.')
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if not found
			# TODO: remove support for cue
			if whatTypes[0]=='DEF' and t.which=='CUE'
				t.which = 'DEF'
			else
				_error('Expecting [.join(" or ",whatTypes)], but got [t] instead.')
		return t to IToken  # CC: to !

	def join(sep as String, stuff as vari String) as String
		# CC: have a join() method for vari, List, IEnumerable, array, etc.; use that and axe this helper method
		sb = StringBuilder()
		sep2 = ''
		for x in stuff
			sb.append(sep2)
			sb.append(x)
			sep2 = sep
		return sb.toString()

	def optional(whatTypes as vari String) as IToken?
		"""
		Gets a token, but only if it matches whatTypes.
		Does not complain or consume a token if there is no match.
		"""
		t = .peek()
		if _willShowTokens
			print 'optional([whatTypes]) --> [t]'
		if t is nil
			return nil
		# CC: support "in" on vari type
		#if t.which in whatTypes
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if found
			return .grab()
		else
			return nil

	def oneOrMore(which as String)
		"""
		Consumes the expected token and any other additional contiguous ones.
		Returns nothing.
		Example:  .oneOrMore('EOL')
		"""
		.expect(which)
		while .peek().which == which
			.grab()


	## Common parsing bits (docString, indent, dedent, ...)

	def docString as String?
		if .optional('DOC_STRING_START')
			textParts = List<of String>()
			keepGoing = true
			while keepGoing
				tok = .grab()
				branch tok.which
					on 'DOC_STRING_STOP'
						# TODO: check that indentation level is correct
						keepGoing = false
					on 'DOC_STRING_BODY_TEXT'
						textParts.add(tok.text)
					else
						_error('Expecting more doc string contents or the end of the doc string instead of [tok].')
			text = Utils.join('', textParts)
			return text
		else
			return ''

	def indent as IToken
		"""
		Consumes an option COLON (which generates a warning), 1 or more EOLs and an INDENT.
		Returns the INDENT.
		"""
		if .optional('COLON')
			_warning('Colons are not used to start indented blocks.')
		.expect('EOL')
		while .optional('EOL')
			pass
		return .expect('INDENT')

	def dedent
		while .optional('EOL')
			pass
		.expect('DEDENT')

	def indentIsDeclNames as List<of String>
		"""
		Parses indentation followed by "is" names, or "is" names followed by indentation.
		Example 1:
			def main is shared
				pass
		Example 2:
			def main
				is shared
				pass
		In either case, returns the list of "is" names or nil if there were none.
		"""
		if .peek().which=='IS'
			isNames = .isDeclNames()
			.expect('INDENT')
			return isNames
		else
			if .optionalIndent()
				return .isDeclNames()
			else
				return List<of String>()

	def optionalIndent as IToken?
		if .optional('COLON')
			_warning('Colons are not used to start indented blocks.')
		.oneOrMore('EOL')
		return .optional('INDENT')


	##
	## Parsing
	##

	var _module as Module

	def parseTokens as Module
		"""
		Parses and then returns an instance of Module.
		"""
		require
			.globalNS
		body
			docString = .docString()
			_module = CobraModule(_fileName, _verbosity, docString)  # TODO: does module really need verbosity?
			if not _fileName.endsWith('SystemInterfaces.cobra')
				# TODO: make an "implicit" token
				useToken = Token(_fileName, 1, 1, 1, 'USE', 'use', nil)
				# default use directives
				_module.addDecl(UseDirective(useToken, ['System']))
				_module.addDecl(UseDirective(useToken, ['System', 'Collections', 'Generic']))
				_module.addDecl(UseDirective(useToken, ['System', 'IO']))
				_module.addDecl(UseDirective(useToken, ['System', 'Text']))
				_module.addDecl(UseDirective(useToken, ['Cobra', 'Lang']))
			what as IMember?
			keepParsing = true
			while keepParsing
				what = nil
				addToNS = true
				tok = .peek()
				if tok is nil
					break
				branch tok.which
					on 'STOPSTOP':	keepParsing = false
					on 'USE':       what = .useDirective()
					on 'IMPORT':    what = .importDirective()
					on 'CLASS':     what = .classDecl()
					on 'INTERFACE': what = .interfaceDecl()
					on 'STRUCT':    what = .structDecl()
					on 'ENUM':      what = .enumDecl()
					on 'EOL':       .grab()
					on 'NAMESPACE'
						what = .nameSpaceDecl()
						addToNS = false
					else
						_error('Expecting use, import, namespace, class, interface or enum, but got [tok]')
						break
				if what
					_module.addDecl(what to IMember)  # CC: axe typecast
					if addToNS
						_globalNS.addDecl(what to IMember)  # CC: axe "to NamedNode"

			return _module

	def useDirective as UseDirective
		"""
		Example source:
			use System.Net
			use Foo
		"""
		token = .expect('USE')
		expectDot = false
		names = List<of String>()
		while true
			id = .expect('ID')
			names.add(id.text)
			dot = .optional('DOT')
			if not dot
				break
		.oneOrMore('EOL')
		return UseDirective(token, names)

	def importDirective as IMember
		assert false
		return nil to passthrough

	def classDecl as Class
		token = .expect('CLASS')
		peek = .peek().which
		if peek == 'ID'
			token = .expect('ID')
			name = token.value to String
		else if peek == 'OPEN_GENERIC'
			token = .expect('OPEN_GENERIC')
			name = token.value to String
		else
			_error('Expecting a class name.')
		if name[0] not in _uppercaseLetters
			_error('Class names must start with an uppercase letter in order to avoid collisions with other identifiers such as arguments and local variables.')

		# CC: rename paramsList to params (can't do it now because it's a C# reserved word and Cobra needs to generate IL or 'escape' these)
		paramsList = .declGenericParams(token)
		name = .nameForDeclGenericParams(token, paramsList)

		.indent()

		isNames = .isDeclNames()

		.genericConstraints(token, paramsList)

		baseNode as INode?
		if .optional('INHERITS')
			baseNode = .type()
			.expect('EOL')
		else
			baseNode = nil

		interfaceNames = List<of INode>()
		if .optional('IMPLEMENTS')
			expectComma = false
			while true
				if .peek().which=='EOL'
					.grab()
					break
				if expectComma
					.expect('COMMA')
				interfaceName = .type()  # using .type since interface could be a generic like IEnumerable(of T)
				interfaceNames.add(interfaceName)
				expectComma = true

		docString = .docString()

		theClass = Class(token, name, .makeList(List<of IType>(), paramsList) to List<of IType>, isNames, baseNode, interfaceNames, docString)

		# TODO when supporting nested classes, look at the clintDeclStack and set a back pointer here
		_boxStack.push(theClass)
#		.isNamesStack = Stack(str)
		.bodiedBoxMemberDecls(theClass)
		_boxStack.pop()

		return theClass

	def makeList(t as System.Collections.IList, u as System.Collections.IList) as System.Collections.IList
		# This feels awkward as hell, but it's a .NET typing thing, not a Cobra thing.
		# I need List<of GenericParam> in the my local code for declaring generics, but the various box constructors need to accept List<of IType>
		# TODO: remove this somehow. Maybe Cobra could have a promotion feature:
		# List<of IType>(paramsList promote to IEnumerable<of IType>)
		# "promote to" works for generics where the new promo type has parameter types that are the same or ancestors to the original parameter types *and* ... ???
		for item in u
			t.add(item)
		return t


	var _validIsNames as List<of String>?

	def isDeclNames as List<of String>
		"""
		Example source:
			# The | below is not literal--it's where this method starts parsing.
			def Compute()
				|is virtual, protected
		Example return values:
			[]
			['shared']
			['private', 'shared']
		Errors:
			TODO
		Used by: classDecl, interfaceDecl, enumDecl, indentIsDeclNames
		"""
		if _validIsNames is nil
			_validIsNames = ['fake', 'shared', 'virtual', 'nonvirtual', 'override', 'public', 'protected', 'private', 'internal']
		names = List<of String>()
		if _isNamesStack
			names.add(_isNamesStack.peek())
#		CC: use this instead of above 3 lines: names = if(_isNamesStack, [_isNamesStack.peek()], List<of String>())
		isWord = .optional('IS')
		if isWord is nil
			return names
		while true
			what = .grab().text
			if what in _validIsNames
				names.add(what)
			else
				_error('Not expecting "[what]".')
			comma = .optional('COMMA')
			if comma is nil
				break
		.oneOrMore('EOL')
		# TODO: error on virtual and override
		# TODO: error on virtual and shared
		# TODO: error if 2 or more of 'public', 'protected', 'private', 'internal'
		return names

	def declGenericParams(token as IToken) as List<of GenericParam>
		"""
		This parses and returns the generic params for a box
		declaration. It does NOT work for the generic params in other
		types such as a return type or a base class type--those can have
		other kinds parameters including other generic types and basic
		types. Box declarations only have generic parameter names.
		"""
		paramsList = List<of GenericParam>()
		if token.which=='OPEN_GENERIC'
			expectComma = false
			while true
				if .peek().which=='GT'
					.grab()
					break
				if expectComma
					.expect('COMMA')
				ident = .expect('ID').text
				paramsList.add(GenericParam(ident))
				expectComma = true
		return paramsList

	def nameForDeclGenericParams(token as IToken, paramList as List<of GenericParam>) as String
		"""
		This is called after declGenericParams() to update the name of the declaring type.
		CC: add an "out name" parameter to declGenericParams() and axe this method.
		"""
		name = token.text.trim()
		if token.which=='OPEN_GENERIC'
			for i = 0 .. paramList.count-1
				name += ','
			name += '>'
		return name

	def interfaceDecl as Interface
		token = .expect('INTERFACE')
		peek = .peek().which
		if peek == 'ID'
			token = .expect('ID')
			name = token.value to String
		else if peek == 'OPEN_GENERIC'
			token = .expect('OPEN_GENERIC')
			name = token.value to String
		else
			_error('Expecting an interface name.')
		if name[0] not in _uppercaseLetters
			_error('Interface names must start with an uppercase letter in order to avoid collisions with other identifiers such as arguments and local variables.')
		if not name.startsWith('I')
			_error('Interfaces must start with a capital "I".')

		# CC: rename paramsList to params (can't do it now because it's a C# reserved word and Cobra needs to generate IL or 'escape' these)
		paramsList = .declGenericParams(token)
		name = .nameForDeclGenericParams(token, paramsList)

		.indent()

		isNames = .isDeclNames()

		.genericConstraints(token, paramsList)

		baseNames = List<of INode>()
		if .optional('INHERITS')
			expectComma = false
			while true
				if .optional('EOL')
					break
				if expectComma
					.expect('COMMA')
				baseName = .type()  # using self.type since interface could be a generic like IEnumerable(of T)
				baseNames.add(baseName)
				expectComma = true

		if .optional('IMPLEMENTS')
			_error('Encountered "implements" in interface declaration. Use "inherits" instead.')

		# TODO: can an interface be nested in another interface?
		docString = .docString()

		theInterface = Interface(token, name, .makeList(List<of IType>(), paramsList) to List<of IType>, isNames, baseNames, docString)

		_boxStack.push(theInterface)
#		.isNamesStack = Stack(str)
		.bodiedBoxMemberDecls(theInterface)  # TODO: this shouldn't be bodiedBoxMemberDecls, right?
		_boxStack.pop()

		return theInterface

	def structDecl as Struct
		token = .expect('STRUCT')
		peek = .peek().which
		if peek == 'ID'
			token = .expect('ID')
			name = token.value to String
		else if peek == 'OPEN_GENERIC'
			token = .expect('OPEN_GENERIC')
			name = token.value to String
		else
			_error('Expecting a class name.')
		if name[0] not in _uppercaseLetters
			_error('Struct names must start with an uppercase letter in order to avoid collisions with other identifiers such as arguments and local variables.')

		# CC: rename paramsList to params (can't do it now because it's a C# reserved word and Cobra needs to generate IL or 'escape' these)
		paramsList = .declGenericParams(token)
		name = .nameForDeclGenericParams(token, paramsList)

		.indent()

		isNames = .isDeclNames()

		.genericConstraints(token, paramsList)

		baseName as String?
		if .optional('INHERITS')
			_error('Structs cannot inherit. If you mean to implement an interface, use "implements" instead.')

		interfaceNodes = List<of INode>()
		if .optional('IMPLEMENTS')
			assert false, 'TODO: implements for structs'
#			expectComma = false
#			while true
#				if .peek().which=='EOL'
#					.grab()
#					break
#				if expectComma
#					.expect('COMMA')
#				interfaceName = .type()  # using .type since interface could be a generic like IEnumerable(of T)
#				interfaceNames.append(interfaceName)
#				expectComma = true

		docString = .docString()

		theStruct = Struct(token, name, .makeList(List<of IType>(), paramsList) to List<of IType>, isNames, baseName, interfaceNodes, docString)

		# TODO when supporting nested classes, look at the clintDeclStack and set a back pointer here
		_boxStack.push(theStruct)
#		.isNamesStack = Stack(str)
		.bodiedBoxMemberDecls(theStruct)
		_boxStack.pop()

		return theStruct

	def enumDecl as EnumDecl
		token = .expect('ENUM')
		name = .expect('ID').value to String
		if name[0] not in _uppercaseLetters
			_error('Enum types must start with uppercase letters to avoid collisions with other identifiers such as properties and methods.')
		.indent()
		isNames = .isDeclNames()
		if .peek().which=='OF'
			possibleStorageType = .type()
			if possibleStorageType is .typeProvider.intType  # TODO: allow any integral type except char
				storageType as IType? = possibleStorageType to IType  # CC: axe "as IType?" and change "to IType?"
		docString = .docString()
		enumMembers = List<of EnumMember>()
		while .peek().which<>'DEDENT'
			enumNameToken = .expect('ID')
			if .peek().which=='ASSIGN'
				.grab()
				enumValue as int? = .expect('INTEGER_LIT').value to int  # CC: change cast to "to int?" and axe "as int?"
			else
				enumValue = nil
			.oneOrMore('EOL')
			enumMembers.add(EnumMember(enumNameToken, enumValue))
			# TODO: check for repeated names
			# TODO: check for values that repeat or go backwards
		.dedent()
		if not enumMembers
			_error('Missing enum members.')
		return EnumDecl(token, name, isNames, storageType, docString, enumMembers)

	def genericConstraints(token as IToken, paramsList as List<of GenericParam>)
		while .optional('WHERE')
			if token.which<>'OPEN_GENERIC'
				_error('Unexpected where clause for non-generic class.')
			paramName = .expect('ID').value
			found = false
			for param in paramsList
				if param.name==paramName
					found = true
					break
			if not found
				_error('Unknown generic parameter "[paramName]".')
			if param.constraints
				_error('Already specified constraints for "[paramName]".')
			.expect('MUST')
			.expect('BE')
			expectComma = false
			while true
				if expectComma
					.expect('COMMA')
				param.constraints.add(.genericConstraint())
				if .optional('EOL')
					break
				expectComma = true

	def genericConstraint as GenericConstraint
		"""
		Consumes a generic constraint and returns it.
		Constraints include classes, interfaces and the keywords:
			class struct callable
		"""
		peek = .peek().which
		branch peek
			on 'CLASS': return GenericClassConstraint(.grab())
			on 'STRUCT': return GenericStructConstraint(.grab())
			on 'CALLABLE': return GenericCallableConstraint(.grab())
			else: return GenericTypeConstraint(.type())
		pass  # CC: axe

	def nameSpaceDecl as NameSpace
		require _nameSpaceStack
		.expect('NAMESPACE')
		curNameSpace = _nameSpaceStack.peek() to NameSpace  # CC: remove "as INode"
		tok = .expect('ID')
		name = tok.value to String  # CC: .value should probably be dynamic
		curNameSpace = curNameSpace.getOrMakeNameSpaceNamed(tok, name)
		_nameSpaceStack.push(curNameSpace)
		.indent()
		while true
			peek = .peek()
			if peek is nil
				_error('expecting a namespace member, but source code ended')
			tok = peek to IToken  # CC: to !
			if tok.which=='DEDENT'
				break
			branch tok.which
				on 'CLASS':  curNameSpace.addDecl(.classDecl())
				on 'INTERFACE': curNameSpace.addDecl(.interfaceDecl())
				on 'STRUCT': curNameSpace.addDecl(.structDecl())
				on 'USE': curNameSpace.addDecl(.useDirective())
				on 'NAMESPACE': .nameSpaceDecl()
				else: _error('expecting a namespace member but got [tok]')
		.dedent()
		_nameSpaceStack.pop()
		return curNameSpace

	def bodiedBoxMemberDecls(box as Box)
# TODO: remove this when SystemInterfaces.cobra and "is fake" goes away
#		require
#			not box inherits Interface
		body
			decl as INode?
			breakLoop = false  # cannot use 'break' to stop a 'while' loop in a branch statement. CC?
			while not breakLoop
				decl = nil
				branch .peek().which
					on 'PASS'
						.classPass()
						breakLoop = true
					on 'DEDENT': breakLoop = true
					on 'DEF': .addDecl(box, .declareMethod())
					on 'GET': .addDecl(box, .declarePropertyGet())
					on 'SET': .addDecl(box, .declarePropertySet())
					on 'PRO': .addDecl(box, .declareProperty())
					on 'VAR': box.addDecl(.classVarDecl())
					on 'EOL': .oneOrMore('EOL')
					on 'ENUM': box.addDecl(.enumDecl())
					on 'SHARED': .bodiedBoxMemberDeclsShared(box)
					on 'TEST': .testSection(box)
					else
						_error('Got [.peek()] when expecting var, def, pro, get, set, enum or shared')
				if decl!
					box.addDecl(decl to IMember)  # CC: axe typecast when if gets smart about not nil
			.dedent()

	def addDecl(box as Box, member as ClassMember?)
		"""
		Created specifically to deal with the fact that overloads should not be added. The methods
		that encounter overloads will create (or affect existing) MemberOverloads and return nil.
		"""
		if member is not nil
			box.addDecl(member)

	def bodiedBoxMemberDeclsShared(box as Box)
		.expect('SHARED')
		.indent()
		_isNamesStack.push('shared')
		try
			.bodiedBoxMemberDecls(box)
		finally
			_isNamesStack.pop()

	def classPass
		if .curBox.declsInOrder
			_warning('Encountered "pass" in a class that already has declared members.')  # TODO: change to an error
		.grab()
		.oneOrMore('EOL')

	def classVarDecl as ClassVar
		varTok = .expect('VAR')
		tok = .expect('ID')
		identifier = tok.text
		other = .curBox.symbolForName(identifier, true, true)  # TODO: should probably really be symbolForName() even after the current symbolForName() becomes findSymbol() or findMember()
		if other
			# TODO need a test case to trigger this
			# TODO: this seems a little fishy as the type may be legit, but not resolved yet due to a forward reference.
			# The error message should not show '(no type)' or this check should be moved to bindInt
			reportType = if(other.resultType, other.resultType.name, '(no type)')
			_error('The name "[identifier]" was already declared earlier as a "reportType".')
		if identifier[0]<>'_'
			sugg = '_' + identifier
			_error('Class variables must start with an underscore to distinguish them from other types of identifiers. Try "[sugg]".')
		numUnderscores = 1
		s = identifier.substring(1)
		while s.startsWith('_')
			s = s.substring(1)
			numUnderscores += 1
		if not s
			_error('A class variable must be made of more than underscores. Try "[identifier]x" or "[identifier]1".')
		if s[0] not in _lowercaseLetters
			if s[0] in _uppercaseLetters
				sugg = String(c'_', numUnderscores) + s[0].toString().toLower() + s.substring(1)
				sugg = ' Try "[sugg]".'
			_error('Class variables must start with lowercase letters (after the underscore(s)) to distinguish them from other types of identifiers.[sugg]')
		type as INode? = if(.optional('AS'), .type(), TypeIdentifier(varTok, .typeProvider.unspecifiedType))
		if .optional('ASSIGN')
			initExpr as Expr? = .expression()  # CC: initExpr = .expression() to ?
		else
			initExpr = nil
			if type is nil
				type = .typeProvider.dynamicType
		docString as String? = ''  # CC: change to: docString = '' to ?
		isNames = List<of String>(_isNamesStack)
		if .peek().which=='IS'
			isNames = .isDeclNames()
			assert .last.which=='EOL'
			.undo()  # need the EOL
			if .optionalIndent()
				docString = .docString()
				.dedent()
		else
			if .optionalIndent()
				isNames = .isDeclNames()
				docString = .docString()
				.dedent()
		assert isNames is not nil
		return ClassVar(tok, .curBox, identifier, type, isNames, initExpr, docString)

	def declareMethod as OneCodeBlockMember?
		require _typeProvider
		token = .expect('DEF')
		opener = .grab()
		if opener.which not in ['ID', 'OPEN_CALL']
			_error('Encountered [opener.which] when expecting an identifier.')
		name = opener.value to String
		curClass = .curBox
		if name==curClass.name or Utils.capped(name)==curClass.name
			_error('Method names cannot be the same as their enclosing [curClass.englishName]. Use `def construct` for creating a constructor or choose another name.')  # TODO list the enclosing types location
		overload as MemberOverload? = nil
		other = curClass.symbolForName(name, true, true)
		if other
			if name=='destruct'
				_error('Cannot define more than one destruct method.')  # TODO give reference to the other one
			if other inherits MemberOverload
				overload = other
			else if other inherits OneCodeBlockMember
				overload = MemberOverload(other)
				curClass.registerOverload(overload to MemberOverload)  # CC: axe cast
			else
				_error('There is already another class member with the name "[name]".')  # TODO list its location and possibly what it is
		else
			other = curClass.symbolForName(name, true, false)  # TODO: should be a CI there for case-insensitive
			if other
				_error('There is already another class member with the name "[other.name]". You must differentiate member names by more than just case.')
			if name[0] in _uppercaseLetters
				_error('Method names must start with lowercase letters. ([name])')

		if opener.which=='OPEN_CALL'
			paramsList = .paramDecls(true)
		else
			paramsList = List<of Param>()

		if .optional('AS')
			returnType as INode? = .type()
		else
			returnType = _typeProvider.voidType
		assert returnType

		method as OneCodeBlockMember?

		if curClass inherits Class or curClass inherits Struct
			isNames = .indentIsDeclNames()
			implementsType = if(.optional('IMPLEMENTS'), .type(), nil)
			if implementsType
				.oneOrMore('EOL')
			docString = .docString()
			assert returnType
			if name=='init'
				if returnType is not .typeProvider.voidType
					_error('Cannot declare a return type for init.')
				method = Constructor(token, .curBox, paramsList, isNames, docString)
			else if name=='destruct'
				if returnType is not .typeProvider.voidType
					_error('Cannot declare a return type for destruct.')
				if paramsList
					_error('Cannot declare parameters for destruct.')
				if 'shared' in isNames
					_error('Cannot declare a shared destructor.')
				assert false
				# CC: method = Destructor(token, .curBox, isNames, docString)
			else
				if name=='constructor'
					_warning('Did you mean to say `construct`?')
				else if name=='destructor'
					_warning('Did you mean to say `destruct`?')
				method = Method(token, .curBox, name, paramsList, returnType, implementsType, isNames, docString)
			.statementsFor(method)
		else if curClass inherits Interface
			if .optionalIndent()
				isNames = .isDeclNames()
				docString = .docString()
				.dedent()
			else
				isNames = List<of String>()
				docString = ''
			if name=='init'
				_error('Cannot declare "init" in an interface.')
			else if name=='destruct'
				_error('Cannot declare "destruct" in an interface.')
			else
				method = Method(token, .curBox, name, paramsList, returnType, nil, isNames, docString)
		else
			throw Exception('Unhandled containing type [curClass]')
		assert method
		if overload
			overload.addMember(method to ClassMember)  # CC: axe cast when above assert is recoginzed as making method non-null
			return nil
		else
			return method

	def declareProperty as ProperDexer?
		"""
		Example source
			pro age as int
				get
					return _age
				set
					assert value>0
					_age = value
		"""
		prop as ProperDexer?
		token = .expect('PRO')
		overload as MemberOverload? = nil  # CC: axe "as MemberOverload" when Cobra gets smarter about type inference of "x = nil"
		if .optional('LBRACKET')
			paramsList = .paramDecls(true, 'RBRACKET')
			name = r'[]'
			other = .curBox.declForName(name)
			if other
				if other inherits MemberOverload
					overload = other
				else if other inherits ProperDexer
					overload = MemberOverload(other)
					.curBox.registerOverload(overload to MemberOverload)  # CC: axe typecast
		else
			name = .expect('ID').text
			.checkProperty(name)
			if .optional('FROM')
				return .declarePropertyFrom(token, name, 'getset')
			paramsList = List<of Param>()
		if .optional('AS')
			returnType as INode = .type()
		else
			returnType = _typeProvider.dynamicType
		assert returnType
		if .curBox inherits Class or .curBox inherits Struct
			isNames = .indentIsDeclNames()
			docString = .docString()
			if paramsList
				prop = Indexer(token, .curBox, name, paramsList, returnType, isNames, docString)
			else
				prop = Property(token, .curBox, name, returnType, isNames, docString)

			if .peek().which=='TEST'
				.testSection(prop to ProperDexer)  # CC: axe cast

			getWord = .optional('GET')
			if getWord
				.indent()
				.statementsFor(prop.makeGetPart(getWord))

			setWord = .optional('SET')
			if setWord
				.indent()
				.statementsFor(prop.makeSetPart(setWord))

			.dedent()
		else if .curBox inherits Interface
			if .optionalIndent()
				isNames = .isDeclNames()
				docString = .docString()
				.dedent()
			else
				isNames = List<of String>()
				docString = ''
			# TODO: support indexer?
			prop = Property(token, .curBox, name, returnType, isNames, docString)
			prop.makeGetPart(token)
			prop.makeSetPart(token)
		else
			throw FallThroughException(.curBox)
		if overload
			assert prop
			overload.addMember(prop to ProperDexer)  # CC: axe cast
			return nil
		else
			return prop

	def declarePropertyFrom(token as IToken, name as String, coverWhat as String) as Property
		require coverWhat in ['get', 'set', 'getset']
		if .optional('VAR')
			varName = '_' + name
		else
			varName = .expect('ID').text
		possibleVarDef = .curBox.declForName(varName)
		if not possibleVarDef inherits ClassVar
			_error('A property can only cover for variables. [varName] is a [possibleVarDef]')
		varDef = possibleVarDef to ClassVar
		if .curBox inherits Interface
			_error('Cannot use the "from" form of a property inside an interface declaration.')
		if .optionalIndent()
			docString = .docString()
			.dedent()
		else
			docString = ''
		isNames = List<of String>()  # TODO: cover isNames
		return Property(token, .curBox, name, isNames, varDef, coverWhat, docString)

	def declarePropertyGet as ProperDexer?
		"""
		Example source
			get meaningOfLife as int
				return 42
		"""
		prop as ProperDexer?
		token = .expect('GET')
		overload as MemberOverload? = nil
		if .optional('LBRACKET')
			paramsList = .paramDecls(true, 'RBRACKET')
			name = r'[]'
			other = .curBox.declForName(name)
			if other
				if other inherits MemberOverload
					overload = other
				else if other inherits ProperDexer
					overload = MemberOverload(other)
					.curBox.registerOverload(overload to MemberOverload)  # CC: axe typecast
		else
			name = .expect('ID').text
			.checkProperty(name)
			if .optional('FROM')
				return .declarePropertyFrom(token, name, 'get')
			paramsList = List<of Param>()
		if .optional('AS')
			returnType as INode = .type()
		else
			returnType = _typeProvider.dynamicType
		assert returnType!

		if .curBox inherits Class or .curBox inherits Struct
			isNames = .indentIsDeclNames()
			docString = .docString()
			if paramsList
				prop = Indexer(token, .curBox, name, paramsList, returnType, isNames, docString)
			else
				prop = Property(token, .curBox, name, returnType, isNames, docString)
			.statementsFor(prop.makeGetPart(token), prop)
		else if .curBox inherits Interface
			if .optionalIndent()
				isNames = .isDeclNames()
				docString = .docString()
				.dedent()
			else
				isNames = List<of String>()
				docString = ''
			# TODO: do we need support Indexers for interfaces?
			prop = Property(token, .curBox, name, returnType, isNames, docString)
			prop.makeGetPart(token)
		else
			throw FallThroughException(.curBox)
		if overload
			assert prop
			overload.addMember(prop to ProperDexer)  # CC: to !
			return nil
		else
			return prop

	def declarePropertySet as Property
		"""
		Example source
			set foo as int
				_foo = value
		"""
		token = .expect('SET')
		name = .expect('ID').text
		.checkProperty(name)
		if .optional('FROM')
			return .declarePropertyFrom(token, name, 'set')
		if .optional('AS')
			returnType as INode = .type()
			assert returnType
		else
			returnType = _typeProvider.dynamicType
		assert returnType

		if .curBox inherits Class or .curBox inherits Struct
			isNames = .indentIsDeclNames()
			docString = .docString()
			prop = Property(token, .curBox, name, returnType, isNames, docString)
			.statementsFor(prop.makeSetPart(token), prop)
		else if .curBox inherits Interface
			if .optionalIndent()
				isNames = .isDeclNames()
				docString = .docString()
				.dedent()
			else
				isNames = List<of String>()
				docString = ''
			prop = Property(token, .curBox, name, returnType, isNames, docString)
			prop.makeSetPart(token)
		else
			throw FallThroughException(.curBox)

		return prop


	##
	## Parameter declarations
	##

	def paramDecls(skipParen as bool) as List<of Param>
		return .paramDecls(skipParen, 'RPAREN')

	def paramDecls(skipParen as bool, rightParen as String) as List<of Param>
		if not skipParen
			.expect('LPAREN')
		paramsList = List<of Param>()
		expectComma = false
		while true
			if .peek().which==rightParen
				.grab()
				break
			if expectComma
				.expect('COMMA')
			param = .paramDecl()
			paramsList.add(param)
			if paramsList.count==1 and param.name=='self' and param.type is _typeProvider.dynamicType
				_warning('The first parameter is "self" which may be a Python carry-over on your part. Cobra does not require that (and calls it "this" anyway).')
			expectComma = true
		return paramsList

	def paramDecl as Param
		return .paramDecl(_typeProvider.dynamicType)

	def paramDecl(defaultType as IType) as Param
		"""
		Example source:
			x as int
			x as int?
			x as vari object
			x   # default type is dynamic    # TODO: should be unspecified
		Arguments:
			theClass is typically ClassVarDecl, LocalVar or Param
			whatName could be set to 'Parameter' for example.
		Returns:
			A theClass(name, type)
		Errors:
			None
		"""
		token = .expect('ID')
		identifier = token.value to String
		.checkStartsLowercase(identifier, 'Parameter')
		type as INode?
		if .peek().which=='AS'
			.grab()
			varii = .optional('VARI')
			type = .type()
			if varii
				type = _typeProvider.variType(type)
		else
			type = defaultType
		if type inherits IType
			param = Param(token, type)
		else if type inherits INode
			param = Param(token, type)
		else
			throw FallThroughException(type)
		# print param
		return param


	##
	## Top Level Statement Entry
	##

	def statementsFor(codePart as ICodePart)
		.statementsFor(codePart, nil)

	def statementsFor(codePart as ICodePart, codePartContainingTest as ClassMember?)
		"""
		Example source
			<any statement 1>
			<any statement 2>
			<any statement N>
		Example source
			test
				<any statement 1>
				<any statement 2>
				<any statement N>
			body
				<any statement 1>
				<any statement 2>
				<any statement N>
		Returns
			Nothing.
		Errors
			Already encountered "code" block.
			Already encountered "test" block.
		"""
		_pushCodePart(codePart)
		if codePartContainingTest is nil
			codePartContainingTest = codePart to ClassMember  # TODO: figure out better typing for this assignement and the method sig of this method
		try
			if .peek().which in ['BODY', 'TEST', 'REQUIRE', 'ENSURE']
				# sectional
				# not flexible. sequence is signature, contract, test, implementation
				_isContractOnSameLine = false
				if .peek().which=='REQUIRE'
					.requireSection(codePart)
				if .peek().which=='ENSURE'
					.ensureSection(codePart)
				if .peek().which=='TEST'
					.testSection(codePartContainingTest to ClassMember)  # CC: axe typecast
				if .peek().which=='BODY'
					.grab()
					.indent()
					_statementsFor(codePart)
					# TODO: old py code: remove: codePart.setBlock(.block())
				else
					if _isContractOnSameLine
						_statementsFor(codePart)
					else
						_error('Expecting `body` section.')
				if not _isContractOnSameLine
					.dedent()
			else
				# non-sectional
				_statementsFor(codePart)
		finally
			_popCodePart()

	def _statementsFor(codePart as ICodePart)
		"""
		Utility method for .statementsFor.
		"""
		while .peek().which<>'DEDENT'
			stmt = .stmt()
			if stmt is not nil
				codePart.addStmt(stmt to Stmt)  # CC: axe "to Stmt"
		.dedent()

	def stmt as Stmt?
		token = .peek()
		which = token.which
		s as Stmt? # the statement (node)
		expectEOL = true
		branch token.which
			on 'ASSERT'
				s = .assertStmt()
			on 'BRANCH'
				s = .branchStmt()
				expectEOL = false
			on 'BREAK'
				s = .breakStmt()
			on 'CONTINUE'
				s = .continueStmt()
			on 'EXPECT'
				s = .expectStmt()
				expectEOL = false
			on 'FOR'
				s = .forStmt()
				expectEOL = false
#			on 'DEF'
#				s = .declareMethod()
			on 'IF'
				s = .ifStmt()
				expectEOL = false
			on 'GET'
				_error('Cannot use "get" for a statement. If you mistakenly started a property above with "def", "get" or "set", then use "pro" instead.')
			on 'PASS'
				s = .passStmt()
			on 'POST'
				s = .postWhileStmt()
				expectEOL = false
			on 'PRINT'
				s = .printStmt()
				expectEOL = false
			on 'RETURN'
				s = .returnStmt()
			on 'THROW'
				s = .throwStmt()
			on 'TRY'
				s = .tryStmt()
				expectEOL = false
			on 'USING'
				s = .usingStmt()
				expectEOL = false
			on 'WHILE'
				s = .whileStmt()
				expectEOL = false
			on 'EOL'
				.grab()  # ignore stray EOL (can especially come up at the end of a file)
				expectEOL = false
			else
				s = .expression()
				s.afterParserRecognizesStatement()
		if expectEOL
			if .verbosity>=5
				print '<> last statement start token=[token]'
				print '<> s = [s]'
			.expect('EOL')
		_finishSpaceAgnostic()
		return s


	##
	## Individual Statements
	##

	def assertStmt as Stmt
		token = .expect('ASSERT')
		expr = .expression()
		# CC: could the following 5 lines be: info = if(.optional('COMMA'), .expression(), nil)
		info as Expr?
		if .optional('COMMA')
			info = .expression()
		else
			info = nil
		return AssertStmt(token, expr, info)

	def branchStmt() as Stmt
		token = .expect('BRANCH')
		e = .expression()
		.indent()
		onParts = List<of BranchOnPart>()
		elsePart as BlockStmt? = nil  # CC: axe type decl
		continuee = true  # CC: axe this when 'break' can be used in a branch inside a loop
		while continuee
			branch .peek().which
				on 'ON'
					.grab()
					if elsePart
						_error('Cannot have "on" parts after an "else" part.')
					exprs = .commaSepExprs(['COLON', 'EOL'])
					.undo()
					block = .branchPartStatements()
					onParts.add(BranchOnPart(exprs, block))
				on 'ELSE'
					.grab()
					if elsePart
						_error('Cannot have more than one "else" in a branch.')
					if not onParts
						_error('Cannot have an "else" in a branch without at least one "on".')
					elsePart = .branchPartStatements()
				on 'DEDENT'
					.grab()
					continuee = false  # CC: axe this when we can use break in a branch
				else
					_error('Expecting "on", "else" or end of branch statement. Encountered [.peek().which]')
		return BranchStmt(token, e, onParts, elsePart)

	def branchPartStatements() as BlockStmt
		if .peek().which=='COLON'
			.grab()
			stmt = .stmt()
			if stmt is nil
				_error('Need a statement.')
			block = BlockStmt(stmt.token, [stmt])
		else
			block = .block()
		return block

	def breakStmt as Stmt
		return BreakStmt(.expect('BREAK'))

	def continueStmt as Stmt
		return ContinueStmt(.expect('CONTINUE'))

	def expectStmt as Stmt
		# expect FooException
		#     block
		token = .expect('EXPECT')
		type = .type()
		block = .block()
		return ExpectStmt(token, type, block)

	def forStmt as Stmt
		"""
		numeric    for int x = 0 up to n step 2
		enumerable for Customer cust in customers
		"""
		token = .expect('FOR')
		varr = .localVarDecl()
		peek = .peek().which
		if peek=='ASSIGN'
			return .forNumericStmt(token, varr)
		else if peek=='IN'
			return .forEnumerableStmt(token, varr)
		else
			_error('Expecting "=" or "in".')
			return Stmt(Token.empty)  # make C# code flow analysis happy

	def forNumericStmt(token as IToken, varr as IVar) as ForNumericStmt
		.expect('ASSIGN')
		start = .expression()
		.expect('DOTDOT')
		stopp = .expression()
		dirToken = .optional('PLUSPLUS')
		if dirToken
			dir = 1
		else
			dirToken = .optional('MINUSMINUS')
			if dirToken
				dir = -1
		stepp as Expr?
		if dirToken is nil
			dir = 1
			stepp = nil
		else
			stepp = .expression()
		stmts = .block()
		return ForNumericStmt(token, varr, start, stopp, dir, stepp, stmts)

	def forEnumerableStmt(token as IToken, varr as IVar) as ForEnumerableStmt
		.expect('IN')
		what = .expression()
		stmts = .block()
		return ForEnumerableStmt(token, varr, what, stmts)

	def ifStmt as Stmt
		token = .expect('IF')
		cond = .expression()
		trueStmts = .block()
		falseStmts as BlockStmt?
		if .peek().which=='ELSE'
			.grab()
			peek = .peek().which
			if peek=='EOL'
				falseStmts = .block()
			else if peek=='IF'
				falseStmts = BlockStmt(.peek(), [.ifStmt()])
			else
				_error('Syntax error. Expecting end-of-line or "if" after an "else".')
		return IfStmt(token, cond, trueStmts, falseStmts)

	def passStmt as Stmt
		return Stmt(.grab())

	def postWhileStmt as Stmt
		token = .expect('POST')
		.expect('WHILE')
		return PostWhileStmt(token, .expression(), .block())

	def printStmt as Stmt
		"""
		Example source:
			print arg
			print a, b, c
			print to sw, a, b
			print to sw, a, b stop
			print a, b, c stop
			print to sw
				body
		"""
		destination as Expr?
		block as BlockStmt?
		token = .expect('PRINT')
		args = List<of Expr>()
		stopp = false
		if .optional('TO')
			destination = .expression()
			peek = .peek().which
			if peek=='COMMA'
				.grab()
			else if peek=='EOL'
				block = .block()
			else
				_error('Expecting a comma and print arguments, or a code block.')
		if not block
			args = .commaSepExprs(['EOL', 'STOP'])
			terminator = .last
			if terminator.which=='STOP'
				stopp = true
				.expect('EOL')
		if block
			return PrintRedirectStmt(token, destination, block)
		else
			return PrintStmt(token, destination, args, stopp)

	def returnStmt as Stmt
		token = .expect('RETURN')
		expr as Expr?  # axe this decl when Cobra looks at the second assignment in after "x = nil"
		if .peek().which=='EOL'
			expr = nil
		else
			expr = .expression()
		return ReturnStmt(token, expr)

	def requireSection(codeMember as ICodePart) as ConditionPart
		return _requireOrEnsure(codeMember, 'REQUIRE', RequirePart)

	def ensureSection(codeMember as ICodePart) as ConditionPart
		return _requireOrEnsure(codeMember, 'ENSURE', EnsurePart)

	def _requireOrEnsure(codeMember as ICodePart, whichToken as String, theClass as Type) as ConditionPart
		token = .expect(whichToken)
		if .peek().which in ['EOL', 'COLON']
			.indent()
			exprs = List<of Expr>()
			while true
				if .peek().which=='EOL'
					.grab()
					continue
				exprs.add(.expression())
				.expect('EOL')
				if .peek().which=='DEDENT'
					break
			.dedent()
		else
			# one expression, on the same line
			exprs = [.expression()]
			.expect('EOL')
			_isContractOnSameLine = true
		return theClass(token, codeMember, exprs) to ConditionPart

	def throwStmt as Stmt
		token = .expect('THROW')
		expr as Expr?  # CC: axe
		if .peek().which=='EOL'
			expr = nil
		else
			expr = .expression()
		return ThrowStmt(token, expr)

	def tryStmt as Stmt
		# try... except... success... finally...
		token = .expect('TRY')
		tryBlock = .block()
		catchBlocks = List<of CatchBlock>()
		didParseCatchAnyBlock = false  # meaning the catch that specifies no specific type of exception
		useCatchMsg = 'Use "catch" instead of "except". (Also, use "throw" for throwing exceptions and "raise" for raising events.)'
		if .peek().which=='EXCEPT'
			_error(useCatchMsg)
		while .peek().which=='CATCH'
			catchToken = .grab()
			if .peek().which in ['COLON', 'EOL']
				if didParseCatchAnyBlock
					_error('Already encountered the "catch every exception" block.')
				anyCatchBlock = .block()
				catchBlocks.add(CatchBlock(catchToken, anyCatchBlock))
				didParseCatchAnyBlock = true
			else
				if didParseCatchAnyBlock
					_error('Cannot have a specific exception block after the "catch every exception" block.')
				varr = .localVarDecl()
				# TODO Accept type, or id, or "id AS type". See what Boo does.
				if false
					catchType as INode?
					if .peek().which<>'EOL'
						catchType = .type()
						if .peek().which=='ID'
							catchVarToken = .expect('ID')
							_curCodePart.addLocal(LocalVar(catchVarToken, catchType))
				catchBlock = .block()
				catchBlocks.add(CatchBlock(catchBlock.token, varr, catchBlock))
		if .peek().which=='EXCEPT'
			_error(useCatchMsg)
		if .peek().which=='ELSE'
			_error('There is no "else" for a "try". There is a "success" however.')
		successBlock as BlockStmt?  # CC: find a way to remove this decl. possibly by adding "to ?" below
		if .peek().which=='SUCCESS'
			.grab()
			successBlock = .block()
		else
			successBlock = nil
		finallyBlock as BlockStmt?  # CC: find a way to remove this decl.
		if .peek().which=='FINALLY'
			.grab()
			finallyBlock = .block()
		else
			finallyBlock = nil
		if not catchBlocks and not successBlock and not finallyBlock
			_error('A try needs at least one "except", "success" or "finally" block.')
		return TryStmt(token, tryBlock, catchBlocks, successBlock, finallyBlock)

	def testSection(codeMember as ClassMember) as TestMethod
		"""
		Parses the `test` section and sets codeMember.testMethod.
		Returns the test method.
		"""
		# TODO: consider pushing the test method as the current code member
		token = .expect('TEST')
		.indent()
		testMethod = TestMethod(token, codeMember, .typeProvider.voidType)
		.statementsFor(testMethod)
		codeMember.testMethod = testMethod
		return testMethod

	def testSection(box as Box) as TestMethod
		# TODO: consider pushing the test method as the current code member
		token = .expect('TEST')
		.indent()
		assert token, token
		assert box, box
		testMethod = TestMethod(token, box, .typeProvider.voidType)
		.statementsFor(testMethod)
		box.testMethod = testMethod
		return testMethod

	def usingStmt as Stmt
		# syntax: using x = e  block
		token = .expect('USING')
		varr = .localVarDecl()
		.expect('ASSIGN')
		initExpr = .expression()
		block = .block()
		return UsingStmt(token, varr, initExpr, block)

	def whileStmt as Stmt
		return WhileStmt(.expect('WHILE'), .expression(), .block())


	##
	## Misc parts
	##

	def block as BlockStmt
		"""
		Used by if, while, print-to, etc.
		Consumes the (optional colon,) indent, statements and dedent.
		Returns a BlockStmt().
		"""
		token = .indent()
		stmts = List<of Stmt>()
		while true
			stmt = .stmt()
			if stmt is not nil
				stmts.add(stmt)
			if .peek().which=='DEDENT'
				break
		if not stmts
			_error('Missing statements in block. Add a real statement or a "pass".')
		.dedent()
		return BlockStmt(token, stmts)

	def localVarDecl as AbstractLocalVar
		return .localVarDecl(.typeProvider.unspecifiedType)

	def localVarDecl(defaultType as IType?) as AbstractLocalVar
		"""
		Variable declarations for parameters, `for` loops and exceptions.
		Not class vars (see classVarDecl()).
		Example source:
			x   # default type is dynamic   # TODO: should be unspecified
			i as int
			cust as Customer
		Arguments:
			theClass is typically ClassVarDecl, LocalVar or Param
			whatName could be set to 'Parameter' for example.
		Returns:
			A theClass(name, type)
		Errors:
			None
		"""
		token = .expect('ID')
		name = token.value to String
		.checkStartsLowercase(name, 'Variable')
		type as INode?
		if .peek().which=='AS'
			.grab()
			type = .type()
		else
			# maybe the var already exists?
			definition = _curCodePart.findLocal(name)
			if definition
				return definition to AbstractLocalVar  # CC: axe type cast
			type = nil

		type = (type ? defaultType) to INode
		assert type

		definition = _curCodePart.findLocal(name)

		# TODO: put this kind of check in bindImp maybe?
		if definition
			if definition.typeNode
				if definition.typeNode==type
					return definition to AbstractLocalVar  # same thing  # CC: axe type cast
				else
					# this should probably be moved to the bindImp phase since types can have different names like "int" and "System.Int32"
					_error('Cannot redeclare "[name]" from "[definition.typeNode]" to "[type]". Previous definition is on line [definition.token.lineNum].')
			else if definition.type
				if definition.type==type
					return definition to AbstractLocalVar  # same thing  # CC: axe type cast
				else
					# this should probably be moved to the bindImp phase since types can have different names like "int" and "System.Int32"
					_error('Cannot redeclare "[name]" from "[definition.type]" to "[type]". Previous definition is on line [definition.token.lineNum].')
			else
				throw FallThroughException(definition)

		# new def
		varr = LocalVar(token, type)
		_curCodePart.addLocal(varr)

		return varr

	##
	## Expressions
	##

	shared
		var _binaryOpPrec = {
			# CANNOT USE 0 AS A VALUE IN THIS DICTIONARY
			'DOT':				80,
			'LBRACKET':			80,
			'LPAREN':			80,

			'STARSTAR':			70,  # right associative

			'QUESTION':			68,
			'BANG':				68,

			'TO':				65,
			'TOQ':				65,

			'STAR':				60,
			'SLASH':			60,
			'SLASHSLASH':		60,
			'PERCENT':			60,

			'PLUS':				50,
			'MINUS':			50,

			'EQ':				40,
			'NE':				40,
			'LT':				40,
			'GT':				40,
			'LE':				40,
			'GE':				40,
			'IS':				40,
			'ISNOT':			40,
			'INHERITS':			40,
			'IMPLEMENTS':		40,

			'IN':				35,
			'NOTIN':			35,

			'AND':				30,
			'OR':				30,
			'IMPLIES':			20,

			'ASSIGN':			20,
			'PLUS_EQUALS':		20,
			'MINUS_EQUALS':		20,
			'STAR_EQUALS':		20,
			'SLASH_EQUALS':		20,
			'PERCENT_EQUALS':	20,
			'QUESTION_EQUALS':	20,
			'BANG_EQUALS':		20,
		}

		var _unaryOpPrec = {
			'MINUS': _binaryOpPrec['MINUS']+1,
			'NOT': _binaryOpPrec['AND']+1,
			'OLD': _binaryOpPrec['STARSTAR']+1,
		}

	def expression as Expr
		test
			# CC: neither of these work and both should

			#assert 0 not in _binaryOpPrec.values

			#for v in _binaryOpPrec.values
			#	assert v<>0

			pass

		body
			return .expression(0, nil)


	def expression(precedence as int) as Expr
		return .expression(precedence, nil)


	def expression(precedence as int, left as Expr?) as Expr
		if left is nil
			left = .expression2()
		while true
			peek = .peek().which
			# handle multi-word operators
			op as String? = nil
			if peek=='IS' and .peek(1).which=='NOT'  # CC: change to .peek(+1)
				# 'is not' is a 2 keyword operator
				op = 'ISNOT'
			else if peek=='NOT' and .peek(1).which=='IN'  # CC: change to .peek(+1)
				op = 'NOTIN'
			# handle precedence (and detect non-binary operators)
			binaryOpPrec = Utils.getSI(_binaryOpPrec, op ? peek, -1)
			if binaryOpPrec==-1 or binaryOpPrec<precedence
				break
			# continue...
			if peek=='LBRACKET'
				# requires special handling - IndexExpr
				token = .grab()
				exprs = .commaSepExprs('RBRACKET')
				return .expression(precedence, IndexExpr(token, left, exprs))
			else if peek=='LPAREN'
				# requires special handling - PostCallExpr
				# this happens for something like: foo[i]('x')
				token = .grab()
				exprs = .commaSepExprs('RPAREN')
				return .expression(precedence, PostCallExpr(token, left, exprs))
			else
				# most operators are one-word affairs
				if op is nil
					opToken = .grab()
					op = opToken.which
				else
					# op was set earlier for a two word operator. ISNOT NOTIN
					opToken = .grab()
					.grab()
				# TODO: axe the following section
				if op=='QUESTION'
					# ? can be a binary operator, or a unary postfix operator
					if .peek().which in ['COMMA', 'EOL', 'RPAREN']
						return IsNilExpr(opToken, left)
					if _binaryOpPrec.containsKey(.peek().which) and .peek().which<>'DOT'
						# keep chugging
						left = IsNilExpr(opToken, left)
						opToken = .grab()
						op = opToken.which
				if op=='BANG'
					if .peek().which in ['COMMA', 'EOL', 'RPAREN']
						return IsNotNilExpr(opToken, left)
					if _binaryOpPrec.containsKey(.peek().which) and .peek().which<>'DOT'
						# keep chugging
						left = IsNotNilExpr(opToken, left)
						opToken = .grab()
						op = opToken.which
			assert _binaryOpPrec.containsKey(op to String)  # CC: axe cast or !
			_leftStack.push(left to Expr)  # CC: axe cast with code flow analysis
			.opStack.push(op to String)  # CC: axe cast or !
			try
				prec = if(OperatorSpecs.rightAssoc().containsKey(op to String), binaryOpPrec, binaryOpPrec+1)  # CC: axe cast or !
				right = .expression(prec)
#				if right inherits IdentifierExpr
#					if right.definition is UnknownId
#						_errorUnknownId(right.text)  # TODO this seems wrong since the name might not be available until later
				if .peek().which=='QUESTION'
					# ? unary postfix is higher precedence than any binary operator
					right = IsNilExpr(.grab(), right)
				else if .peek().which=='BANG'
					# ! unary postfix is higher precedence than any binary operator
					right = IsNotNilExpr(.grab(), right)
				left = BinaryOpExpr.make(opToken to IToken, op to String, left to Expr, right to Expr)  # CC: assert opToken up higher and remove cast
			finally
				.opStack.pop()
				_leftStack.pop()
#		if left inherits IdentifierExpr and left.definition is UnknownId
#			.errorUnknownId(left.text)  # TODO this seems wrong since the name might not be available until later
		assert left
		return left to Expr  # CC: to !

	def expression2 as Expr
		peek = .peek().which
		if _unaryOpPrec.containsKey(peek)
			token = .grab()
			prec = _unaryOpPrec[peek]
			if token.which=='OLD'
				return OldExpr(token, .expression(prec))
			else
				return UnaryOpExpr(token, peek, .expression(prec))
		# TODO: make a branch statement
		else if peek=='LPAREN'
			.grab()
			node = .expression(0, nil)
			.expect('RPAREN')
			return node
		else if peek=='DOT'
			# leading dot
			token = .grab()
			peek = .peek().which
			if peek=='ID'
				memberToken = .expect('ID')
				expr = MemberExpr(memberToken, memberToken.text) to Expr
			else if peek=='OPEN_CALL'
				expr = .callExpr()
			else
				_error('Syntax error after "."')
			return BinaryOpExpr.make(token to IToken, 'DOT', ThisLit(token, .curBox), expr)
		else if peek=='NIL'
			return NilLiteral(.grab())
		else if peek=='TRUE'
			return BoolLit(.grab())
		else if peek=='FALSE'
			return BoolLit(.grab())
		else if peek=='THIS'
			return ThisLit(.grab(), .curBox)
		else if peek=='BASE'
			return BaseLit(.grab(), .curBox)
		else if peek=='VAR'
			assert _curCodePart
			if _curCodePart inherits ProperDexerXetter
				return VarLit(.grab(), _curCodePart)
			else
				_error('Cannot refer to `var` in expressions outside of a property `get` or `set`.')
				assert false  # stop a warning
		else if peek=='CHAR_LIT_SINGLE'
			return CharLit(.grab())
		else if peek=='CHAR_LIT_DOUBLE'
			return CharLit(.grab())
		else if peek=='STRING_START_SINGLE'
			return .stringWithSubstitutionLit('STRING_START_SINGLE', 'STRING_PART_SINGLE', 'STRING_STOP_SINGLE')
		else if peek=='STRING_START_DOUBLE'
			return .stringWithSubstitutionLit('STRING_START_DOUBLE', 'STRING_PART_DOUBLE', 'STRING_STOP_DOUBLE')
		else if peek=='STRING_SINGLE'
			return StringLit(.grab())
		else if peek=='STRING_DOUBLE'
			return StringLit(.grab())
		else if peek=='INTEGER_LIT'
			return IntegerLit(.grab())
		else if peek=='DECIMAL_LIT'
			return DecimalLit(.grab())
		else if peek=='FLOAT_LIT'
			return FloatLit(.grab())
		else if peek=='LBRACKET'
			return .literalList()
		else if peek=='LCURLY'
			return .literalDict()
		else if peek=='OPEN_IF'
			return .ifExpr()
		else if peek=='OPEN_CALL'
			return .callExpr()
		else if peek=='OPEN_GENERIC'
			return TypeExpr(.type())
		else if peek=='ID'
			return .identifierExpr()
		else if peek=='SHARP_OPEN'
			return .sharpExpr()
		else
			return .typeExpr()
# TODO
#			try
#				return TypeExpr(.nonqualifiedType('throw'))
#			catch ParserError, pe
#				if pe.errorMessage==.expectingAType
#					.error('Expecting an expression.')
#				else
#					throw

	def callExpr as CallExpr
		"""
		Syntax:
			foo(args)
		"""
		token = .expect('OPEN_CALL')
		callName = token.value to String
		assert not callName.endsWith('(')
		exprs = .commaSepExprs('RPAREN')
		return CallExpr(token, callName, exprs)

	def commaSepExprs(terminator as String) as List<of Expr>
		return .commaSepExprs([terminator], false)

	def commaSepExprs(terminators as List<of String>) as List<of Expr>
		return .commaSepExprs(terminators, false)

	def commaSepExprs(terminators as List<of String>, isSpaceAgnostic as bool) as List<of Expr>
		"""
		Example source
			... expr TERMINATOR
			... expr, expr TERMINATOR
			... expr, expr, expr, TERMINATOR
		Returns
			A list of expressions.
		Notes
			Popular terminators are 'EOL' and 'RPAREN'.
			The terminator token is consumed, but can be examined with .last().
		"""
		expectComma = false
		exprs = List<of Expr>()
		while true
			if isSpaceAgnostic
				_spaceAgnostic()
			if .peek().which in terminators
				terminator = .grab()
				break
			if expectComma
				.expect('COMMA')
			if .peek().which in terminators
				terminator = .grab()
				break
			if isSpaceAgnostic
				_spaceAgnostic()
			if .peek().which in terminators
				terminator = .grab()
				break
			.newOpStack()
			try
				exprs.add(.expression())
			finally
				.delOpStack()
			expectComma = true
		return exprs

	def identifierExpr as Expr
		nameToken = .expect('ID')
		name = nameToken.text
		if .opStack and .opStack.peek()=='DOT'
			return MemberExpr(nameToken, name)
		if .peek().which=='AS'
			if not Utils.startsWithLowerLetter(name)
				_error('Local variable declarations must start with a lowercase letter. This avoids collisions with other identifiers such as classes and enums.')
			asToken = .grab()
			type = .type()
			assert type
			return AsExpr(asToken, nameToken, type)
		else
			return IdentifierExpr(nameToken, name, nil)

	def ifExpr as IfExpr
		token = .expect('OPEN_IF')
		expr = .expression()
		.expect('COMMA')
		texpr = .expression()
		.expect('COMMA')
		fexpr = .expression()
		.expect('RPAREN')
		return IfExpr(token, expr, texpr, fexpr)

	def literalList as ListLit
		token = .expect('LBRACKET')
		exprs = .commaSepExprs(['RBRACKET'], true)
		return ListLit(token, exprs)

	def literalDict as DictLit
		token = .expect('LCURLY')
		expectComma = false
		entries = List<of List<of Expr> >() # CC: >>
		while true
			_spaceAgnostic()
			if .peek().which=='RCURLY'
				.grab()
				break
			if expectComma
				.expect('COMMA')
			if .peek().which=='RCURLY'
				.grab()
				break
			_spaceAgnostic()
			if .peek().which=='RCURLY'
				.grab()
				break
			key = .expression()
			.expect('COLON')
			value = .expression()
			entries.add([key, value])
			expectComma = true
		return DictLit(token, entries)

	def sharpExpr as SharpExpr
		token = .expect('SHARP_OPEN')
		expr = .expression()
		.expect('RPAREN')
		return SharpExpr(token, expr)

	def stringWithSubstitutionLit(whichStart as String, whichPart as String, whichStop as String) as StringSubstLit
		# comment this mo-fo
		items = List<of Expr>()
		item = .expect(whichStart)
		items.add(StringLit(item))
		while true
			expr = .expression()
			fmt = .optional('STRING_PART_FORMAT')
			if fmt
				assert fmt.text.startsWith('')
				items.add(FormattedExpr(expr, fmt.text.substring(1)))
			else
				items.add(expr)
			peek = .peek().which
			if peek==whichPart
				items.add(StringLit(.grab()))
			else if peek==whichStop
				items.add(StringLit(.grab()))
				break
			else
				if _verbosity>=4
					print '<> stringWithSubstitutionLit([whichStart], [whichPart], [whichStop])'
				_error('Expecting more string contents or the string end after the expression.')
		return StringSubstLit(items)

	def typeExpr as TypeExpr
		t = .type()
		# Not expecting a TypeIdentifier() because the ID token case is
		# handled in expression parsing well before Cobra starts looking
		# for a type.
		if t inherits IType
			return TypeExpr(.last, t)
		else if t inherits TypeIdentifier
			return TypeExpr(t)
		else
			assert false, t

	##
	## Types
	##

	def type as ISyntaxNode
		return .qualifiedType()

	def qualifiedType as ISyntaxNode
		"""
		May actually return a non-qualified type.
		"""
		types = List<of ISyntaxNode>()
		while true
			t = .nonqualifiedType()
			assert t
			types.add(t)
			if .peek().which=='DOT'
				if .peek(1).which=='OPEN_CALL'
					# See Tests\150-basics-two\510-number-parse.cobra
					break
				else
					.grab()
			else
				break
		assert types
		if types.count==1
			return types[0]
		else
			qt = QualifiedType(types)
			return TypeIdentifier(types[0].token, qt.name, qt)

	def nonqualifiedType as ISyntaxNode
		return .nonqualifiedType(ErrorActionEnum.Exit)

	def nonqualifiedType(action as ErrorActionEnum) as AbstractTypeIdentifier
		token = .grab()
		assert token

		t as AbstractTypeIdentifier?

		if token.which=='OPEN_GENERIC'
			t = .genericType(token to IToken)  # CC: axe cast

		# TODO: use a branch here
		else if token.text=='int'
			t = TypeIdentifier(token, .typeProvider.intType)
		else if token.text=='bool'
			t = TypeIdentifier(token, .typeProvider.boolType)
		else if token.text=='char'
			t = TypeIdentifier(token, .typeProvider.charType)
		else if token.text=='decimal'
			t = TypeIdentifier(token, .typeProvider.decimalType)
		else if token.text=='float'
			t = TypeIdentifier(token, .typeProvider.floatType)
		else if token.text=='passthrough'
			t = TypeIdentifier(token, .typeProvider.passThroughType)
		else if token.which=='ID'
			t = TypeIdentifier(token)
		else
			_error('Unrecognized type: [token]')
			return AbstractTypeIdentifier(Token.empty, '')  # CC: remove

		assert t<>nil

		# check for 'optional' aka 'can be nil'
		question = .optional('QUESTION')
		if question is not nil
			t = NilableTypeIdentifier(question, t)

		return t to AbstractTypeIdentifier  # CC: axe cast

	def genericType(openGenericToken as IToken) as AbstractTypeIdentifier
		require openGenericToken.text.trim().endsWith('<of')
		fullName = openGenericToken.text.trim() + ' '
		rootName = fullName.substring(0, fullName.length-4)  # CC: [:-4]
		expectComma = false
		types = List<of ISyntaxNode>()
		while true
			if .peek().which=='GT'
				.grab()
				break
			if expectComma
				.expect('COMMA')
				fullName += ', '
			t = .type()
			types.add(t)
			fullName += t.token.text # TODO: this is totally wrong because the type could be something complex like a qualified type or a generic type.
			expectComma = true
		fullName += '>'
		return GenericTypeIdentifier(openGenericToken, rootName, types, fullName)


	##
	## Op stack
	##

	def newOpStack
		require _opStackStack!
		_opStackStack.push(Stack<of String>())

	def delOpStack
		require _opStackStack
		_opStackStack.pop()

	get opStack as Stack<of String>
		"""
		Returns the current opStack.
		"""
		return _opStackStack.peek() to Stack<of String>  # CC: axe to String


	##
	## Protected self utility
	##

	def checkProperty(name as String)
		box = .curBox
		if name==box.name
			_error('Property names cannot be the same as their enclosing type.')  # TODO: list the enclosing types location
		other = box.declForName(name)
		if other
			_error('There is already another class member with the name "[name]".')  # TODO: list its location and possibly what it is
		other = box.declForNameCI(name)
		if other
			_error('There is already another class member with the name "[other.name]". You must differentiate member names by more than just case.')
		if Utils.startsNonLower(name)
			_error('Property names must start with lowercase letters. ([name])')

	def checkStartsLowercase(identifier as String, whatName as String)
		"""
		Makes an error if identifier does not match 'foo'.
		whatName should be capitalized.
		"""
		if identifier[0]=='_'
			sugg = identifier.substring(1, identifier.length-1)
			while sugg
				sugg = sugg.substring(1, sugg.length-1)
			sugg = sugg[0].toString().toLower() + sugg.substring(1, sugg.length-1)
			_error('[whatName] declarations cannot start with an underscore. Those are reserved for class variables. Try "[sugg]".')
		if Utils.startsNonLower(identifier)  # CC: should be char.isLower(identifier[0]), but cannot see members of char at this time
			sugg = identifier[0].toString().toLower() + identifier.substring(1, identifier.length-1)
			_error('[whatName] declarations must start with a lowercase letter to distinguish them from other types of identifiers. Try "[sugg]".')

	def _error(msg as String)
		token = .last
		if token
			msg = '[token.fileName]([token.lineNum],[token.colNum]): error: [msg]'
		else
			msg = '[_fileName](1, 1): error: [msg]'
		if _whenError==ErrorActionEnum.Exit
			print msg
			if _verbosity>=1
				print 'Last tokens:'
				print '    ...'
				for pair in .lastN(9)
					s = '    [pair.i]. [pair.token]'
					s = s.padRight(25) + 'line [pair.token.lineNum]'
					print s
			if _verbosity<2
				Environment.exit(1)
				# otherwise throw an exception in order to be more verbose
		throw ParserException(.last, msg)

	def _warning(msg as String)
		token = .last
		branch _whenWarning
			on WarningActionEnum.Print
				w = CobraWarning(_fileName, token, msg)
				print w.message
			on WarningActionEnum.Throw
				throw CobraWarning(_fileName, token, msg)
			else
				throw FallThroughException()

	def _pushCodePart(codePart as ICodePart)
		_codeParts.push(codePart)
		_curCodePart = codePart

	def _popCodePart
		require _codeParts
		_codeParts.pop()
		# CC: _curCodePart = if(_codeParts, _codeParts.peek(), nil)
		if _codeParts
			_curCodePart = _codeParts.peek() to ICodePart  # CC: axe "to ICodePart"
		else
			_curCodePart = nil

	def _spaceAgnostic
		"""
		Eats up EOLs, INDENTs and DEDENTs.
		Call this to go into "space agnostic" mode.
		Call finishSpaceAgnostic afterwards to eat up subsequent INDENTs and DEDENTs.
		"""
		while true
			peek = .peek().which
			branch peek
				on 'EOL'
					.grab()
					continue
				on 'INDENT'
					.grab()
					_spaceAgnosticIndentLevel += 1
					continue
				on 'DEDENT'
					.grab()
					_spaceAgnosticIndentLevel -= 1
					continue
			break

	def _finishSpaceAgnostic
		"""
		Eats up the DEDENTs and INDENTs that balance out the ones encountered in spaceAgnostic.
		"""
		if _verbosity>=5
			print '<> finishSpaceAgnostic() level=[_spaceAgnosticIndentLevel]'
		if _spaceAgnosticIndentLevel
			while _spaceAgnosticIndentLevel>0
				.dedent()
				_spaceAgnosticIndentLevel -= 1
			while _spaceAgnosticIndentLevel<0
				.expect('INDENT')
				_spaceAgnosticIndentLevel += 1
		assert _spaceAgnosticIndentLevel==0  # cobra: make this an ensure


class NumberedToken
	"""
	In support of Parser.lastN.
	# TODO: Replace this with Pair<T1, T2>
	"""

	var _i as int
	var _token as IToken

	def construct(i as int, token as IToken)
		_i = i
		_token = token

	get i from var
	get token from var

	def toString as String is override
		return '([_i], [_token])'
