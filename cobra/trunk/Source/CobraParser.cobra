"""
The Cobra Parser
"""


class ParserException
	inherits SystemException

	var _token as IToken
	var _msg as String

	def construct(token as IToken, msg as String)
		#base.construct(msg)  # CC:
		_token = token
		_msg = msg

	get message as String is override
		return _msg


class Parser
	"""
	Notes:

		* The tokenizer's verbosity is set to 4 less than the parser's. In other words, the
		  tokenizer will not print messages unless the parser's verbosity is 5 or greater.

	"""

	test
		p = Parser()
		p.globalNS = NameSpace('(global)')
		module = p.parseSource('test1', 'class Test\n\tpass\n')
		assert module
		decls = module.declsInOrder
		decl = decls[decls.count-1]
		if decl inherits Class
			assert decl.name == 'Test'
		else
			assert false, decl

		p = Parser()
		p.globalNS = NameSpace('(global)')
		p.parseSource('test2', 'class Test\n\tdef main is shared\n\t\treturn\n')

	enum WhenErrorEnum
		exit
		throww

	enum WhenWarningEnum
		emit
		throww

	var _whenError as WhenErrorEnum

	var _lowercaseLetters = 'abcdefghijklmnopqrstuvwxyz'
	var _uppercaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

	var _fileName as String?
	var _willShowTokens = false
	var _verbosity = 0

	var _tokens as List<of IToken>?
	var _curTokenIndex as int

	var _isNamesStack as Stack<of String>?
	var _boxStack as Stack<of Box>?

	var _globalNS as NameSpace
	var _nameSpaceStack as Stack<of NameSpace>

	var _codeParts as Stack<of ICodePart>
	var _curCodePart as ICodePart?

	var _isContractOnSameLine as bool


	def construct
		_boxStack = Stack<of Box>()
		_nameSpaceStack = Stack<of NameSpace>()
		_codeParts = Stack<of ICodePart>()

	pro verbosity from var

	pro whenError from var

	pro globalNS as NameSpace
		get
			return _globalNS
		set
			require _globalNS is nil
			_globalNS = value
			_nameSpaceStack.push(_globalNS)

	get curBox as Box
		# yes there is only one box at the moment, but when nested classes and structs are supported there could by many.
		return _boxStack.peek() to Box  # CC: axe typecast

	def parseFileNamed(fileName as String) as Module
		_fileName = fileName
		source = File.readAllText(_fileName to String)  # CC: axe "to String" when "if" gets smart about non-nil
		return .parseSource(fileName, source)

	def parseSource(source as String) as Module
		return .parseSource('(no file name)', source)

	def parseSource(fileName as String, source as String) as Module
		"""
		Parses module source code and returns resulting module.
		"""
		_fileName = fileName
		tokVerbosity = _verbosity - 4  # in order words, tokenizer does not spew unless our verbosity is 5 or greater
		if tokVerbosity<0
			tokVerbosity = 0

		_isNamesStack = Stack<of String>()  # for `shared` for example

		_tokens = nil
		try
			_tokens = CobraTokenizer(tokVerbosity).startSource(_fileName, source).allTokens()
		catch te as TokenizerError
			print '<> Caught TokenizerError'
			print te
			assert false
		_curTokenIndex = 0

		return .parseTokens()


	## Tokens

	def grab as IToken?
		"""
		Returns the next token or nil if there are none left.
		"""
		if _curTokenIndex >= _tokens.count
			return nil
		token = _tokens[_curTokenIndex]
		_curTokenIndex += 1
		if _willShowTokens
			print 'grab    --> [token]'
		return token

	def undo
		"""
		Undoes the last token() call. Often called "push" in parser examples.
		"""
		require _curTokenIndex>0
		_curTokenIndex -= 1
		if _willShowTokens
			print 'undo'

	def peek as IToken?
		return .peek(0)

	def peek(offset as int) as IToken?
		"""
		Returns a token without changing the current token, or nil if none left.
		With no offset, returns the current token, otherwise peeks ahead.
		"""
		i = _curTokenIndex + offset
		if i < _tokens.count
			token = _tokens[i]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'peek([offset]) --> [token]'
		return token

	get last as IToken?
		"""
		Returns the last token returned by get() or nil if get() was never invoked.
		"""
		if _curTokenIndex > 0
			token = _tokens[_curTokenIndex]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'last    --> [token]'
		return token

	def expect(whatTypes as vari String) as IToken?
		"""
		Gets a token and complains if its type does not match whatType(s).
		Returns the token.
		"""
		t = .grab()
		if _willShowTokens
			print 'expect([whatTypes]) --> [t]'
		if t is nil
			_error('Expecting [.join(" or ",whatTypes)], but source ended suddenly.')
		# CC: support "not in" on vari type
		#if t.which not in whatTypes
		#	_error('Expecting [whatTypes], but got [t] instead.')
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if not found
			_error('Expecting [.join(" or ",whatTypes)], but got [t] instead.')
		return t

	def join(sep as String, stuff as vari String) as String
		# CC: have a join() method for vari, List, IEnumerable, array, etc.; use that and axe this helper method
		sb = StringBuilder()
		sep2 = ''
		for x in stuff
			sb.append(sep2)
			sb.append(x)
			sep2 = sep
		return sb.toString()

	def optional(whatTypes as vari String) as IToken?
		"""
		Gets a token, but only if it matches whatTypes.
		Does not complain or consume a token if there is no match.
		"""
		t = .peek()
		if _willShowTokens
			print 'optional([whatTypes]) --> [t]'
		if t is nil
			return nil
		# CC: support "in" on vari type
		#if t.which in whatTypes
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if found
			return .grab()
		else
			return nil

	def oneOrMore(which as String)
		"""
		Consumes the expected token and any other additional contiguous ones.
		Returns nothing.
		Example:  .oneOrMore('EOL')
		"""
		.expect(which)
		while .peek().which == which
			.grab()


	## Common parsing bits (docString, indent, dedent, ...)

	def docString as String?
		return nil  # TODO

	def indent
		if .optional('COLON')
			_warning('Colons are not used to start indented blocks.')
		.expect('EOL')
		while .optional('EOL')
			pass
		.expect('INDENT')
		while .optional('EOL')  # added
			pass

	def dedent
		while .optional('EOL')
			pass
		.expect('DEDENT')
		while .optional('EOL')  # added
			pass

	def indentIsDeclNames as List<of String>
		"""
		Parses indentation followed by "is" names, or "is" names followed by indentation.
		Example 1:
			def main is shared
				pass
		Example 2:
			def main
				is shared
				pass
		In either case, returns the list of "is" names or nil if there were none.
		"""
		if .peek().which=='IS'
			isNames = .isDeclNames()
			.expect('INDENT')
			return isNames
		else
			if .optionalIndent()
				return .isDeclNames()
			else
				return List<of String>()

	def optionalIndent as IToken?
		if .optional('COLON')
			_warning('Colons are not used to start indented blocks.')
		.oneOrMore('EOL')
		return .optional('INDENT')


	## Parsing

	var _module as Module

	def parseTokens as Module
		"""
		Parses and then returns an instance of Module.
		"""
		require
			.globalNS
		code
			_module = CobraModule(_fileName, _verbosity)  # TODO: does module really need verbosity?
			if not _fileName.endsWith('SystemInterfaces.cobra')
				# default use directives
				_module.addDecl(UseDirective(nil, ['System']))
				_module.addDecl(UseDirective(nil, ['System', 'Collections', 'Generic']))
				_module.addDecl(UseDirective(nil, ['System', 'IO']))
				_module.addDecl(UseDirective(nil, ['System', 'Text']))
				_module.addDecl(UseDirective(nil, ['Cobra', 'Lang']))
			# TODO: _module.docString = .docString()
			what as NamedNode?
			while true
				what = nil
				addToNS = true
				tok = .peek()
				if tok is nil
					break
				branch tok.which
					on 'USE':       what = .useDirective()
					on 'IMPORT':    what = .importDirective()
					on 'CLASS':     what = .classDecl()
					on 'INTERFACE': what = .interfaceDecl()
					on 'STRUCT':    what = .structDecl()
					on 'ENUM':      what = .enumDecl()
					on 'EOL':       .grab()
					on 'NAMESPACE'
						.nameSpaceDecl()
						addToNS = false
					else
						_error('Expecting use, import, namespace, class, interface or enum, but got [tok]')
						break
				if what
					_module.addDecl(what to Node)  # CC: axe typecast
					if addToNS
						_globalNS.addDecl(what to NamedNode)  # CC: axe "to NamedNode"

			return _module

	def useDirective as NamedNode
		return NamedNode('TODO')

	def importDirective as NamedNode
		return NamedNode('TODO')

	def classDecl as NamedNode
		.expect('CLASS')
		peek = .peek().which
		if peek == 'ID'
			token = .expect('ID')
			name = token.value to String
		else if peek == 'OPEN_GENERIC'
			token = .expect('OPEN_GENERIC')
			name = token.value to String
		else
			_error('Expecting a class name.')
		if name[0] not in _uppercaseLetters
			_error('Class names must start with an uppercase letter in order to avoid collisions with other identifiers such as arguments and local variables.')

		# CC: rename paramsList to params (can't do it now because it's a C# reserved word and Cobra needs to generate IL or 'escape' these)
#		paramsList = []
#		if token.which=='OPEN_GENERIC'
#			expectComma = false
#			while 1
#				if .peek().which=='GT'
#					.get()
#					break
#				if expectComma
#					.expect('COMMA')
#				ident = .expect('ID').value
#				paramsList.append(GenericParam(ident))
#				expectComma = true

		.indent()

		isNames = .isDeclNames()

#		while .optional('WHERE')
#			if token.which!='OPEN_GENERIC'
#				_error('Unexpected where clause for non-generic class.')
#			paramName = .expect('ID').value
#			found = false
#			for param in params
#				if param.name==paramName
#					found = true
#					break
#			if not found
#				_error('Unknown generic parameter "%s".' % name)
#			if param.constraints
#				_error('Already specified constraints for "%s".' % name)
#			.expect('MUST')
#			.expect('BE')
#			expectComma = false
#			while 1
#				if expectComma
#					.expect('COMMA')
#				param.constraints.append(.genericConstraint())
#				if .optional('EOL')
#					break
#				expectComma = true
		paramList = List<of Node>() # TODO: axe

		baseName as String?
		if .optional('INHERITS')
			baseName = .expect('ID').text
			.expect('EOL')
		else
			baseName = nil

#		interfaceNames = []
#		if .optional('IMPLEMENTS')
#			expectComma = false
#			while 1
#				if .peek().which=='EOL'
#					.get()
#					break
#				if expectComma
#					.expect('COMMA')
#				interfaceName = .type()  # using .type since interface could be a generic like IEnumerable(of T)
#				interfaceNames.append(interfaceName)
#				expectComma = true
		interfaceNames = List<of String>()  # TODO: axe

		docString = .docString()

		theClass = Class(name, paramList, isNames, baseName, interfaceNames, docString)

		# TODO when supporting nested classes, look at the clintDeclStack and set a back pointer here
		_boxStack.push(theClass)
#		.isNamesStack = Stack(str)
		.classMemberDecls(theClass)
		_boxStack.pop()

		return theClass



	var _validIsNames as List<of String>?

	def isDeclNames as List<of String>
		"""
		Example source:
			# The | below is not literal--it's where this method starts parsing.
			def Compute()
				|is virtual, protected
		Example return values:
			[]
			['shared']
			['private', 'shared']
		Errors:
			TODO
		Used by: classDecl, interfaceDecl, enumDecl, indentIsDeclNames
		"""
		if _validIsNames is nil
			_validIsNames = ['fake', 'shared', 'virtual', 'nonvirtual', 'override', 'public', 'protected', 'private', 'internal']
		names = List<of String>()
		if _isNamesStack
			names.add(_isNamesStack.peek())
#		names = if(_isNamesStack, [_isNamesStack.peek()], List<of String>())
		isWord = .optional('IS')
		if isWord is nil
			return names
		while true
			what = .grab().text
			if what in _validIsNames
				names.add(what)
			else
				_error('Not expecting "[what]".')
			comma = .optional('COMMA')
			if comma is nil
				break
		.oneOrMore('EOL')
		# TODO: error on virtual and override
		# TODO: error on virtual and shared
		# TODO: error if 2 or more of 'public', 'protected', 'private', 'internal'
		return names

	def interfaceDecl as NamedNode
		return NamedNode('TODO')

	def structDecl as NamedNode
		return NamedNode('TODO')

	def enumDecl as NamedNode
		return NamedNode('TODO')

	def nameSpaceDecl as NameSpace
		require _nameSpaceStack
		.expect('NAMESPACE')
		curNameSpace = _nameSpaceStack.peek() to NameSpace  # CC: remove "as Node"
		name = .expect('ID').value to String  # CC: .value should probably be dynamic
		curNameSpace = curNameSpace.getOrMakeNameSpaceNamed(name)
		_nameSpaceStack.push(curNameSpace)
		.indent()
		while true
			tok = .peek()
			if tok.which=='DEDENT'
				break
			branch tok.which
				on 'CLASS':  curNameSpace.addDecl(.classDecl())
				on 'INTERFACE': curNameSpace.addDecl(.interfaceDecl())
				on 'STRUCT': curNameSpace.addDecl(.structDecl())
				on 'USE': curNameSpace.addDecl(.useDirective())
				on 'NAMESPACE': .nameSpaceDecl()
				else: _error('expecting "class" but got [tok]')
		.dedent()
		_nameSpaceStack.pop()
		return curNameSpace

	def classMemberDecls(theClass as Class)
		decl as Node?
		breakLoop = false  # cannot use 'break' to stop a 'while' loop in a branch statement. CC?
		while not breakLoop
			decl = nil
			branch .peek().which
				on 'PASS'
					.classPass()
					breakLoop = true
				on 'DEDENT': breakLoop = true
				on 'DEF': .declareMethod()
				on 'EOL': .oneOrMore('EOL')
				else
					_error('Got [.peek()] when expecting var, def, pro, get, set, enum or shared')
			if decl!
				theClass.addDecl(decl to Node)  # CC: axe typecast when if gets smart about not nil
		.dedent()

	def classPass
		if .curBox.declsInOrder
			_warning('Encountered "pass" in a class that already has declared members.')  # TODO: change to an error
		.grab()
		.oneOrMore('EOL')

	def declareMethod as Method
		token = .expect('DEF')
		opener = .grab()
		if opener.which not in ['ID', 'OPEN_CALL']
			_error('Encountered [opener.which] when expecting an identifier.')
		name = opener.value to String
		curClass = .curBox
		if name==curClass.name or Utils.capped(name)==curClass.name
			_error('Method names cannot be the same as their enclosing [curClass.specificName]. Use `def construct` for creating a constructor or choose another name.')  # TODO list the enclosing types location
# TODO
#		overload = nil
#		other = curClass.symbolForName(name, true)
#		if other
#			if name=='destruct'
#				.error('Cannot define more than one destruct method.')  # TODO give reference to the other one
#			if inherits(other, MemberOverload)
#				overload = other
#			else if inherits(other, DefOneCodeBlockMember)
#				overload = MemberOverload(token, other)
#				curClass.registerOverload(overload)
#			else
#				.error('There is already another class member with the name "%s".' % name)  # TODO list its location and possibly what it is
#		else
#			other = curClass.symbolForNameCI(name, true)
#			if other
#				.error('There is already another class member with the name "%s". You must differentiate member names by more than just case.' % other.name)
#			if name[0] in .uppercaseLetters
#				.error('%s names must start with lowercase letters. (%s)' % ('Method', name))

#		if opener.which=='OPEN_CALL'
#			params = .paramDecls(skipParen=true)
#		else
#			params = []
		paramsList = List<of Param>()

#		if .optional('AS')
#			returnType = .type()
#		else
#			returnType = tvoid
#		assert returnType

		if curClass inherits Class
			isNames = .indentIsDeclNames()
#			implements = .optional('IMPLEMENTS') and .type() or nil
#			if implements
#				.oneOrMore('EOL')
#			docString = .docString()
			docString = ''

#			assert returnType
#			if name=='construct'
#				if returnType is not tvoid
#					.error('Cannot declare a return type for construct.')
#				defMethod = DefConstruct(token, .curBox, params, isNames, docString)
#			else if name=='destruct'
#				if returnType is not tvoid
#					.error('Cannot declare a return type for destruct.')
#				if params
#					.error('Cannot declare parameters for destruct.')
#				if 'shared' in isNames
#					.error('Cannot declare a shared destructor.')
#				defMethod = DefDestruct(token, .curBox, isNames, docString)
#			else
#				if name=='constructor'
#					.warning('Did you mean to say `construct`?')
#				else if name=='destructor'
#					.warning('Did you mean to say `destruct`?')
			returnType = CobraType()
			implementsList = List<of Node>()
			if true
				method = Method(token, .curBox, name, paramsList, returnType, isNames, implementsList, docString)
			.statementsFor(method)
		else if curClass inherits Interface
			if .optionalIndent()
				isNames = .isDeclNames()
#				docString = .docString()
				docString = ''
				.dedent()
			else
				isNames = List<of String>()
				docString = ''
			implementsList = List<of Node>()
			if name=='construct'
				_error('Cannot declare "construct" in an interface.')
			else if name=='destruct'
				_error('Cannot declare "destruct" in an interface.')
			else
				method = Method(token, .curBox, name, paramsList, returnType, isNames, implementsList, docString)
		else
			throw Exception('Unhandled containing type [curClass]')
		assert method
#		if overload
#			overload.addMember(defMethod)
		return method

	def statementsFor(codePart as ICodePart)
		.statementsFor(codePart, nil)

	def statementsFor(codePart as ICodePart, codePartContainingTest as ICodePart)
		"""
		Example source
			<any statement 1>
			<any statement 2>
			<any statement N>
		Example source
			test
				<any statement 1>
				<any statement 2>
				<any statement N>
			code
				<any statement 1>
				<any statement 2>
				<any statement N>
		Returns
			Nothing.
		Errors
			Already encountered "code" block.
			Already encountered "test" block.
		"""
		_pushCodePart(codePart)
		if codePartContainingTest is nil
			codePartContainingTest = codePart
		try
			if .peek().which in ['CODE', 'TEST', 'REQUIRE', 'ENSURE']
				# sectional
				# not flexible. sequence is signature, contract, test, implementation
				_isContractOnSameLine = false
#				if .peek().which=='REQUIRE'
#					.require(codePart)
#				if .peek().which=='ENSURE'
#					.ensure(codePart)
#				if .peek().which=='TEST'
#					.testSection(codePartContainingTest)
#				if .peek().which=='CODE'
#					.grab()
#					codePart.setBlock(.block())
#				else
				if true
					if _isContractOnSameLine
						_statementsFor(codePart)
					else
						_error('Expecting `code` section.')
				if not _isContractOnSameLine
					.dedent()
			else
				# non-sectional
				_statementsFor(codePart)
		finally
			_curCodePart = nil

	def _statementsFor(codePart as ICodePart)
		"""
		Utility method for .statementsFor.
		"""
		while .peek().which<>'DEDENT'
			stmt = .stmt()
			if stmt is not nil
				codePart.addStmt(stmt to Stmt)  # CC: axe "to Stmt"
		.dedent()

	def stmt as Stmt?
		return nil


	#
	## Protected self utility
	#

	def _error(msg as String)
		if _whenError==WhenErrorEnum.exit
			token = .last
			if token
				print '[token.fileName]([token.lineNum],[token.colNum]): error: [msg]'
			else
				print '[token.fileName](1, 1): error: [msg]'
			if _verbosity>=1
				print 'Last tokens:'
				# TODO
			if _verbosity<2
				Environment.exit(1)
				# otherwise raise an exception in order to be more verbose
		throw ParserException(.last, msg)

	def _warning(msg as String)
		assert false, 'to do'

	def _pushCodePart(codePart as ICodePart)
		_codeParts.push(codePart)
		_curCodePart = codePart

	def _popCodePart
		require _codeParts
		_codeParts.pop()
		# CC: _curCodePart = if(_codeParts, _codeParts.peek(), nil)
		if _codeParts
			_curCodePart = _codeParts.peek() to ICodePart  # CC: axe "to ICodePart"
		else
			_curCodePart = nil


class UseDirective
	inherits Node

	def construct(obj as Object?, nameParts as List<of String>)
		pass


class Box
	inherits NamedNode
	"""
	The abstract base class for:
		* Class
		* Interface
		* Struct
	These are collectively known as "boxes".
	"""

	var _declsInOrder as List<of Node>  # TODO: can the inner list type be narrowed more? say to IClassMemberDecl or ClassMemberDecl

	def construct(name as String)
		base.construct(name)

	get declsInOrder from var

	def addDecl(decl as Node)
		_declsInOrder.add(decl)

	get specificName as String
		"""
		Return the specific name of this type of box: class, interface, struct.
		"""
		return ''


class Class
	inherits Box

	def construct(name as String, paramList as List<of Node>, isNames as List<of String>, baseName as String?, interfaceNames as List<of String>, docString as String?)
		base.construct(name)

	get specificName as String is override
		return 'class'


class Interface
	inherits Box

	def construct(name as String, paramList as List<of Node>, isNames as List<of String>, baseName as String?, interfaceNames as List<of String>, docString as String?)
		base.construct(name)

	get specificName as String is override
		return 'interface'


class ClassMember
	inherits NamedNode

	var _box as Box

	def construct(box as Box, name as String)
		base.construct(name)
		_box = box



interface ICodePart
	"""
	The common interface to:
		- methods
		- inits (special methods)
		- property getter
		- property setter
		- nested method
		- anonymous method
	"""

	def addStmt(stmt as Stmt)



class Method
	inherits ClassMember
	implements ICodePart

	var _params as List<of Param>
	var _returnTypeNode as Node
	var _isNames as List<of String>
	var _implementsList as List<of Node>
	var _docString as String
	var _stmts as List<of Stmt>

	def construct(token as IToken, box as Box, name as String, paramsList as List<of Param>, returnTypeNode as Node, isNames as List<of String>, implementsList as List<of Node>, docString as String)
		base.construct(box, name)
		_params = paramsList
		_returnTypeNode = returnTypeNode
		_isNames = isNames
		_implementsList = implementsList
		_docString = docString

	def addStmt(stmt as Stmt)
		_stmts.add(stmt)


class Param
	inherits NamedNode

	def construct(name as String)
		base.construct(name)


class Stmt
	inherits Node

	def construct(token as IToken)
		base.construct()
		pass
