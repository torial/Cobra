"""
The Cobra Parser
"""


class ParserException
	inherits CobraException

	var _token as IToken

	def construct(token as IToken, msg as String)
		base.construct(msg)
		_token = token


class Parser
	"""
	Notes:

		* The tokenizer's verbosity is set to 4 less than the parser's. In other words, the
		  tokenizer will not print messages unless the parser's verbosity is 5 or greater.

	"""

	test
		p = Parser()
		p.globalNS = NameSpace(Token.empty, '(global)')
		p.typeProvider = BasicTypeProvider()
		module = p.parseSource('test1', 'class Test\n\tpass\n')
		assert module
		decls = module.declsInOrder
		decl = decls[decls.count-1]
		if decl inherits Class
			assert decl.name == 'Test'
		else
			assert false, decl

		p = Parser()
		p.globalNS = NameSpace(Token.empty, '(global)')
		p.typeProvider = BasicTypeProvider()
		p.parseSource('test2', 'class Test\n\tdef main is shared\n\t\treturn\n')

	enum WhenErrorEnum
		exit
		throww

	enum WhenWarningEnum
		emit
		throww

	var _whenError as WhenErrorEnum

	var _lowercaseLetters = 'abcdefghijklmnopqrstuvwxyz'
	var _uppercaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

	var _fileName as String?
	var _willShowTokens = false
	var _verbosity = 0

	var _tokens as List<of IToken>?
	var _nextTokenIndex as int

	var _isNamesStack as Stack<of String>?
	var _boxStack as Stack<of Box>?

	var _globalNS as NameSpace
	var _nameSpaceStack as Stack<of NameSpace>

	var _codeParts as Stack<of ICodePart>
	var _curCodePart as ICodePart?

	var _isContractOnSameLine as bool

	var _leftStack as Stack<of Expr>
	var _opStackStack as Stack<of Stack<of String> >  # CC: should be able to say >> at the end instead of > >
		"""
		Used by expression parts so the last operator can be examined.
		A stack of stacks is needed for CallExpr's args.
		"""

	var _typeProvider as ITypeProvider

	def construct
		_boxStack = Stack<of Box>()
		_nameSpaceStack = Stack<of NameSpace>()
		_codeParts = Stack<of ICodePart>()

	pro verbosity from var

	pro whenError from var

	pro typeProvider from var

	pro globalNS as NameSpace
		get
			return _globalNS
		set
			require _globalNS is nil
			_globalNS = value
			_nameSpaceStack.push(_globalNS)

	get curBox as Box
		# yes there is only one box at the moment, but when nested classes and structs are supported there could by many.
		return _boxStack.peek() to Box  # CC: axe typecast

	def parseFileNamed(fileName as String) as Module
		require .typeProvider
		_fileName = fileName
		source = File.readAllText(_fileName to String)  # CC: axe "to String" when "if" gets smart about non-nil
		return .parseSource(fileName, source)

	def parseSource(source as String) as Module
		require .typeProvider
		return .parseSource('(no file name)', source)

	def parseSource(fileName as String, source as String) as Module
		"""
		Parses module source code and returns resulting module.
		"""
		.preParseSource(fileName, source)
		return .parseTokens()

	def preParseSource(fileName as String, source as String)
		"""
		Sets up for parsing, but does not invoke parseTokens().
		Used by parseSource() and various test sections.
		"""
		_fileName = fileName
		tokVerbosity = _verbosity - 4  # in order words, tokenizer does not spew unless our verbosity is 5 or greater
		if tokVerbosity<0
			tokVerbosity = 0

		_isNamesStack = Stack<of String>()  # for `shared` for example
		_leftStack = Stack<of Expr>()
		_opStackStack = Stack<of Stack<of String> >()
		.newOpStack()

		_tokens = nil
		try
			_tokens = CobraTokenizer(tokVerbosity).startSource(_fileName, source).allTokens()
		catch te as TokenizerError
			print '<> Caught TokenizerError'
			print te
			assert false
		_nextTokenIndex = 0


	##
	## Tokens
	##

	def grab as IToken?
		"""
		Returns the next token or nil if there are none left.
		"""
		if _nextTokenIndex >= _tokens.count
			return nil
		token = _tokens[_nextTokenIndex]
		_nextTokenIndex += 1
		if _willShowTokens
			print 'grab    --> [token]'
		return token

	def undo
		"""
		Undoes the last token() call. Often called "push" in parser examples.
		"""
		require _nextTokenIndex>0
		_nextTokenIndex -= 1
		if _willShowTokens
			print 'undo'

	def peek as IToken?
		return .peek(0)

	def peek(offset as int) as IToken?
		"""
		Returns a token without changing the current token, or nil if none left.
		With no offset, returns the current token, otherwise peeks ahead.
		"""
		i = _nextTokenIndex + offset
		if i < _tokens.count
			token = _tokens[i]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'peek([offset]) --> [token]'
		return token

	get last as IToken?
		"""
		Returns the last token returned by get() or nil if get() was never invoked.
		"""
		if _nextTokenIndex > 0
			token = _tokens[_nextTokenIndex-1]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'last    --> [token]'
		return token

	def lastN(n as int) as List<of NumberedToken>  # CC: use List<of Pair<of int, IToken>>
		"""
		Returns a list of NumberedTokens.
		"""
		test
			p = Parser()
			s = 'namespace class Foo def'
			p.preParseSource('(no filename)', s)
			p.grab()
			p.grab()
			p.grab()
			t = p.lastN(2)
			assert t[0].token.which=='CLASS', t
			assert t[1].token.which=='ID', t
			assert t.count==2, t
		code
			tokens = List<of NumberedToken>()
			if _nextTokenIndex > 0
				while true
					n -= 1
					if n == -1
						break
					i = _nextTokenIndex - n - 1
					if i >= 0 and i < _tokens.count
						tokens.add(NumberedToken(i, _tokens[i]))
			return tokens

	def expect(whatTypes as vari String) as IToken
		"""
		Gets a token and complains if its type does not match whatType(s).
		Returns the token.
		"""
		t = .grab()
		if _willShowTokens
			print 'expect([whatTypes]) --> [t]'
		if t is nil
			_error('Expecting [.join(" or ",whatTypes)], but source ended suddenly.')
		# CC: support "not in" on vari type
		#if t.which not in whatTypes
		#	_error('Expecting [whatTypes], but got [t] instead.')
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if not found
			_error('Expecting [.join(" or ",whatTypes)], but got [t] instead.')
		return t to IToken  # CC: to !

	def join(sep as String, stuff as vari String) as String
		# CC: have a join() method for vari, List, IEnumerable, array, etc.; use that and axe this helper method
		sb = StringBuilder()
		sep2 = ''
		for x in stuff
			sb.append(sep2)
			sb.append(x)
			sep2 = sep
		return sb.toString()

	def optional(whatTypes as vari String) as IToken?
		"""
		Gets a token, but only if it matches whatTypes.
		Does not complain or consume a token if there is no match.
		"""
		t = .peek()
		if _willShowTokens
			print 'optional([whatTypes]) --> [t]'
		if t is nil
			return nil
		# CC: support "in" on vari type
		#if t.which in whatTypes
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if found
			return .grab()
		else
			return nil

	def oneOrMore(which as String)
		"""
		Consumes the expected token and any other additional contiguous ones.
		Returns nothing.
		Example:  .oneOrMore('EOL')
		"""
		.expect(which)
		while .peek().which == which
			.grab()


	## Common parsing bits (docString, indent, dedent, ...)

	def docString as String?
		if .optional('DOC_STRING_START')
			textParts = List<of String>()
			keepGoing = true
			while keepGoing
				tok = .grab()
				branch tok.which
					on 'DOC_STRING_STOP'
						# TODO: check that indentation level is correct
						keepGoing = false
					on 'DOC_STRING_BODY_TEXT'
						textParts.add(tok.text)
					else
						_error('Expecting more doc string contents or the end of the doc string instead of [tok].')
			text = Utils.join('', textParts)
			return text
		else
			return ''

	def indent as IToken
		"""
		Consumes an option COLON (which generates a warning), 1 or more EOLs and an INDENT.
		Returns the INDENT.
		"""
		if .optional('COLON')
			_warning('Colons are not used to start indented blocks.')
		.expect('EOL')
		while .optional('EOL')
			pass
		return .expect('INDENT')

	def dedent
		while .optional('EOL')
			pass
		.expect('DEDENT')

	def indentIsDeclNames as List<of String>
		"""
		Parses indentation followed by "is" names, or "is" names followed by indentation.
		Example 1:
			def main is shared
				pass
		Example 2:
			def main
				is shared
				pass
		In either case, returns the list of "is" names or nil if there were none.
		"""
		if .peek().which=='IS'
			isNames = .isDeclNames()
			.expect('INDENT')
			return isNames
		else
			if .optionalIndent()
				return .isDeclNames()
			else
				return List<of String>()

	def optionalIndent as IToken?
		if .optional('COLON')
			_warning('Colons are not used to start indented blocks.')
		.oneOrMore('EOL')
		return .optional('INDENT')


	##
	## Parsing
	##

	var _module as Module

	def parseTokens as Module
		"""
		Parses and then returns an instance of Module.
		"""
		require
			.globalNS
		code
			docString = .docString()
			_module = CobraModule(_fileName, _verbosity, docString)  # TODO: does module really need verbosity?
			if not _fileName.endsWith('SystemInterfaces.cobra')
				# TODO: make an "implicit" token
				useToken = Token(_fileName, 1, 1, 1, 'USE', 'use', nil)
				# default use directives
				_module.addDecl(UseDirective(useToken, nil, ['System']))
#				_module.addDecl(UseDirective(useToken, nil, ['System', 'Collections', 'Generic']))
#				_module.addDecl(UseDirective(useToken, nil, ['System', 'IO']))
#				_module.addDecl(UseDirective(useToken, nil, ['System', 'Text']))
#				_module.addDecl(UseDirective(useToken, nil, ['Cobra', 'Lang']))
			what as IMember?
			keepParsing = true
			while keepParsing
				what = nil
				addToNS = true
				tok = .peek()
				if tok is nil
					break
				branch tok.which
					on 'STOPSTOP':	keepParsing = false
					on 'USE':       what = .useDirective()
					on 'IMPORT':    what = .importDirective()
					on 'CLASS':     what = .classDecl()
					on 'INTERFACE': what = .interfaceDecl()
					on 'STRUCT':    what = .structDecl()
					on 'ENUM':      what = .enumDecl()
					on 'EOL':       .grab()
					on 'NAMESPACE'
						what = .nameSpaceDecl()
						addToNS = false
					else
						_error('Expecting use, import, namespace, class, interface or enum, but got [tok]')
						break
				if what
					_module.addDecl(what to IMember)  # CC: axe typecast
					if addToNS
						_globalNS.addDecl(what to IMember)  # CC: axe "to NamedNode"

			return _module

	def useDirective as IMember
		assert false
		return nil to passthrough

	def importDirective as IMember
		assert false
		return nil to passthrough

	def classDecl as Class
		token = .expect('CLASS')
		peek = .peek().which
		if peek == 'ID'
			token = .expect('ID')
			name = token.value to String
		else if peek == 'OPEN_GENERIC'
			token = .expect('OPEN_GENERIC')
			name = token.value to String
		else
			_error('Expecting a class name.')
		if name[0] not in _uppercaseLetters
			_error('Class names must start with an uppercase letter in order to avoid collisions with other identifiers such as arguments and local variables.')

		# CC: rename paramsList to params (can't do it now because it's a C# reserved word and Cobra needs to generate IL or 'escape' these)
		paramsList = List<of INode>()  # TODO: change type to GenericParam
		if token.which=='OPEN_GENERIC'
			assert false, 'TODO: Generics'
#			expectComma = false
#			while 1
#				if .peek().which=='GT'
#					.grab()
#					break
#				if expectComma
#					.expect('COMMA')
#				ident = .expect('ID').value
#				paramsList.append(GenericParam(ident))
#				expectComma = true

		.indent()

		isNames = .isDeclNames()

		while .optional('WHERE')
			assert false, 'TODO: where clause'
#			if token.which<>'OPEN_GENERIC'
#				_error('Unexpected where clause for non-generic class.')
#			paramName = .expect('ID').value
#			found = false
#			for param in params
#				if param.name==paramName
#					found = true
#					break
#			if not found
#				_error('Unknown generic parameter "%s".' % name)
#			if param.constraints
#				_error('Already specified constraints for "%s".' % name)
#			.expect('MUST')
#			.expect('BE')
#			expectComma = false
#			while 1
#				if expectComma
#					.expect('COMMA')
#				param.constraints.append(.genericConstraint())
#				if .optional('EOL')
#					break
#				expectComma = true

		baseName as String?
		if .optional('INHERITS')
			baseName = .expect('ID').text
			.expect('EOL')
		else
			baseName = nil

		interfaceNames = List<of String>()
		if .optional('IMPLEMENTS')
			assert false, 'TODO: implements for classes'
#			expectComma = false
#			while 1
#				if .peek().which=='EOL'
#					.grab()
#					break
#				if expectComma
#					.expect('COMMA')
#				interfaceName = .type()  # using .type since interface could be a generic like IEnumerable(of T)
#				interfaceNames.append(interfaceName)
#				expectComma = true
		interfaceNames = List<of String>()  # TODO: axe

		docString = .docString()

		theClass = Class(token, name, paramsList, isNames, baseName, interfaceNames, docString)

		# TODO when supporting nested classes, look at the clintDeclStack and set a back pointer here
		_boxStack.push(theClass)
#		.isNamesStack = Stack(str)
		.bodiedBoxMemberDecls(theClass)
		_boxStack.pop()

		return theClass



	var _validIsNames as List<of String>?

	def isDeclNames as List<of String>
		"""
		Example source:
			# The | below is not literal--it's where this method starts parsing.
			def Compute()
				|is virtual, protected
		Example return values:
			[]
			['shared']
			['private', 'shared']
		Errors:
			TODO
		Used by: classDecl, interfaceDecl, enumDecl, indentIsDeclNames
		"""
		if _validIsNames is nil
			_validIsNames = ['fake', 'shared', 'virtual', 'nonvirtual', 'override', 'public', 'protected', 'private', 'internal']
		names = List<of String>()
		if _isNamesStack
			names.add(_isNamesStack.peek())
#		CC: use this instead of above 3 lines: names = if(_isNamesStack, [_isNamesStack.peek()], List<of String>())
		isWord = .optional('IS')
		if isWord is nil
			return names
		while true
			what = .grab().text
			if what in _validIsNames
				names.add(what)
			else
				_error('Not expecting "[what]".')
			comma = .optional('COMMA')
			if comma is nil
				break
		.oneOrMore('EOL')
		# TODO: error on virtual and override
		# TODO: error on virtual and shared
		# TODO: error if 2 or more of 'public', 'protected', 'private', 'internal'
		return names

	def interfaceDecl as Interface
		assert false, 'TO DO'
		return nil to passthrough

	def structDecl as Struct
		token = .expect('STRUCT')
		peek = .peek().which
		if peek == 'ID'
			token = .expect('ID')
			name = token.value to String
		else if peek == 'OPEN_GENERIC'
			token = .expect('OPEN_GENERIC')
			name = token.value to String
		else
			_error('Expecting a class name.')
		if name[0] not in _uppercaseLetters
			_error('Struct names must start with an uppercase letter in order to avoid collisions with other identifiers such as arguments and local variables.')

		# CC: rename paramsList to params (can't do it now because it's a C# reserved word and Cobra needs to generate IL or 'escape' these)
		paramsList = List<of INode>()  # TODO: change to GenericParam
		if token.which=='OPEN_GENERIC'
			assert false, 'TODO: generics for structs'
#			expectComma = false
#			while 1
#				if .peek().which=='GT'
#					.grab()
#					break
#				if expectComma
#					.expect('COMMA')
#				ident = .expect('ID').value
#				paramsList.append(GenericParam(ident))
#				expectComma = true

		.indent()

		isNames = .isDeclNames()

		while .optional('WHERE')
			assert false, 'TODO: where clause for structs'
#			if token.which<>'OPEN_GENERIC'
#				_error('Unexpected where clause for non-generic class.')
#			paramName = .expect('ID').value
#			found = false
#			for param in params
#				if param.name==paramName
#					found = true
#					break
#			if not found
#				_error('Unknown generic parameter "%s".' % name)
#			if param.constraints
#				_error('Already specified constraints for "%s".' % name)
#			.expect('MUST')
#			.expect('BE')
#			expectComma = false
#			while 1
#				if expectComma
#					.expect('COMMA')
#				param.constraints.append(.genericConstraint())
#				if .optional('EOL')
#					break
#				expectComma = true

		baseName as String?
		if .optional('INHERITS')
			_error('Structs cannot inherit. If you mean to implement an interface, use "implements" instead.')

		interfaceNames = List<of String>()
		if .optional('IMPLEMENTS')
			assert false, 'TODO: implements for structs'
#			expectComma = false
#			while 1
#				if .peek().which=='EOL'
#					.grab()
#					break
#				if expectComma
#					.expect('COMMA')
#				interfaceName = .type()  # using .type since interface could be a generic like IEnumerable(of T)
#				interfaceNames.append(interfaceName)
#				expectComma = true

		docString = .docString()

		theStruct = Struct(token, name, paramsList, isNames, baseName, interfaceNames, docString)

		# TODO when supporting nested classes, look at the clintDeclStack and set a back pointer here
		_boxStack.push(theStruct)
#		.isNamesStack = Stack(str)
		.bodiedBoxMemberDecls(theStruct)
		_boxStack.pop()

		return theStruct

	def enumDecl as EnumDecl
		token = .expect('ENUM')
		name = .expect('ID').value to String
		if name[0] not in _uppercaseLetters
			_error('Enum types must start with uppercase letters to avoid collisions with other identifiers such as properties and methods.')
		.indent()
		isNames = .isDeclNames()
		if .peek().which=='OF'
			possibleStorageType = .type()
			if possibleStorageType is .typeProvider.intType  # TODO: allow any integral type except char
				storageType as IType? = possibleStorageType to IType  # CC: axe "as IType?" and change "to IType?"
		docString = .docString()
		enumMembers = List<of EnumMember>()
		while .peek().which<>'DEDENT'
			enumNameToken = .expect('ID')
			if .peek().which=='ASSIGN'
				.grab()
				enumValue as int? = .expect('INTEGER_LIT').value to int  # CC: change cast to "to int?" and axe "as int?"
			else
				enumValue = nil
			.oneOrMore('EOL')
			enumMembers.add(EnumMember(enumNameToken, enumValue))
			# TODO: check for repeated names
			# TODO: check for values that repeat or go backwards
		.dedent()
		if not enumMembers
			_error('Missing enum members.')
		return EnumDecl(token, name, isNames, storageType, docString, enumMembers)

	def nameSpaceDecl as NameSpace
		require _nameSpaceStack
		.expect('NAMESPACE')
		curNameSpace = _nameSpaceStack.peek() to NameSpace  # CC: remove "as INode"
		tok = .expect('ID')
		name = tok.value to String  # CC: .value should probably be dynamic
		curNameSpace = curNameSpace.getOrMakeNameSpaceNamed(tok, name)
		_nameSpaceStack.push(curNameSpace)
		.indent()
		while true
			peek = .peek()
			if peek is nil
				_error('expecting a namespace member, but source code ended')
			tok = peek to IToken  # CC: to !
			if tok.which=='DEDENT'
				break
			branch tok.which
				on 'CLASS':  curNameSpace.addDecl(.classDecl())
				on 'INTERFACE': curNameSpace.addDecl(.interfaceDecl())
				on 'STRUCT': curNameSpace.addDecl(.structDecl())
				on 'USE': curNameSpace.addDecl(.useDirective())
				on 'NAMESPACE': .nameSpaceDecl()
				else: _error('expecting a namespace member but got [tok]')
		.dedent()
		_nameSpaceStack.pop()
		return curNameSpace

	def bodiedBoxMemberDecls(box as Box)
		require
			not box inherits Interface
		code
			decl as INode?
			breakLoop = false  # cannot use 'break' to stop a 'while' loop in a branch statement. CC?
			while not breakLoop
				decl = nil
				branch .peek().which
					on 'PASS'
						.classPass()
						breakLoop = true
					on 'DEDENT': breakLoop = true
					on 'DEF': box.addDecl(.declareMethod())
					on 'GET': box.addDecl(.declarePropertyGet())
					on 'SET': box.addDecl(.declarePropertySet())
					on 'PRO': box.addDecl(.declareProperty())
					on 'VAR': box.addDecl(.classVarDecl())
					on 'EOL': .oneOrMore('EOL')
					on 'ENUM': box.addDecl(.enumDecl())
					on 'SHARED': .bodiedBoxMemberDeclsShared(box)
					else
						_error('Got [.peek()] when expecting var, def, pro, get, set, enum or shared')
				if decl!
					box.addDecl(decl to IMember)  # CC: axe typecast when if gets smart about not nil
			.dedent()

	def bodiedBoxMemberDeclsShared(box as Box)
		.expect('SHARED')
		.indent()
		_isNamesStack.push('shared')
		try
			.bodiedBoxMemberDecls(box)
		finally
			_isNamesStack.pop()

	def classPass
		if .curBox.declsInOrder
			_warning('Encountered "pass" in a class that already has declared members.')  # TODO: change to an error
		.grab()
		.oneOrMore('EOL')

	def classVarDecl as ClassVar
		.expect('VAR')
		tok = .expect('ID')
		identifier = tok.text
		other = .curBox.symbolForName(identifier, true, true)  # TODO: should probably really be symbolForName() even after the current symbolForName() becomes findSymbol() or findMember()
		if other
			# TODO need a test case to trigger this
			# TODO: this seems a little fishy as the type may be legit, but not resolved yet due to a forward reference.
			# The error message should not show '(no type)' or this check should be moved to bindInt
			reportType = if(other.resultType, other.resultType.name, '(no type)')
			_error('The name "[identifier]" was already declared earlier as a "reportType".')
		if identifier[0]<>'_'
			sugg = '_' + identifier
			_error('Class variables must start with an underscore to distinguish them from other types of identifiers. Try "[sugg]".')
		numUnderscores = 1
		s = identifier.substring(1)
		while s.startsWith('_')
			s = s.substring(1)
			numUnderscores += 1
		if not s
			_error('A class variable must be made of more than underscores. Try "[identifier]x" or "[identifier]1".')
		if s[0] not in _lowercaseLetters
			if s[0] in _uppercaseLetters
				sugg = String(c'_', numUnderscores) + s[0].toString().toLower() + s.substring(1)
				sugg = ' Try "[sugg]".'
			_error('Class variables must start with lowercase letters (after the underscore(s)) to distinguish them from other types of identifiers.[sugg]')
		type = if(.optional('AS'), .type(), nil)
		if .optional('ASSIGN')
			initExpr as Expr? = .expression()  # CC: initExpr = .expression() to ?
		else
			initExpr = nil
			if type is nil
				type = .typeProvider.dynamicType
		docString as String? = ''  # CC: change to: docString = '' to ?
		isNames = List<of String>(_isNamesStack)
		if .peek().which=='IS'
			isNames = .isDeclNames()
			assert .last.which=='EOL'
			.undo()  # need the EOL
			if .optionalIndent()
				docString = .docString()
				.dedent()
		else
			if .optionalIndent()
				isNames = .isDeclNames()
				docString = .docString()
				.dedent()
		assert isNames is not nil
		return ClassVar(tok, .curBox, identifier, type, isNames, initExpr, docString)

	def declareMethod as Method
		require _typeProvider
		token = .expect('DEF')
		opener = .grab()
		if opener.which not in ['ID', 'OPEN_CALL']
			_error('Encountered [opener.which] when expecting an identifier.')
		name = opener.value to String
		curClass = .curBox
		if name==curClass.name or Utils.capped(name)==curClass.name
			_error('Method names cannot be the same as their enclosing [curClass.englishName]. Use `def construct` for creating a constructor or choose another name.')  # TODO list the enclosing types location
# TODO
#		overload = nil
#		other = curClass.symbolForName(name, true)
#		if other
#			if name=='destruct'
#				.error('Cannot define more than one destruct method.')  # TODO give reference to the other one
#			if inherits(other, MemberOverload)
#				overload = other
#			else if inherits(other, DefOneCodeBlockMember)
#				overload = MemberOverload(token, other)
#				curClass.registerOverload(overload)
#			else
#				.error('There is already another class member with the name "%s".' % name)  # TODO list its location and possibly what it is
#		else
#			other = curClass.symbolForNameCI(name, true)
#			if other
#				.error('There is already another class member with the name "%s". You must differentiate member names by more than just case.' % other.name)
#			if name[0] in .uppercaseLetters
#				.error('%s names must start with lowercase letters. (%s)' % ('Method', name))

		if opener.which=='OPEN_CALL'
			paramsList = .paramDecls(true)
		else
			paramsList = List<of Param>()

		if .optional('AS')
			returnType = .type()
		else
			returnType = _typeProvider.voidType
		assert returnType

		if curClass inherits Class or curClass inherits Struct
			isNames = .indentIsDeclNames()
#			implements = .optional('IMPLEMENTS') and .type() or nil
#			if implements
#				.oneOrMore('EOL')
#			docString = .docString()
			docString = ''

#			assert returnType
#			if name=='construct'
#				if returnType is not tvoid
#					.error('Cannot declare a return type for construct.')
#				defMethod = DefConstruct(token, .curBox, paramsList, isNames, docString)
#			else if name=='destruct'
#				if returnType is not tvoid
#					.error('Cannot declare a return type for destruct.')
#				if paramsList
#					.error('Cannot declare parameters for destruct.')
#				if 'shared' in isNames
#					.error('Cannot declare a shared destructor.')
#				defMethod = DefDestruct(token, .curBox, isNames, docString)
#			else
#				if name=='constructor'
#					.warning('Did you mean to say `construct`?')
#				else if name=='destructor'
#					.warning('Did you mean to say `destruct`?')
			implementsList = List<of INode>()
			if true
				method = Method(token, .curBox, name, paramsList, returnType, isNames, implementsList, docString)
			.statementsFor(method)
		else if curClass inherits Interface
			if .optionalIndent()
				isNames = .isDeclNames()
#				docString = .docString()
				docString = ''
				.dedent()
			else
				isNames = List<of String>()
				docString = ''
			implementsList = List<of INode>()
			if name=='construct'
				_error('Cannot declare "construct" in an interface.')
			else if name=='destruct'
				_error('Cannot declare "destruct" in an interface.')
			else
				method = Method(token, .curBox, name, paramsList, returnType, isNames, implementsList, docString)
		else
			throw Exception('Unhandled containing type [curClass]')
		assert method
#		if overload
#			overload.addMember(defMethod)
		return method

	def declareProperty as Property
		"""
		Example source
			pro age as int
				get
					return _age
				set
					assert value>0
					_age = value
		"""
		token = .expect('PRO')
		overload as MemberOverload? = nil  # CC: axe "as MemberOverload" when Cobra gets smarter about type inference of "x = nil"
		if .optional('LBRACKET')
			paramsList = .paramDecls(true, 'RBRACKET')
			name = r'[]'
			other = .curBox.declForName(name)
			if other
				if other inherits MemberOverload
					overload = other
				else if other inherits Property
					overload = MemberOverload(.curBox, other)
					.curBox.registerOverload(overload to MemberOverload)  # CC: axe typecast
		else
			name = .expect('ID').text
			.checkProperty(name)
			if .optional('FROM')
				return .declarePropertyFrom(token, name, 'getset')
			paramsList = List<of Param>()
		if .optional('AS')
			returnType = .type()
		else
			returnType = _typeProvider.dynamicType
		assert returnType
		if .curBox inherits Class
			isNames = .indentIsDeclNames()
			docString = .docString()
			if paramsList
				assert false, 'TODO: implement indexers'
			prop = Property(token, .curBox, name, returnType, isNames, docString)

# TODO:
#			if .peek().which=='TEST'
#				.testSection(defProperty)

			getWord = .optional('GET')
			if getWord
				.indent()
				.statementsFor(prop.makeGetPart(getWord to IToken))  # CC: axe to IToken

			setWord = .optional('SET')
			if setWord
				.indent()
				.statementsFor(prop.makeSetPart(setWord to IToken))  # CC: axe to IToken

			.dedent()
# TODO
#		else if .curBox inherits Interface
#			if .optionalIndent
#				isNames = .isDeclNames()
#				docString = .docString()
#				.dedent()
#			else
#				isNames = List<of String>()
#				docString = nil
#			defProperty = Property(token, .curBox, name, paramsList, returnType, isNames, docString)
#			defProperty.makeGetPart(token)
#			defProperty.makeSetPart(token)
		else
			throw FallThroughException(.curBox)
		if overload
			overload.addMember(prop)
		return prop

	def declarePropertyFrom(token as IToken, name as String, coverWhat as String) as Property
		require coverWhat in ['get', 'set', 'getset']
		if .optional('VAR')
			varName = '_' + name
		else
			varName = .expect('ID').text
		possibleVarDef = .curBox.declForName(varName)
		if not possibleVarDef inherits ClassVar
#TODO			if _verbosity>=3
#				.curBox.dumpNames(sys.stdout)
			_error('A property can only cover for variables. [varName] is a [possibleVarDef]')
		varDef = possibleVarDef to ClassVar
		if .curBox inherits Interface
			_error('Cannot use the "from" form of a property inside an interface declaration.')
		if .optionalIndent()
			docString = .docString()
			.dedent()
		else
			docString = nil
		isNames = List<of String>()  # TODO: cover isNames
		return Property(token, .curBox, name, isNames, varDef, coverWhat, docString)

	def declarePropertyGet as Property
		"""
		Example source
			get meaningOfLife as int
				return 42
		"""
		token = .expect('GET')
		overload as MemberOverload? = nil
		if .optional('LBRACKET')
			paramsList = .paramDecls(true, 'RBRACKET')
			name = r'[]'
			other = .curBox.declForName(name)
			if other
				if other inherits MemberOverload
					overload = other
				else if other inherits Property
					overload = MemberOverload(.curBox, other)
					.curBox.registerOverload(overload to MemberOverload)  # CC: axe typecast
		else
			name = .expect('ID').text
			.checkProperty(name)
			if .optional('FROM')
				return .declarePropertyFrom(token, name, 'get')
			paramsList = List<of Param>()
		if .optional('AS')
			returnType = .type()
		else
			returnType = _typeProvider.dynamicType
		assert returnType!

		if .curBox inherits Class or .curBox inherits Struct
			isNames = .indentIsDeclNames()
			docString = .docString()
			prop = Property(token, .curBox, name, returnType, isNames, docString)
			.statementsFor(prop.makeGetPart(token), prop)
# TODO
#		else if .curBox inherits Interface
#			if .optionalIndent
#				isNames = .isDeclNames()
#				docString = .docString()
#				.dedent()
#			else
#				isNames = List<of String>()
#				docString = nil
#			prop = Property(token, .curBox, name, paramsList, returnType, isNames, docString)
#			prop.makeGetPart(token)
		else
			throw FallThroughException(.curBox)
		if overload
			overload.addMember(prop)
		return prop

	def declarePropertySet as Property
		"""
		Example source
			set foo as int
				_foo = value
		"""
		token = .expect('SET')
		name = .expect('ID').text
		.checkProperty(name)
		if .optional('FROM')
			return .declarePropertyFrom(token, name, 'set')
		if .optional('AS')
			returnType = .type()
			assert returnType
		else
			returnType = _typeProvider.dynamicType
		assert returnType

		if .curBox inherits Class
			isNames = .indentIsDeclNames()
			docString = .docString()
			defProperty = Property(token, .curBox, name, returnType, isNames, docString)
			.statementsFor(defProperty.makeSetPart(token), defProperty)
		else if .curBox inherits Interface
			if .optionalIndent()
				isNames = .isDeclNames()
				docString = .docString()
				.dedent()
			else
				isNames = List<of String>()
				docString = nil
			prop = Property(token, .curBox, name, returnType, isNames, docString)
			prop.makeSetPart(token)
		else
			throw FallThroughException(.curBox)

		return prop


	##
	## Parameter declarations
	##

	def paramDecls(skipParen as bool) as List<of Param>
		return .paramDecls(skipParen, 'RPAREN')

	def paramDecls(skipParen as bool, rightParen as String) as List<of Param>
		if not skipParen
			.expect('LPAREN')
		paramsList = List<of Param>()
		expectComma = false
		while true
			if .peek().which==rightParen
				.grab()
				break
			if expectComma
				.expect('COMMA')
			param = .paramDecl()
			paramsList.add(param)
			if paramsList.count==1 and param.name=='self' and param.type is _typeProvider.dynamicType
				_warning('The first parameter is "self" which may be a Python carry-over on your part. Cobra does not require that (and calls it "this" anyway).')
			expectComma = true
		return paramsList

	def paramDecl as Param
		return .paramDecl(_typeProvider.dynamicType)

	def paramDecl(defaultType as IType) as Param
		"""
		Example source:
			x as int
			x as int?
			x as vari object
			x   # default type is dynamic    # TODO: should be unspecified
		Arguments:
			theClass is typically ClassVarDecl, LocalVar or Param
			whatName could be set to 'Parameter' for example.
		Returns:
			A theClass(name, type)
		Errors:
			None
		"""
		token = .expect('ID')
		identifier = token.value to String
		.checkStartsLowercase(identifier, 'Parameter')
		type as INode?
		if .peek().which=='AS'
			.grab()
			varii = .optional('VARI')
			type = .type()
			if varii
				type = _typeProvider.variType(type)
		else
			type = nil
		if type inherits IType
			param = Param(token, type)
		else if type inherits INode
			param = Param(token, type)
		else
			throw FallThroughException(type)
		# print param
		return param


	##
	## Top Level Statement Entry
	##

	def statementsFor(codePart as ICodePart)
		.statementsFor(codePart, nil)

	def statementsFor(codePart as ICodePart, codePartContainingTest as ClassMember?)
		"""
		Example source
			<any statement 1>
			<any statement 2>
			<any statement N>
		Example source
			test
				<any statement 1>
				<any statement 2>
				<any statement N>
			code
				<any statement 1>
				<any statement 2>
				<any statement N>
		Returns
			Nothing.
		Errors
			Already encountered "code" block.
			Already encountered "test" block.
		"""
		_pushCodePart(codePart)
		if codePartContainingTest is nil
			codePartContainingTest = codePart to ClassMember  # TODO: figure out better typing for this assignement and the method sig of this method
		try
			if .peek().which in ['CODE', 'TEST', 'REQUIRE', 'ENSURE']
				# sectional
				# not flexible. sequence is signature, contract, test, implementation
				_isContractOnSameLine = false
#				if .peek().which=='REQUIRE'
#					.require(codePart)
#				if .peek().which=='ENSURE'
#					.ensure(codePart)
#				if .peek().which=='TEST'
#					.testSection(codePartContainingTest)
#				if .peek().which=='CODE'
#					.grab()
#					codePart.setBlock(.block())
#				else
				if true
					if _isContractOnSameLine
						_statementsFor(codePart)
					else
						_error('Expecting `code` section.')
				if not _isContractOnSameLine
					.dedent()
			else
				# non-sectional
				_statementsFor(codePart)
		finally
			_curCodePart = nil

	def _statementsFor(codePart as ICodePart)
		"""
		Utility method for .statementsFor.
		"""
		while .peek().which<>'DEDENT'
			stmt = .stmt()
			if stmt is not nil
				codePart.addStmt(stmt to Stmt)  # CC: axe "to Stmt"
		.dedent()

	def stmt as Stmt?
		token = .peek()
		which = token.which
		s as Stmt? # the statement (node)
		expectEOL = true
		branch token.which
			on 'ASSERT'
				s = .assertStmt()
			on 'BRANCH'
				s = .branchStmt()
				expectEOL = false
			on 'BREAK'
				s = .breakStmt()
			on 'CONTINUE'
				s = .continueStmt()
			on 'EXPECT'
				s = .expectStmt()
				expectEOL = false
			on 'FOR'
				s = .forStmt()
				expectEOL = false
#			on 'DEF'
#				s = .declareMethod()
			on 'IF'
				s = .ifStmt()
				expectEOL = false
			on 'GET'
				_error('Cannot use "get" for a statement. If you mistakenly started a property above with "def", "get" or "set", then use "pro" instead.')
			on 'PASS'
				s = .passStmt()
			on 'POST'
				s = .postWhileStmt()
				expectEOL = false
			on 'PRINT'
				s = .printStmt()
				expectEOL = false
			on 'RETURN'
				s = .returnStmt()
			on 'THROW'
				s = .throwStmt()
			on 'TRY'
				s = .tryStmt()
				expectEOL = false
			on 'USING'
				s = .usingStmt()
				expectEOL = false
			on 'WHILE'
				s = .whileStmt()
				expectEOL = false
			on 'EOL'
				.grab()  # ignore stray EOL (can especially come up at the end of a file)
				expectEOL = false
			else
				s = .expression()
				s.afterParserRecognizesStatement()
		if expectEOL
			if .verbosity>=5
				print '<> last statement start token=[token]'
				print '<> s = [s]'
			.expect('EOL')
		_finishSpaceAgnostic()
		return s


	##
	## Individual Statements
	##

	def assertStmt as Stmt
		token = .expect('ASSERT')
		expr = .expression()
		# CC: could the following 5 lines be: info = if(.optional('COMMA'), .expression(), nil)
		info as Expr?
		if .optional('COMMA')
			info = .expression()
		else
			info = nil
		return AssertStmt(token, expr, info)

	def branchStmt() as Stmt
		token = .expect('BRANCH')
		e = .expression()
		.indent()
		onParts = List<of BranchOnPart>()
		elsePart as BlockStmt? = nil  # CC: axe type decl
		continuee = true  # CC: axe this when 'break' can be used in a branch inside a loop
		while continuee
			branch .peek().which
				on 'ON'
					.grab()
					if elsePart
						_error('Cannot have "on" parts after an "else" part.')
					exprs = .commaSepExprs(['COLON', 'EOL'])
					.undo()
					block = .branchPartStatements()
					onParts.add(BranchOnPart(exprs, block))
				on 'ELSE'
					.grab()
					if elsePart
						_error('Cannot have more than one "else" in a branch.')
					if not onParts
						_error('Cannot have an "else" in a branch without at least one "on".')
					elsePart = .branchPartStatements()
				on 'DEDENT'
					.grab()
					continuee = false  # CC: axe this when we can use break in a branch
				else
					_error('Expecting "on", "else" or end of branch statement. Encountered [.peek().which]')
		return BranchStmt(token, e, onParts, elsePart)

	def branchPartStatements() as BlockStmt
		if .peek().which=='COLON'
			.grab()
			stmt = .stmt()
			if stmt is nil
				_error('Need a statement.')
			block = BlockStmt(stmt.token, [stmt])
		else
			block = .block()
		return block

	def breakStmt as Stmt
		return Stmt(.grab())

	def continueStmt as Stmt
		return Stmt(.grab())

	def expectStmt as Stmt
		return Stmt(.grab())

	def forStmt as Stmt
		"""
		numeric    for int x = 0 up to n step 2
		enumerable for Customer cust in customers
		"""
		token = .expect('FOR')
		varr = .localVarDecl()
		peek = .peek().which
		if peek=='ASSIGN'
			return .forNumericStmt(token, varr)
		else if peek=='IN'
			return .forEnumerableStmt(token, varr)
		else
			_error('Expecting "=" or "in".')
			return Stmt(Token.empty)  # make C# code flow analysis happy

	def forNumericStmt(token as IToken, varr as IVar) as ForNumericStmt
		.expect('ASSIGN')
		start = .expression()
		.expect('DOTDOT')
		stopp = .expression()
		dirToken = .optional('PLUSPLUS')
		if dirToken
			dir = 1
		else
			dirToken = .optional('MINUSMINUS')
			if dirToken
				dir = -1
		stepp as Expr?
		if dirToken is nil
			dir = 1
			stepp = nil
		else
			stepp = .expression()
		stmts = .block()
		return ForNumericStmt(token, varr, start, stopp, dir, stepp, stmts)

	def forEnumerableStmt(token as IToken, varr as IVar) as ForEnumerableStmt
		.expect('IN')
		what = .expression()
		stmts = .block()
		return ForEnumerableStmt(token, varr, what, stmts)

	def ifStmt as Stmt
		token = .expect('IF')
		cond = .expression()
		trueStmts = .block()
		falseStmts as BlockStmt?
		if .peek().which=='ELSE'
			.grab()
			peek = .peek().which
			if peek=='EOL'
				falseStmts = .block()
			else if peek=='IF'
				falseStmts = BlockStmt(.peek(), [.ifStmt()])
			else
				_error('Syntax error. Expecting end-of-line or "if" after an "else".')
		return IfStmt(token, cond, trueStmts, falseStmts)

	def passStmt as Stmt
		return Stmt(.grab())

	def postWhileStmt as Stmt
		token = .expect('POST')
		.expect('WHILE')
		return PostWhileStmt(token, .expression(), .block())

	def printStmt as Stmt
		"""
		Example source:
			print arg
			print a, b, c
			print to sw, a, b
			print to sw, a, b stop
			print a, b, c stop
			print to sw
				code
		"""
		destination as Expr?
		block as BlockStmt?
		token = .expect('PRINT')
		args = List<of Expr>()
		stopp = false
		if .optional('TO')
			destination = .expression()
			peek = .peek().which
			if peek=='COMMA'
				.grab()
			else if peek=='EOL'
				block = .block()
			else
				_error('Expecting a comma and print arguments, or a code block.')
		if not block
			args = .commaSepExprs(['EOL', 'STOP'])
			terminator = .last
			if terminator.which=='STOP'
				stopp = true
				.expect('EOL')
		if block
			return PrintRedirectStmt(token, destination, block)
		else
			return PrintStmt(token, destination, args, stopp)

	def returnStmt as Stmt
		token = .expect('RETURN')
		expr as Expr?  # axe this decl when Cobra looks at the second assignment in after "x = nil"
		if .peek().which=='EOL'
			expr = nil
		else
			expr = .expression()
		return ReturnStmt(token, expr)

	def throwStmt as Stmt
		token = .expect('THROW')
		expr as Expr?  # CC: axe
		if .peek().which=='EOL'
			expr = nil
		else
			expr = .expression()
		return ThrowStmt(token, expr)

	def tryStmt as Stmt
		# try... except... success... finally...
		token = .expect('TRY')
		tryBlock = .block()
		catchBlocks = List<of CatchBlock>()
		didParseCatchAnyBlock = false  # meaning the catch that specifies no specific type of exception
		useCatchMsg = 'Use "catch" instead of "except". (Also, use "throw" for throwing exceptions and "raise" for raising events.)'
		if .peek().which=='EXCEPT'
			_error(useCatchMsg)
		while .peek().which=='CATCH'
			catchToken = .grab()
			if .peek().which in ['COLON', 'EOL']
				if didParseCatchAnyBlock
					_error('Already encountered the "catch every exception" block.')
				anyCatchBlock = .block()
				catchBlocks.add(CatchBlock(catchToken, anyCatchBlock))
				didParseCatchAnyBlock = true
			else
				if didParseCatchAnyBlock
					_error('Cannot have a specific exception block after the "catch every exception" block.')
				varr = .localVarDecl()
				# TODO Accept type, or id, or "id AS type". See what Boo does.
				if false
					catchType as INode?
					if .peek().which<>'EOL'
						catchType = .type()
						if .peek().which=='ID'
							catchVarToken = .expect('ID')
							_curCodePart.addLocal(LocalVar(catchVarToken, catchType))
				catchBlock = .block()
				catchBlocks.add(CatchBlock(catchBlock.token, varr, catchBlock))
		if .peek().which=='EXCEPT'
			_error(useCatchMsg)
		if .peek().which=='ELSE'
			_error('There is no "else" for a "try". There is a "success" however.')
		successBlock as BlockStmt?  # CC: find a way to remove this decl. possibly by adding "to ?" below
		if .peek().which=='SUCCESS'
			.grab()
			successBlock = .block()
		else
			successBlock = nil
		finallyBlock as BlockStmt?  # CC: find a way to remove this decl.
		if .peek().which=='FINALLY'
			.grab()
			finallyBlock = .block()
		else
			finallyBlock = nil
		if not catchBlocks and not successBlock and not finallyBlock
			_error('A try needs at least one "except", "success" or "finally" block.')
		return TryStmt(token, tryBlock, catchBlocks, successBlock, finallyBlock)

	def usingStmt as Stmt
		# syntax: using x = e  block
		token = .expect('USING')
		varr = .localVarDecl(.typeProvider.passThroughType)
		.expect('ASSIGN')
		initExpr = .expression()
		block = .block()
		return UsingStmt(token, varr, initExpr, block)

	def whileStmt as Stmt
		return WhileStmt(.expect('WHILE'), .expression(), .block())


	##
	## Misc parts
	##

	def block as BlockStmt
		"""
		Used by if, while, print-to, etc.
		Consumes the (optional colon,) indent, statements and dedent.
		Returns a BlockStmt().
		"""
		token = .indent()
		stmts = List<of Stmt>()
		while true
			stmt = .stmt()
			if stmt is not nil
				stmts.add(stmt)
			if .peek().which=='DEDENT'
				break
		if not stmts
			_error('Missing statements in block. Add a real statement or a "pass".')
		.dedent()
		return BlockStmt(token, stmts)

	def localVarDecl as AbstractLocalVar
		return .localVarDecl(nil)

	def localVarDecl(defaultType as IType?) as AbstractLocalVar
		"""
		Variable declarations for parameters, `for` loops and exceptions.
		Not class vars (see classVarDecl()).
		Example source:
			x   # default type is dynamic   # TODO: should be unspecified
			i as int
			cust as Customer
		Arguments:
			theClass is typically ClassVarDecl, LocalVar or Param
			whatName could be set to 'Parameter' for example.
		Returns:
			A theClass(name, type)
		Errors:
			None
		"""
		token = .expect('ID')
		name = token.value to String
		.checkStartsLowercase(name, 'Variable')
		type as INode?
		if .peek().which=='AS'
			.grab()
			type = .type()
		else
			# maybe the var already exists?
			definition = _curCodePart.findLocal(name)
			if definition
				return definition to AbstractLocalVar  # CC: axe type cast
			type = nil

		type = (type ? defaultType) to INode
		assert type

		definition = _curCodePart.findLocal(name)

		# TODO: put this kind of check in bindImp maybe?
		if definition
			if definition.typeNode
				if definition.typeNode==type
					return definition to AbstractLocalVar  # same thing  # CC: axe type cast
				else
					# this should probably be moved to the bindImp phase since types can have different names like "int" and "System.Int32"
					_error('Cannot redeclare "[name]" from "[definition.typeNode]" to "[type]". Previous definition is on line [definition.token.lineNum].')
			else if definition.type
				if definition.type==type
					return definition to AbstractLocalVar  # same thing  # CC: axe type cast
				else
					# this should probably be moved to the bindImp phase since types can have different names like "int" and "System.Int32"
					_error('Cannot redeclare "[name]" from "[definition.type]" to "[type]". Previous definition is on line [definition.token.lineNum].')
			else
				throw FallThroughException(definition)

		# new def
		varr = LocalVar(token, type)
		_curCodePart.addLocal(varr)

		return varr

	##
	## Expressions
	##

	shared
		var _binaryOpPrec = {
			# CANNOT USE 0 AS A VALUE IN THIS DICTIONARY
			'DOT':				80,
			'LBRACKET':			80,
			'LPAREN':			80,

			'STARSTAR':			70,  # right associative

			'QUESTION':			68,
			'BANG':				68,

			'TO':				65,
			'TOQ':				65,

			'STAR':				60,
			'SLASH':			60,
			'SLASHSLASH':		60,
			'PERCENT':			60,

			'PLUS':				50,
			'MINUS':			50,

			'EQ':				40,
			'NE':				40,
			'LT':				40,
			'GT':				40,
			'LE':				40,
			'GE':				40,
			'IS':				40,
			'ISNOT':			40,
			'INHERITS':			40,
			'IMPLEMENTS':		40,

			'IN':				35,
			'NOTIN':			35,

			'AND':				30,
			'OR':				30,
			'IMPLIES':			20,

			'ASSIGN':			20,
			'PLUS_EQUALS':		20,
			'MINUS_EQUALS':		20,
			'STAR_EQUALS':		20,
			'SLASH_EQUALS':		20,
			'PERCENT_EQUALS':	20,
			'QUESTION_EQUALS':	20,
			'BANG_EQUALS':		20,
		}

		var _unaryOpPrec = {
			'MINUS': _binaryOpPrec['MINUS']+1,
			'NOT': _binaryOpPrec['AND']+1,
			'OLD': _binaryOpPrec['STARSTAR']+1,
		}

	def expression as Expr
		test
			# CC: neither of these work and both should

			#assert 0 not in _binaryOpPrec.values

			#for v in _binaryOpPrec.values
			#	assert v<>0

			pass

		code
			return .expression(0, nil)


	def expression(precedence as int) as Expr
		return .expression(precedence, nil)


	def expression(precedence as int, left as Expr?) as Expr
		if left is nil
			left = .expression2()
		while true
			peek = .peek().which
			# handle multi-word operators
			op as String? = nil
			if peek=='IS' and .peek(1).which=='NOT'  # CC: change to .peek(+1)
				# 'is not' is a 2 keyword operator
				op = 'ISNOT'
			else if peek=='NOT' and .peek(1).which=='IN'  # CC: change to .peek(+1)
				op = 'NOTIN'
			# handle precedence (and detect non-binary operators)
			binaryOpPrec = Utils.getSI(_binaryOpPrec, op ? peek, -1)
			if binaryOpPrec==-1 or binaryOpPrec<precedence
				break
			# continue...
			if peek=='LBRACKET'
				# requires special handling - IndexExpr
				token = .grab()
				exprs = .commaSepExprs('RBRACKET')
				return .expression(precedence, IndexExpr(token, left, exprs))
			else if peek=='LPAREN'
				# requires special handling - PostCallExpr
				token = .grab()
				exprs = .commaSepExprs('RPAREN')
				assert false, 'TODO'
#				return .expression(precedence, PostCallExpr(token, left, exprs))
			else
				# most operators are one-word affairs
				if op is nil
					opToken = .grab()
					op = opToken.which
				else
					# op was set earlier for a two word operator. ISNOT NOTIN
					opToken = .grab()
					.grab()
				# TODO: axe the following section
#				if op=='QUESTION'
					# ? can be a binary operator, or a unary postfix operator
#					if .peek().which in ['COMMA', 'EOL', 'RPAREN']
#						return IsNilExpr(opToken, left)
#					if _binaryOpPrec.containsKey(.peek().which) and .peek().which!<>'DOT'
#						# keep chugging
#						left = IsNilExpr(opToken, left)
#						opToken = .grab()
#						op = opToken.which
				if op=='BANG'
					if .peek().which in ['COMMA', 'EOL', 'RPAREN']
						return IsNotNilExpr(opToken, left)
					if _binaryOpPrec.containsKey(.peek().which) and .peek().which<>'DOT'
						# keep chugging
						left = IsNotNilExpr(opToken, left)
						opToken = .grab()
						op = opToken.which
			assert _binaryOpPrec.containsKey(op)
			_leftStack.push(left)
			.opStack.push(op)
			try
				prec = if(OperatorSpecs.rightAssoc().containsKey(op), binaryOpPrec, binaryOpPrec+1)
				right = .expression(prec)
#				if right inherits IdentifierExpr
#					if right.definition is UnknownId
#						_errorUnknownId(right.text)  # TODO this seems wrong since the name might not be available until later
				if .peek().which=='QUESTION'
					# ? unary postfix is higher precedence than any binary operator
					right = IsNilExpr(.grab(), right)
				else if .peek().which=='BANG'
					# ! unary postfix is higher precedence than any binary operator
					right = IsNotNilExpr(.grab(), right)
				left = BinaryOpExpr.make(opToken to IToken, op to String, left to Expr, right to Expr)  # CC: assert opToken up higher and remove cast
			finally
				.opStack.pop()
				_leftStack.pop()
#		if left inherits IdentifierExpr and left.definition is UnknownId
#			.errorUnknownId(left.text)  # TODO this seems wrong since the name might not be available until later
		assert left
		return left to Expr  # CC: to !

	def expression2 as Expr
		peek = .peek().which
		if _unaryOpPrec.containsKey(peek)
			token = .grab()
			prec = _unaryOpPrec[peek]
			if token.which=='OLD'
				return OldExpr(token, .expression(prec))
			else
				return UnaryOpExpr(token, peek, .expression(prec))
		# TODO: make a branch statement
		else if peek=='LPAREN'
			.grab()
			node = .expression(0, nil)
			.expect('RPAREN')
			return node
		else if peek=='DOT'
			# leading dot
			token = .grab()
			peek = .peek().which
			if peek=='ID'
				token = .expect('ID')
				assert false, 'TODO'
#				expr = MemberExpr(token, token.text, nil, nil)
			else if peek=='OPEN_CALL'
				expr = .callExpr() to Expr
			else
				_error('Syntax error after "."')
			expr = Expr(Token.empty)  # TODO: axe this when the above are fixed
			return BinaryOpExpr.make(token to IToken, 'DOT', ThisLit(token, .curBox), expr)
		else if peek=='NIL'
			return NilLiteral(.grab())
		else if peek=='TRUE'
			return BoolLiteral(.grab())
		else if peek=='FALSE'
			return BoolLiteral(.grab())
		else if peek=='THIS'
			return ThisLit(.grab(), .curBox)
		else if peek=='BASE'
			return BaseLit(.grab(), .curBox)
# TODO
#		else if peek=='VAR'
#			return VarLit(.grab(), _curCodePart)
		else if peek=='CHAR_LIT_SINGLE'
			return CharLit(.grab())
		else if peek=='CHAR_LIT_DOUBLE'
			return CharLit(.grab())
		else if peek=='STRING_START_SINGLE'
			return .stringWithSubstitutionLit('STRING_START_SINGLE', 'STRING_PART_SINGLE', 'STRING_STOP_SINGLE')
		else if peek=='STRING_START_DOUBLE'
			return .stringWithSubstitutionLit('STRING_START_DOUBLE', 'STRING_PART_DOUBLE', 'STRING_STOP_DOUBLE')
		else if peek=='STRING_SINGLE'
			return StringLit(.grab())
		else if peek=='STRING_DOUBLE'
			return StringLit(.grab())
		else if peek=='INTEGER_LIT'
			return IntegerLit(.grab())
		else if peek=='DECIMAL_LIT'
			return DecimalLit(.grab())
		else if peek=='FLOAT_LIT'
			return FloatLit(.grab())
# TODO
#		else if peek=='LBRACKET'
#			return .literalList()
#		else if peek=='LCURLY'
#			return .literalDict()
#		else if peek=='OPEN_IF'
#			return .ifExpr()
		else if peek=='OPEN_CALL'
			return .callExpr()
#		else if peek=='OPEN_GENERIC'
#			return TypeExpr(.type())
		else if peek=='ID'
			return .identifierExpr()
		else
			return .typeExpr()
# TODO
#			try
#				return TypeExpr(.nonqualifiedType('throw'))
#			catch ParserError, pe
#				if pe.errorMessage==.expectingAType
#					.error('Expecting an expression.')
#				else
#					throw

	def callExpr as CallExpr
		"""
		Syntax:
			foo(args)
		"""
		token = .expect('OPEN_CALL')
		callName = token.value to String
		assert not callName.endsWith('(')
		exprs = .commaSepExprs('RPAREN')
		return CallExpr(token, callName, exprs)

	def commaSepExprs(terminator as String) as List<of Expr>
		return .commaSepExprs([terminator], false)

	def commaSepExprs(terminators as List<of String>) as List<of Expr>
		return .commaSepExprs(terminators, false)

	def commaSepExprs(terminators as List<of String>, isSpaceAgnostic as bool) as List<of Expr>
		"""
		Example source
			... expr TERMINATOR
			... expr, expr TERMINATOR
			... expr, expr, expr, TERMINATOR
		Returns
			A list of expressions.
		Notes
			Popular terminators are 'EOL' and 'RPAREN'.
			The terminator token is consumed, but can be examined with .last().
		"""
		expectComma = false
		exprs = List<of Expr>()
		while true
			if isSpaceAgnostic
				_spaceAgnostic()
			if .peek().which in terminators
				terminator = .grab()
				break
			if expectComma
				.expect('COMMA')
			if .peek().which in terminators
				terminator = .grab()
				break
			if isSpaceAgnostic
				_spaceAgnostic()
			if .peek().which in terminators
				terminator = .grab()
				break
			.newOpStack()
			try
				exprs.add(.expression())
			finally
				.delOpStack()
			expectComma = true
		return exprs

	def identifierExpr as Expr
		nameToken = .expect('ID')
		name = nameToken.text
		if .opStack and .opStack.peek()=='DOT'
			return MemberExpr(nameToken, name)
		if .peek().which=='AS'
# TODO
#			if name[0] not in .lowercaseLetters
#				.error(TidBits.localVarLowercaseError)
			asToken = .grab()
			type = .type()
			assert type
			return AsExpr(asToken, nameToken, type)
		else
			return IdentifierExpr(nameToken, name, nil)

	def stringWithSubstitutionLit(whichStart as String, whichPart as String, whichStop as String) as StringSubstLit
		# comment this mo-fo
		items = List<of Expr>()
		item = .expect(whichStart)
		items.add(StringLit(item))
		while true
			expr = .expression()
			fmt = .optional('STRING_PART_FORMAT')
			if fmt
				assert fmt.text.startsWith('')
				items.add(FormattedExpr(expr, fmt.text.substring(1)))
			else
				items.add(expr)
			peek = .peek().which
			if peek==whichPart
				items.add(StringLit(.grab()))
			else if peek==whichStop
				items.add(StringLit(.grab()))
				break
			else
				if _verbosity>=4
					print '<> stringWithSubstitutionLit([whichStart], [whichPart], [whichStop])'
				_error('Expecting more string contents or the string end after the expression.')
		return StringSubstLit(items)

	def typeExpr as TypeExpr
		t = .type()
		# Not expecting a TypeIdentifier() because the ID token case is
		# handled in expression parsing well before Cobra starts looking
		# for a type.
		if t inherits IType
			return TypeExpr(.last, t)
		else
			assert false, t

	##
	## Types
	##

	def type as INode
		token = .grab()
		# TODO: use .typeProvider.fooType
		if token.text=='int'
			return IntType()
		else if token.text=='bool'
			return BoolType()
		else if token.text=='char'
			return CharType()
		else if token.text=='decimal'
			return DecimalType()
		else if token.text=='float'
			return FloatType()
		else if token.text=='passthrough'
			return .typeProvider.passThroughType
		else if token.which=='ID'
			return TypeIdentifier(token)
		else
			_error('Unrecognized type: [token]')
			return CobraType()


	##
	## Op stack
	##

	def newOpStack
		require _opStackStack!
		_opStackStack.push(Stack<of String>())

	def delOpStack
		require _opStackStack
		_opStackStack.pop()

	get opStack as Stack<of String>
		"""
		Returns the current opStack.
		"""
		return _opStackStack.peek() to Stack<of String>  # CC: axe to String


	##
	## Protected self utility
	##

	def checkProperty(name as String)
		box = .curBox
		if name==box.name
			_error('Property names cannot be the same as their enclosing type.')  # TODO: list the enclosing types location
		other = box.declForName(name)
		if other
			_error('There is already another class member with the name "[name]".')  # TODO: list its location and possibly what it is
		other = box.declForNameCI(name)
		if other
			_error('There is already another class member with the name "[other.name]". You must differentiate member names by more than just case.')
		if Utils.startsNonLower(name)
			_error('Property names must start with lowercase letters. ([name])')

	def checkStartsLowercase(identifier as String, whatName as String)
		"""
		Makes an error if identifier does not match 'foo'.
		whatName should be capitalized.
		"""
		if identifier[0]=='_'
			sugg = identifier.substring(1, identifier.length-1)
			while sugg
				sugg = sugg.substring(1, sugg.length-1)
			sugg = sugg[0].toString().toLower() + sugg.substring(1, sugg.length-1)
			_error('[whatName] declarations cannot start with an underscore. Those are reserved for class variables. Try "[sugg]".')
		if Utils.startsNonLower(identifier)  # CC: should be char.isLower(identifier[0]), but cannot see members of char at this time
			sugg = identifier[0].toString().toLower() + identifier.substring(1, identifier.length-1)
			_error('[whatName] declarations must start with a lowercase letter to distinguish them from other types of identifiers. Try "[sugg]".')

	def _error(msg as String)
		token = .last
		if token
			msg = '[token.fileName]([token.lineNum],[token.colNum]): error: [msg]'
		else
			msg = '[token.fileName](1, 1): error: [msg]'
		if _whenError==WhenErrorEnum.exit
			print msg
			if _verbosity>=1
				print 'Last tokens:'
				print '    ...'
				for pair in .lastN(9)
					s = '    [pair.i]. [pair.token]'
					s = s.padRight(25) + 'line [pair.token.lineNum]'
					print s
			if _verbosity<2
				Environment.exit(1)
				# otherwise throw an exception in order to be more verbose
		throw ParserException(.last, msg)

	def _warning(msg as String)
		assert false, 'to do'

	def _pushCodePart(codePart as ICodePart)
		_codeParts.push(codePart)
		_curCodePart = codePart

	def _popCodePart
		require _codeParts
		_codeParts.pop()
		# CC: _curCodePart = if(_codeParts, _codeParts.peek(), nil)
		if _codeParts
			_curCodePart = _codeParts.peek() to ICodePart  # CC: axe "to ICodePart"
		else
			_curCodePart = nil

	def _spaceAgnostic
		pass

	def _finishSpaceAgnostic
		pass


class NumberedToken
	"""
	In support of Parser.lastN.
	# TODO: Replace this with Pair<T1, T2>
	"""

	var _i as int
	var _token as IToken

	def construct(i as int, token as IToken)
		_i = i
		_token = token

	get i from var
	get token from var

	def toString as String is override
		return '([_i], [_token])'
