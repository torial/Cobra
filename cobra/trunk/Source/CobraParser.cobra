"""
The Cobra Parser
"""


class Parser
	"""
	Notes:

		* The tokenizer's verbosity is set to 4 less than the parser's. In other words, the
		  tokenizer will not print messages unless the parser's verbosity is 5 or greater.

	"""

	test
		p = Parser()
#		p.parseSource('class Test\n\tpass\n')

	enum WhenError
		exit

	enum WhenWarning
		emit
		throww

	var _lowercaseLetters = 'abcdefghijklmnopqrstuvwxyz'
	var _uppercaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

	var _fileName as String?
	var _willShowTokens = false
	var _verbosity = 0

	var _tokens as List<of IToken>?
	var _curTokenIndex as int


	def construct
		pass

	def parseFileNamed(fileName as String) as Node
		_fileName = fileName
		source = File.readAllText(_fileName to String)  # CC: axe "to String" when "if" gets smart about non-nil
		return .parseSource(source)

	def parseSource(source as String) as Node
		"""
		Parses module source code and returns resulting module.
		"""
		if not _fileName
			_fileName = '(no file name)'
		tokVerbosity = _verbosity - 4  # in order words, tokenizer does not spew unless our verbosity is 5 or greater
		if tokVerbosity<0
			tokVerbosity = 0

		_tokens = nil
		try
			_tokens = CobraTokenizer(tokVerbosity).startSource(source).allTokens()
		catch te as TokenizerError
			print '<> Caught TokenizerError'
			print te
			assert false
		_curTokenIndex = 0

		return .parseTokens()


	## Tokens

	def grab as IToken?
		"""
		Returns the next token or nil if there are none left.
		"""
		if _curTokenIndex >= _tokens.count
			return nil
		token = _tokens[_curTokenIndex]
		_curTokenIndex += 1
		if _willShowTokens
			print 'grab    --> [token]'
		return token

	def undo
		"""
		Undoes the last token() call. Often called "push" in parser examples.
		"""
		require _curTokenIndex>0
		_curTokenIndex -= 1
		if _willShowTokens
			print 'undo'

	def peek as IToken?
		return .peek(0)

	def peek(offset as int) as IToken?
		"""
		Returns a token without changing the current token, or nil if none left.
		With no offset, returns the current token, otherwise peeks ahead.
		"""
		i = _curTokenIndex + offset
		if i < _tokens.count
			token = _tokens[i]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'peek([offset]) --> [token]'
		return token

	get last as IToken?
		"""
		Returns the last token returned by get() or nil if get() was never invoked.
		"""
		if _curTokenIndex > 0
			token = _tokens[_curTokenIndex]
		else
			token = nil to passthrough  # CC: get rid of cast somehow
		if _willShowTokens
			print 'last    --> [token]'
		return token

	def expect(whatTypes as vari String) as IToken?
		"""
		Gets a token and complains if its type does not match whatType(s).
		Returns the token.
		"""
		t = .grab()
		if _willShowTokens
			print 'expect([whatTypes]) --> [t]'
		# TODO: join whatTypes by ' or ' in 2 following errors to make them more readable
		if t is nil
			_error('Expecting [whatTypes], but source ended suddenly.')
		# CC: support "not in" on vari type
		#if t.which not in whatTypes
		#	_error('Expecting [whatTypes], but got [t] instead.')
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if not found
			_error('Expecting [whatTypes], but got [t] instead.')
		return t

	def optional(whatTypes as vari String) as IToken?
		"""
		Gets a token, but only if it matches whatTypes.
		Does not complain or consume a token if there is no match.
		"""
		t = .peek()
		if _willShowTokens
			print 'optional([whatTypes]) --> [t]'
		if t is nil
			return nil
		# CC: support "in" on vari type
		#if t.which in whatTypes
		found = false
		for wt in whatTypes
			if t.which == wt
				found = true
				break
		if found
			return .grab()
		else
			return nil

	def oneOrMore(which as String)
		"""
		Consumes the expected token and any other additional contiguous ones.
		Returns nothing.
		Example:  .oneOrMore('EOL')
		"""
		.expect(which)
		while .peek().which == which
			.grab()


	## Parsing

	var _module as Module

	def parseTokens as Node
		"""
		Parses and then returns an instance of Module.
		"""
		_module = CobraModule(_fileName, _verbosity)  # TODO: does module really need verbosity?
		if not _fileName.endsWith('SystemInterfaces.cobra')
			# default use directives
			_module.addDecl(UseDirective(nil, ['System']))
			_module.addDecl(UseDirective(nil, ['System', 'Collections', 'Generic']))
			_module.addDecl(UseDirective(nil, ['System', 'IO']))
			_module.addDecl(UseDirective(nil, ['System', 'Text']))
			_module.addDecl(UseDirective(nil, ['Cobra', 'Lang']))
		# TODO: _module.docString = .docString()
		what as Node?
		while true
			what = nil
			addToNS = true
			tok = .peek()
			if tok is nil
				break
			branch tok.which
				on 'USE':       what = .useDirective()
				on 'IMPORT':    what = .importDirective()
				on 'CLASS':     what = .classDecl()
				on 'INTERFACE': what = .interfaceDecl()
				on 'STRUCT':    what = .structDecl()
				on 'ENUM':      what = .enumDecl()
				on 'EOL':       .grab()
				on 'NAMESPACE'
					.nameSpaceDecl()
					addToNS = false
				else
					_error('Expecting use, import, namespace, class, interface or enum, but got [tok]')
					break
			if what
				_module.addDecl(what to Node)  # CC: axe typecast
			print '<> at end, tok=[tok] and what=[what]'
# TODO:
#				if addToNS
#					_globalNS.addDecl(what)

		return _module

	def useDirective as Node
		return Node()

	def importDirective as Node
		return Node()

	def classDecl as Node
		return Node()

	def interfaceDecl as Node
		return Node()

	def structDecl as Node
		return Node()

	def enumDecl as Node
		return Node()

	def nameSpaceDecl as Node
		return Node()

	def _error(msg as String)
		throw Exception()


class Node
	pass


class Module
	inherits Node

	var _declsInOrder as List<of Node>

	def construct(fileName as String, verbosity as int)
		_declsInOrder = List<of Node>()

	def addDecl(decl as Node)
		_declsInOrder.add(decl)

class CobraModule
	inherits Module

	def construct(fileName as String, verbosity as int)
		base.construct(fileName, verbosity)

class UseDirective
	inherits Node

	def construct(obj as Object?, nameParts as List<of String>)
		pass
