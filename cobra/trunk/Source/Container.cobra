interface IContainer
	inherits IMember
	"""
	Containers are named nodes that respond to declForName().
	Containers include:
		* NameSpace
		* Box
		  * Class
		  * Struct
		  * Interface
		* Enum
	"""
	def declForName(name as String) as IMember?
		"""
		Returns the member of this container with the given name.
		May return nil if no such container exists.
		Case-sensitive.
		"""

	def memberForName(name as String) as IMember?
		"""
		Returns the member of this container with the given name, including any inherited members.
		May return nil if no such container exists.
		Case-sensitive.
		"""


class Container
	inherits NamedNode
	implements IContainer, IType
	"""
	TODO: Should Container inherit from CobraType? I guess the problem is that NamedNode is a SyntaxNode and CobraType inherits from Node. However, IType does specify a name... Maybe NamedNode should inherit Node and the token thing done via ISyntaxNode only. At the very least, greatestCommonDenominatorWith() is duplicated. Others may be as well.

	A container has:
		* declarations in a given order, but also accessible by name,
		  both case-sensitive and non.
		* a doc string

	A container is a NamedNode, IContainer and IType.

	The declForName[CI] methods do not follow inheritance, but the
	memberForName() should (subclasses have to override).

	IMember is implemented (brought in via IContainer).

	The target type that is contained is IMember.  TODO: should that be a generic parameter?

	Subclasses are responsible for passing bindInt and bindImp to _declsInOrder.
	"""

	var _declsInOrder as List<of IMember>  # TODO: can the inner list type be narrowed more? say to IClassMemberDecl or ClassMemberDecl
	var _declsByName as Dictionary<of String, IMember>
	var _declsByNameCI as Dictionary<of String, IMember>
	var _docString as String
	var _isNames as List<of String>

	def construct(token as IToken, name as String, docString as String?)
		base.construct(token, name)
		_declsInOrder = List<of IMember>()
		_declsByName = Dictionary<of String, IMember>()
		_declsByNameCI = Dictionary<of String, IMember>()
		_docString = docString ? ''

	get declsInOrder from var

	def addDecl(decl as IMember)
		require
			decl.name
			not .declsInOrder.contains(decl)
			.declForName(decl.name) is nil
			.declForNameCI(decl.name) is nil
		ensure
			.declsInOrder.contains(decl)
			.declForName(decl.name) is decl
			.declForNameCI(decl.name) is decl
			.declsInOrder.count == old .declsInOrder.count + 1
		code
			_declsInOrder.add(decl)
			_declsByName.add(decl.name, decl)
			_declsByNameCI.add(decl.name.toLower(), decl)

	def declForName(name as String) as IMember?
		require
			name
		ensure
			result implies result.name==name
		code
			return if(_declsByName.containsKey(name), _declsByName[name], nil)

	def declForNameCI(name as String) as IMember?
		require
			name
		ensure
			result implies result.name.toLower()==name.toLower()
			result is nil implies .declForName(name) is nil
		code
			name = name.toLower()
			return if(_declsByNameCI.containsKey(name), _declsByNameCI[name], nil)

	pro docString from var

	def addSubFields is override
		base.addSubFields()
		.addField('declsInOrder', _declsInOrder)

	## IMember

	get englishName as String
		throw OverrideException(.getType())
		return ''

	get isCallable as bool
		return false

	get requiresThis as bool
		return false

	get resultType as IType
		return this

	## IType

	def greatestCommonDenominatorWith(type as IType) as IType
		if this is type
			return this
		if .isDescendantOf(type)
			return type
		if type.isDescendantOf(this)
			return this
		# TODO: following is a guess
		if .superType and type.superType
			return .superType.greatestCommonDenominatorWith(type.superType to IType)
		else
			return .compiler.libraryType('System', 'Object')

	def isAssignableTo(type as IType) as bool
		require
			.compiler
		code
			# TODO: some code dup with IType
			if this is type
				return true
			if type is .compiler.passThroughType
				return true
			if type is .compiler.libraryType('System', 'Object')
				return true
			# TODO: remove this:
			if type inherits GenericParam
				return true
			# TODO: would this be needed if not for qualified types?
			if type inherits WrappedType
				return .isAssignableTo(type.theWrappedType to passthrough)  # CC: weird cast
			return .isDescendantOf(type)

	def isDescendantOf(type as IType) as bool
		require
			.didBindInt
		code
			return type is this

	get isReference as bool
		throw OverrideException()
		return false

	def indexType(argTypes as List<of IType>) as IType?
		return nil

	get innerType as IType?
		return nil

	get superType as IType?
		require .didBindInt
		return nil

	get isGenericDef as bool
		return false

	get isGeneric as bool
		return false

	get genericParams as List<of IType>
		if .isGenericDef
			throw Exception('.isGenericDef returns true, but there is no override to return the genericParams')
		else
			throw Exception('.isGenericDef returns false, so there can be no genericParams')

	def constructedTypeFor(typeArgs as List<of IType>) as IType
		if .isGenericDef
			throw Exception('.isGenericDef returns true, but there is no override to constructedTypeFor')
		else
			throw Exception('.isGenericDef returns false, so there can be no constructedTypeFor')
		return CobraType()  # TODO: axe whole line when code flow analysis proves it's not needed

	def memberForName(name as String) as IMember?
		m = .declForName(name)
		if m is nil
			objClass = .compiler.libraryType('System', 'Object')
			if this is not objClass
				return objClass.memberForName(name)
		return m

	get csInit as String
		throw OverrideException(.getType())
		return ''

	# TODO: _isNames, writeSharpIsNames() and defaultAccessLevel should be moved out to a mixin since NameSpace, a subclass of Container, has no isNames. Box and Enum do. So does ClassMember which duplicates this.

	get defaultAccessLevel as String
		throw OverrideException(.getType())
		return ''

	def writeSharpIsNames(sw as SharpWriter)
		# TODO: cache this somewhere
		accessLevels = ['public', 'protected', 'internal', 'protected internal', 'private']
		# CC: accessLevels = 'public,protected,internal,protected internal,private'.split(c',')
			# same names in both Cobra and C#

		# TODO:
		# if isNames is nil
		#	isNames = _isNames
		isNames = List<of String>()
		if _isNames
			isNames.addRange(_isNames)
		if .defaultAccessLevel
			found = false
			for level as String in accessLevels  # CC: axe as
				if level in isNames
					found = true
			if not found
				isNames.insert(0, .defaultAccessLevel)
		isNameCS = {
			# only have to specify the ones that are different
			'shared': 'static',
			'nonvirtual': '',
		}
		sep = ''
		for name in isNames
			name = Utils.getSS(isNameCS to passthrough, name, name) to String # CC: to !
			sw.write(sep)
			sw.write(name)
			sep = ' '
		if sep
			sw.write(' ')

	## Other

	def cloneCollections
		_declsInOrder = List<of IMember>(_declsInOrder)
		_declsByName = Dictionary<of String, IMember>(_declsByName)
		_declsByNameCI = Dictionary<of String, IMember>(_declsByNameCI)


interface IMember
	inherits INamedNode
	"""
	Anything that could conceivably be a member of namespace, class,
	struct or interface, implements IMember.

	That includes namespaces, classes, structs and interfaces
	themselves. As well as the obvious choices of methods, constructors,
	properties and indexers. Also, enums and generic parameters, which
	themselves can be specific types such as `int`.

	That mostly leaves statements and expressions as the nodes that
	cannot be IMembers.

	IContainer and Container both reference IMember extensively.

	Furthermore, IContainer happens to implement IMember because, as it
	turns out, all of the containers may be members of other containers
	(though not without restrictions (a namespace can belong to only
	another namespace)).
	"""

	get isCallable as bool
		"""
		Returns true if this member can be called with parens: () or (args)
		"""

	get englishName as String  # TODO: rename to englishTypeName
		"""
		Return the type of member as a plain, lowercase English word:
			class, property, method, namespace, etc.
		"""

	get requiresThis as bool
		"""
		Returns true if accessing the member requires a `this`
		reference. True of non-shared properties, methods and fields.
		"""

	get resultType as IType  # TODO: rename to dottedAccessResultType
		"""
		Returns the result of accessing this member in the source
		expression "foo.bar" where this is the bar. For a method or
		property, this would be the return type. For other members like
		enums and classes, this would be the member itself.
		"""

	def writeSharpDef(sw as SharpWriter)
		"""
		Write the C# code for this member declaration to the given
		SharpWriter.
		"""