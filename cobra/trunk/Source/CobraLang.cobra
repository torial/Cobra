

namespace Cobra

	namespace Lang

		class CobraImp
			is fake
			shared
				get hasSuperStackTrace
					pass
				def dumpStack
					pass
				def dumpStack(tw as System.IO.TextWriter)  # TODO: why does TextWriter have to be qualified?
					pass
				def typeName(t as Type) as String
					pass
				def toTechString(x as Object?) as String
					pass

		class Tracer
			inherits Object
			"""
			Used to implement the trace statement.
			TODO: support indentation
			"""

			var _isActive = true
			var _willAutoFlush = true
			var _dest as System.IO.TextWriter
			var _separator = '; '
			var _prefix = 'trace: '

			def init
				"""
				Initializes the tracer with Console.out as the destination.
				"""
				.init(Console.out)

			def init(dest as System.IO.TextWriter)
				base.init
				_dest = dest

			pro isActive from var
				"""
				When false, the `trace` methods will produce no output.
				"""

			pro willAutoFlush from var
				"""
				When true, `destination.flush` is invoked after every trace.
				Defaults to `true`.
				"""

			pro destination from _dest
				"""
				The TextWriter where all trace output is sent to.
				"""

			pro separator from var
				"""
				The separator string used between items of both name/value pairs and source information.
				Default is '; '.
				"""

			pro prefix from var
				"""
				The prefix string used at the beginning of every trace.
				Default is 'trace: '.
				"""

			def trace(source as SourceInfo)
				if .isActive
					print to _dest, '[.prefix][source.oneLiner(.separator)]'
					if .willAutoFlush
						_dest.flush

			def trace(source as SourceInfo, nameValues as vari Object)
				require nameValues.length % 2 == 0
				if .isActive
					_dest.write(.prefix)
					sep = .separator
					i = 0
					while i < nameValues.length-1
						name = nameValues[i] to String
						value = CobraCore.toTechString(nameValues[i+1])
						_dest.write('[name]=[value][sep]')
						i += 2
					_dest.writeLine(source.oneLiner(.separator))
					if .willAutoFlush
						_dest.flush

		class CobraCore

			shared

				## Release info

				get version as Version
					return Version(0, 4, 0)

				get releaseNum as int

					return 17


				## Command line args in generic list form

				get commandLineArgs as List<of String>
					return List<of String>(Environment.getCommandLineArgs)


				## Tracer

				var _tracer as Tracer

				pro tracer as Tracer
					"""
					The global Tracer object used by `trace` statements.
					Via this property, you can set this to your own instance,
					or access the tracer to read or write its properties.
					To turn off tracing, for example, you can write `CobraCore.tracer.isActive = false`.
					"""
					get
						if _tracer is nil
							_tracer = Tracer()
						return _tracer
					set
						_tracer = Tracer()


				## Super stack trace

				get hasSuperStackTrace
					return CobraImp.hasSuperStackTrace

				def dumpStack
					CobraImp.dumpStack

				def dumpStack(tw as System.IO.TextWriter)  # TODO: why does TextWriter have to be qualified?
					CobraImp.dumpStack(tw)


				## Type names and tech strings

				def typeName(t as Type) as String
					return CobraImp.typeName(t)

				def toTechString(x as Object?) as String
					return CobraImp.toTechString(x)


				## Will check control flags

				# CC: make a public section/block here
				var _willCheckInvariant = true
					is public
				var _willCheckRequire = true
					is public
				var _willCheckEnsure = true
					is public
				var _willCheckAssert = true
					is public
				var _willCheckNonNilClassVars = true
					is public

				pro willCheckInvariant from var
				pro willCheckRequire from var
				pro willCheckEnsure from var
				pro willCheckAssert from var
				pro willCheckNonNilClassVars from var

				set willCheckAll as bool
					.willCheckInvariant = value
					.willCheckRequire = value
					.willCheckEnsure = value
					.willCheckAssert = value
					.willCheckNonNilClassVars = value

		class SourceInfo
			"""
			A SourceInfo instance captures the source location of a statement or expression, as in the
			filename, line number, declaring class name, method name and run-time object. The Cobra
			compiler generates SourceInfo instances in various circumstances; for example, the `trace`
			statement.
			"""

			var _fileName as String
			var _lineNum as int
			var _className as String
			var _memberName as String
			var _object as Object

			def init(fileName as String, lineNum as int, className as String, memberName as String, obj as Object)
				_fileName = fileName
				_lineNum = lineNum
				_className = className
				_memberName = memberName
				_object = obj

			def toString as String is override
				fileName = CobraCore.toTechString(_fileName)
				className = CobraCore.toTechString(_className)
				memberName = CobraCore.toTechString(_memberName)
				obj = CobraCore.toTechString(_object)
				return '[.getType.name]([fileName], [_lineNum], [className], [memberName], [obj])'

			get fileName from var

			get lineNum from var

			get className from var

			get memberName from var

			get object from var

			get runTimeClassName as String
				return _object.getType.name

			def oneLiner(sep as String) as String
				test
					si = SourceInfo('Foo.cobra', 10, 'Object', 'bar', Object())
					assert si.oneLiner('; ') == 'at Foo.cobra:10; in Object.bar'
					si = SourceInfo('Foo.cobra', 10, 'Foo', 'bar', Object())
					assert si.oneLiner('; ') == 'at Foo.cobra:10; in Foo.bar; subclass Object'
				body
					sb = $sharp('new System.Text.StringBuilder()') to System.Text.StringBuilder
					sb.append('at [_fileName]:[_lineNum][sep]in [_className].[_memberName]')
					name = .runTimeClassName
					if name <> _className
						sb.append('[sep]subclass [name]')
					return sb.toString

		class FallThroughException
			inherits Exception

			var _info as Object?

			def init
				.init(nil)
				pass

			def init(info as Object?)
				base.init
				_info = info

			def init(info as Object?, innerExc as Exception?)
				base.init(nil, innerExc)
				_info = info

			get message as String is override
				return 'info=[CobraCore.toTechString(_info)]'

			get info as Object?
				return _info

		class DynamicOperationException
			inherits Exception
			"""
			The base class for all dynamic operation exceptions.
			"""

			def init(message as String)
				.init(message, nil)

			def init(message as String, innerExc as Exception?)
				base.init(message, innerExc)

		class UnknownMemberException
			inherits DynamicOperationException

			var _obj as Object
			var _name as String
			var _type as Type

			def init(obj as Object, name as String, type as Type)
				.init(obj, name, type, nil)

			def init(obj as Object, name as String, type as Type, innerExc as Exception?)
				base.init(nil, innerExc)
				_obj = obj
				_name = name
				_type = type

			get message as String is override
				return 'obj=[CobraCore.toTechString(_obj)], name=[CobraCore.toTechString(_name)], type=[_type]'


		class CannotReadPropertyException
			inherits UnknownMemberException

			# CC: axe init()s

			def init(obj as Object, name as String, type as Type)
				.init(obj, name, type, nil)

			def init(obj as Object, name as String, type as Type, innerExc as Exception?)
				base.init(obj, name, type, innerExc)

		class CannotWritePropertyException
			inherits UnknownMemberException

			# CC: axe init()s

			def init(obj as Object, name as String, type as Type)
				.init(obj, name, type, nil)

			def init(obj as Object, name as String, type as Type, innerExc as Exception?)
				base.init(obj, name, type, innerExc)

		class CannotSliceTypeException
			inherits UnknownMemberException

			# CC: axe init()s

			def init(obj as Object, name as String, type as Type)
				.init(obj, name, type, nil)

			def init(obj as Object, name as String, type as Type, innerExc as Exception?)
				base.init(obj, name, type, innerExc)

		class CannotInTypeException
			inherits UnknownMemberException

			# CC: axe init()s

			def init(obj as Object, name as String, type as Type)
				.init(obj, name, type, nil)

			def init(obj as Object, name as String, type as Type, innerExc as Exception?)
				base.init(obj, name, type, innerExc)

		class CannotCompareException
			inherits DynamicOperationException

			var _a
			var _b

			def init(a, b)
				.init(a, b, nil)

			def init(a, b, innerExc as Exception?)
				base.init(nil, innerExc)
				_a = a
				_b = b
