namespace Cobra

	namespace Lang

		class CobraImp
			is fake
			shared
				get hasSuperStackTrace
					pass
				get superStackTrace as Stack<of CobraFrame>
					pass
				def typeName(t as Type) as String
					pass
				def toTechString(x as Object?) as String
					pass
				var _maxStackFrames as int
				var _numLastMaxStackFrames as int

		class Tracer
			inherits Object
			"""
			Used to implement the trace statement.
			"""

			var _isActive = true
			var _willAutoFlush = true
			var _dest as System.IO.TextWriter
			var _separator = '; '
			var _prefix = 'trace: '

			def init
				"""
				Initializes the tracer with Console.out as the destination.
				"""
				.init(Console.out)

			def init(dest as System.IO.TextWriter)
				base.init
				_dest = dest

			pro isActive from var
				"""
				When false, the `trace` methods will produce no output.
				"""

			pro willAutoFlush from var
				"""
				When true, `destination.flush` is invoked after every trace.
				Defaults to `true`.
				"""

			pro destination from _dest
				"""
				The TextWriter where all trace output is sent to.
				"""

			pro separator from var
				"""
				The separator string used between items of both name/value pairs and source information.
				Default is '; '.
				"""

			pro prefix from var
				"""
				The prefix string used at the beginning of every trace.
				Default is 'trace: '.
				"""

			def trace(source as SourceInfo)
				if .isActive
					print to _dest, '[.prefix][source.oneLiner(.separator)]'
					if .willAutoFlush
						_dest.flush

			def trace(source as SourceInfo, nameValues as vari Object)
				require nameValues.length % 2 == 0
				if .isActive
					_dest.write(.prefix)
					sep = .separator
					i = 0
					while i < nameValues.length-1
						name = nameValues[i] to String
						value = CobraCore.toTechString(nameValues[i+1])
						_dest.write('[name]=[value][sep]')
						i += 2
					_dest.writeLine(source.oneLiner(.separator))
					if .willAutoFlush
						_dest.flush

		class CobraCore

			shared
			
				## Release info

				get version as Version
					return Version(0, 5, 0)

				get releaseNum as int
					return 18


				## Program stuff

				get commandLineArgs as List<of String>
					return List<of String>(Environment.getCommandLineArgs)

				get exePath as String
					"""
					Returns the full path of the currently executing exe including directory, file name and extension.
					"""
					test
						assert '.exe' in CobraCore.exePath
					body
						return System.Reflection.Assembly.getExecutingAssembly.location


				## Tracer

				var _tracer as Tracer

				pro tracer as Tracer
					"""
					The global Tracer object used by `trace` statements.
					Via this property, you can set this to your own instance,
					or access the tracer to read or write its properties.
					To turn off tracing, for example, you can write `CobraCore.tracer.isActive = false`.
					"""
					get
						if _tracer is nil
							_tracer = Tracer()
						return _tracer
					set
						_tracer = Tracer()


				## Super stack trace

				pro maxStackFrames as int
					"""
					When super stack trace is on, this value limits the maximum stack depth before
					Cobra will exit with a stack overflow error including a listing of the most
					recent stack frames. The default value is 500. You can set to 0 to disable
					stack overflow detection.
					"""
					get
						return CobraImp._maxStackFrames
					set
						require value == 0 or value > 9
						CobraImp._maxStackFrames = value

				pro numLastMaxStackFrames as int
					"""
					When stack overflow is detected, this value gives the number of most recent stack frames that will be printed.
					"""
					get
						return CobraImp._numLastMaxStackFrames
					set
						require value >= 2
						CobraImp._numLastMaxStackFrames = value
						
				get hasSuperStackTrace
					return CobraImp.hasSuperStackTrace

				def dumpStackAsText
					.dumpStackAsText(Console.out)

				def dumpStackAsText(tw as System.IO.TextWriter)  # TODO: why does TextWriter have to be qualified?
					.dumpStackAsText(tw, CobraImp.superStackTrace)
						
				def dumpStackAsText(tw as System.IO.TextWriter, frames as Stack<of CobraFrame>)
					# dump the most recent stack frames last since the text will output top-down and scroll in the shell
					tw.writeLine('Stack trace:')
					if not frames.count
						tw.writeLine('No stack frames.')
					else
						i = 0
						for frame in frames
							frame.dumpText(tw, i)
							i += 1

				def dumpStackAsHtml(tw as System.IO.TextWriter)  # CC: no qual
					.dumpStackAsHtml(tw, CobraImp.superStackTrace)
					
				def dumpStackAsHtml(tw as System.IO.TextWriter, frames as Stack<of CobraFrame>)  # CC: no qual
					# dump the most recent stack frames first since the HTML file will be displayed at the top in the browser
					tw.writeLine('<html>')
					tw.writeLine('<link href=styles.css rel=stylesheet type="text/css">')
					tw.writeLine('<body>')
					tw.writeLine('<div class=sstHeading>Cobra Super Stack Trace</div>')
					tw.writeLine('<table class=keyValues border=0 cellpadding=1 cellspacing=1>')
					name = System.Diagnostics.Process.getCurrentProcess.processName
					if name.endsWith('mono')
						for part in Environment.commandLine.split(c' ')
							if part.endsWith('.exe')
								name = System.IO.Path.getFileName(part)  # CC: axe namespace
								break
					.pair(tw, 'Program', name)
					.pair(tw, 'When', DateTime.now)
					.pair(tw, 'CommandLine', Environment.commandLine)
					.pair(tw, 'CurrentDirectory', Environment.currentDirectory)
					.pair(tw, 'MachineName', Environment.machineName)
					.pair(tw, 'Cobra', CobraCore.version)
					tw.writeLine('</table>')
					if not frames.count
						tw.writeLine('<p>No stack frames.</p>')
					else
						frameList = List<of CobraFrame>(frames)
						frameList.reverse
						tw.writeLine('<table class=stack border=0 cellpadding=1 cellspacing=1>')
						i = 0
						for frame in frameList
							frame.dumpHtml(tw, i)
							i += 1
						tw.writeLine('</table>')
					tw.writeLine('</body>')
					tw.writeLine('</html>')

				def pair(tw as System.IO.TextWriter, key as String, value as Object)
					key = .htmlEncode(key)
					value = .htmlEncode(value.toString)
					tw.writeLine('<tr class=keyValue> <td class=key> [key] </td> <td> &nbsp;=&nbsp; </td> <td class=value> [value] </td> </tr>')

				def htmlEncode(s as String) as String
					# TODO: complete this
					return s


				## Type names and tech strings

				def typeName(t as Type) as String
					return CobraImp.typeName(t)

				def toTechString(x as Object?) as String
					return CobraImp.toTechString(x)


				## Will check control flags

				# CC: make a public section/block here
				var _willCheckInvariant = true
					is public
				var _willCheckRequire = true
					is public
				var _willCheckEnsure = true
					is public
				var _willCheckAssert = true
					is public
				var _willCheckNonNilClassVars = true
					is public

				pro willCheckInvariant from var
				pro willCheckRequire from var
				pro willCheckEnsure from var
				pro willCheckAssert from var
				pro willCheckNonNilClassVars from var

				set willCheckAll as bool
					.willCheckInvariant = value
					.willCheckRequire = value
					.willCheckEnsure = value
					.willCheckAssert = value
					.willCheckNonNilClassVars = value


				## Finding cobra command line program

				def findCobraExe as String?
					return .findCobraExe(nil)

				def findCobraExe(extraPaths as IList<of String>?) as String?
					"""
					Finds cobra.exe on the current system by looking in various places:
						* the current directory
						* the directory where the current executable resides
						* the path of the cobra.exe that produced the current executable
						* the path of the COBRA environment variable
						* the system PATH
						* educated guesses like \WINDOWS\Program Files\Cobra\bin and /usr/local/bin
						* the extraPaths argument
					"""
					# check previous cached result first
					if _findCobraCache
						return _findCobraCache
					# check the current directory
					path = _findCobraExe(Environment.currentDirectory)
					if path
						return path
					# check the directory where the current executable resides
					path = _findCobraExe(CobraCore.exePath)
					if path
						return path
					# check for the cobra that created the current executable
					if System.IO.File.exists(CobraInfo.cobraPath)
						return CobraInfo.cobraPath
					# check COBRA environment variable
					path = Environment.getEnvironmentVariable('COBRA') ? ''
					if path <> ''
						path = _findCobraExe(path)
						if path
							return path
					# check the PATH
					paths = (Environment.getEnvironmentVariable('PATH') ? '').split(System.IO.Path.pathSeparator)
					for sysPath in paths
						path = _findCobraExe(sysPath)
						if path
							return path
					# check common locations and extraPaths
					morePaths = [
						r'\WINDOWS\Program Files\Cobra\bin',
						r'\Cobra\bin',
						r'/usr/local/bin',
						r'/usr/bin',
						r'/bin',
					]
					if extraPaths
						morePaths.addRange(extraPaths)
					for path in morePaths
						path = _findCobraExe(path)
						if path
							return path
					# cannot find cobra.exe
					return nil

				def clearCobraExeCache
					"""
					The `findCobraExe` method caches its results for subsequent speed.
					This method clears the cache in the event you need to do so.
					"""
					_findCobraCache = nil

				var _findCobraCache as String?

				def _findCobraExe(path as String) as String?
					_findCobraCache = _findCobraExe(path, true)
					return _findCobraCache

				def _findCobraExe(path as String, firstTime as bool) as String?
					if path <> CobraCore.exePath and path.endsWith('cobra.exe')
						# ^ first condition guards against test cases like "invoke-cobra.exe" from endlessly invoking themselves
						if System.IO.File.exists(path)
							return path
						else
							return nil
					else if System.IO.Directory.exists(path)
						exe = System.IO.Path.combine(path, 'cobra.exe')
						if System.IO.File.exists(exe)
							return exe
						exe = System.IO.Path.combine(System.IO.Path.combine(path, 'bin'), 'cobra.exe')
						if System.IO.File.exists(exe)
							return exe
						if firstTime
							# check for a 'Cobra' subdirectory
							return _findCobraExe(System.IO.Path.combine(path, 'Cobra'), false)
						else
							return nil
					else
						return nil

		class CobraInfo
			is fake

			get cobraPath as String
				"""
				The Path of the cobra compiler executable that created this program.
				"""
				pass

		class SourceInfo
			"""
			A SourceInfo instance captures the source location of a statement or expression, as in the
			filename, line number, declaring class name, method name and run-time object. The Cobra
			compiler generates SourceInfo instances in various circumstances; for example, the `trace`
			statement.
			"""

			var _fileName as String
			var _lineNum as int
			var _className as String
			var _memberName as String
			var _object as Object

			def init(fileName as String, lineNum as int, className as String, memberName as String, obj as Object)
				_fileName = fileName
				_lineNum = lineNum
				_className = className
				_memberName = memberName
				_object = obj

			def toString as String is override
				fileName = CobraCore.toTechString(_fileName)
				className = CobraCore.toTechString(_className)
				memberName = CobraCore.toTechString(_memberName)
				obj = CobraCore.toTechString(_object)
				return '[.getType.name]([fileName], [_lineNum], [className], [memberName], [obj])'

			get fileName from var

			get lineNum from var

			get className from var

			get memberName from var

			get object from var

			get runTimeClassName as String
				return _object.getType.name

			def oneLiner(sep as String) as String
				test
					si = SourceInfo('Foo.cobra', 10, 'Object', 'bar', Object())
					assert si.oneLiner('; ') == 'at Foo.cobra:10; in Object.bar'
					si = SourceInfo('Foo.cobra', 10, 'Foo', 'bar', Object())
					assert si.oneLiner('; ') == 'at Foo.cobra:10; in Foo.bar; subclass Object'
				body
					sb = $sharp('new System.Text.StringBuilder()') to System.Text.StringBuilder
					sb.append('at [_fileName]:[_lineNum][sep]in [_className].[_memberName]')
					if not _object inherits Type
						# I guess that condition would preclude reporting the subclass name in a trace statement in subclasses of Type
						# But then those come with the system anyway (RuntimeType)
						name = .runTimeClassName
						if name <> _className
							sb.append('[sep]subclass [name]')
					return sb.toString

		class CobraFrame
		
			var _declClassName as String
			var _methodName as String
			var _fileName as String
			var _lineNum as int is public
			var _args as Object[]
			var _locals as Dictionary<of String, dynamic>
			var _localNamesInOrder as List<of String>
			
			def init(declClassName as String, methodName as String, fileName as String, lineNum as int, args as vari Object)
				"""
				args should have the arg names embedded: "x", x, "y", y
				"""
				_declClassName = declClassName
				_methodName = methodName
				_fileName = fileName
				_lineNum = lineNum
				_args = $sharp(r'(object[])args.Clone()')
				_locals = Dictionary<of String, dynamic>()
				_localNamesInOrder = List<of String>()
				for j = 0 .. _args.length ++ 2
					.setLocal(_args[j] to String, _args[j+1])

			def setLocal(name as String, value as dynamic)
				if not _locals.containsKey(name)
					_localNamesInOrder.add(name)
				_locals[name] = value

			def dumpText(tw as System.IO.TextWriter, i as int)
				nameWidth = 8
				tw.writeLine('\n    [i]. [this]')
				tw.writeLine('        args')
				for j = 0 .. _args.length ++ 2
					tw.write(String.format('               {0} = ', (_args[j] to String).padRight(nameWidth)))
					try
						s = CobraCore.toTechString(_args[j+1])
					catch e as Exception
						s = 'ToString() Exception: ' + e.message
					tw.writeLine(s)
				tw.writeLine('        locals')
				for name in _localNamesInOrder
					if name == 'this'
						continue
					tw.write(String.format('               {0} = ', name.padRight(nameWidth)))
					try
						s = CobraCore.toTechString(_locals[name])
					catch e as Exception
						s = 'ToString() Exception: ' + e.message
					tw.writeLine(s)

			def dumpHtml(tw as System.IO.TextWriter, i as int)
				tw.writeLine('<tr class=frameHead> <td class=number> [i]. </td> <td class=qualifiedMember colspan=4> [_declClassName].[_methodName] </td> </tr> ')
				baseName = System.IO.Path.getFileName(_fileName) # CC: no qual
				dirName = System.IO.Path.getDirectoryName(_fileName) # CC: no qual
				if dirName <> ''
					dirName = ' - ' + (dirName to String)
				tw.writeLine('<tr> <td class=indent> &nbsp; </td> <td class=label> at: </td> <td class=sourceLocation colspan=3> [_lineNum] [baseName] [dirName] </td> </tr>')
				for j = 0 .. _args.length ++ 2
					label = if(j==0, 'args:', '')
					tw.write('<tr class=frameDetails> <td class=indent> &nbsp; </td> <td class=label> [label] </td> <td> [_args[j]] </td> <td> &nbsp;=&nbsp; </td>')
					try
						s = CobraCore.toTechString(_args[j+1])
					catch e as Exception
						s = 'ToString() Exception: ' + e.message
					tw.writeLine('<td> [s] </td> </tr>')
				first = true
				for name in _localNamesInOrder
					if name == 'this'
						continue
					label = if(first, 'locals:', '')
					tw.write('<tr class=frameDetails> <td class=indent> &nbsp; </td> <td class=label> [label] </td> <td> [name] </td> <td> &nbsp;=&nbsp; </td>')
					try
						s = CobraCore.toTechString(_locals[name])
					catch e as Exception
						s = 'ToString() Exception: ' + e.message
					tw.writeLine('<td> [s] </td> </tr>')
					first = false
				tw.writeLine('<tr class=blank> <td colspan=4> &nbsp; </td> </tr>')

			def toString as String is override
				return 'def [_declClassName].[_methodName] at line [_lineNum]'

			def copy as CobraFrame
				return .memberwiseClone to CobraFrame

		class FallThroughException
			inherits Exception

			var _info as Object?

			def init
				.init(nil)
				pass

			def init(info as Object?)
				base.init
				_info = info

			def init(info as Object?, innerExc as Exception?)
				base.init(nil, innerExc)
				_info = info

			get message as String is override
				return 'info=[CobraCore.toTechString(_info)]'

			get info as Object?
				return _info

		class DynamicOperationException
			inherits Exception
			"""
			The base class for all dynamic operation exceptions.
			"""

			def init(message as String)
				.init(message, nil)

			def init(message as String, innerExc as Exception?)
				base.init(message, innerExc)

		class UnknownMemberException
			inherits DynamicOperationException

			var _obj as Object
			var _name as String
			var _type as Type

			def init(obj as Object, name as String, type as Type)
				.init(obj, name, type, nil)

			def init(obj as Object, name as String, type as Type, innerExc as Exception?)
				base.init('obj=[CobraCore.toTechString(obj)], name=[CobraCore.toTechString(name)], type=[type]', innerExc)
				_obj = obj
				_name = name
				_type = type

		class CannotReadPropertyException
			inherits UnknownMemberException

			# CC: axe init()s

			def init(obj as Object, name as String, type as Type)
				.init(obj, name, type, nil)

			def init(obj as Object, name as String, type as Type, innerExc as Exception?)
				base.init(obj, name, type, innerExc)

		class CannotWritePropertyException
			inherits UnknownMemberException

			# CC: axe init()s

			def init(obj as Object, name as String, type as Type)
				.init(obj, name, type, nil)

			def init(obj as Object, name as String, type as Type, innerExc as Exception?)
				base.init(obj, name, type, innerExc)

		class CannotSliceTypeException
			inherits UnknownMemberException

			# CC: axe init()s

			def init(obj as Object, name as String, type as Type)
				.init(obj, name, type, nil)

			def init(obj as Object, name as String, type as Type, innerExc as Exception?)
				base.init(obj, name, type, innerExc)

		class CannotInTypeException
			inherits UnknownMemberException

			# CC: axe init()s

			def init(obj as Object, name as String, type as Type)
				.init(obj, name, type, nil)

			def init(obj as Object, name as String, type as Type, innerExc as Exception?)
				base.init(obj, name, type, innerExc)

		class CannotCompareException
			inherits DynamicOperationException

			var _a
			var _b

			def init(a, b)
				.init(a, b, nil)

			def init(a, b, innerExc as Exception?)
				base.init('a=[a], b=[b]', innerExc)
				#base.init('a=[CobraCore.toTechString(a)], a.getType=[a.getType.name], b=[CobraCore.toTechString(b)], b.getType=[b.getType.name]', innerExc)
				_a = a
				_b = b
