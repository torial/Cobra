class Box
	inherits Container
	"""
	The abstract base class for:
		* Class
		* Interface
		* Struct
	These are collectively known as "boxes".
	"""

	# TODO: Box should implement IType

	var _baseInterfaceNodes as List<of INode>
	var _baseInterfaces as List<of Interface>
	var _baseInterfaceTypes as List<of IType>  # can include interfaces and qualified types (containing interfaces)

	var _overloads as List<of MemberOverload>
	var _nextPrivateSerialNumber = 1001

	var _testMethod as TestMethod

	def construct(token as IToken, name as String, docString as String?)
		base.construct(token, name, docString)
		_overloads = List<of MemberOverload>()
		_baseInterfaces = List<of Interface>()
		_baseInterfaceTypes = List<of IType>()

	pro testMethod from var

	def makeNextPrivateSerialNumber as int
		n = _nextPrivateSerialNumber
		_nextPrivateSerialNumber += 1
		return n

	def registerOverload(ol as MemberOverload)
		require
			ol.name
			ol not in _overloads
		code
			_overloads.add(ol)
			_declsByName[ol.name] = ol
			_declsByName[ol.name.toLower()] = ol

	def symbolForName(name as String, canBeMember as bool, haveThis as bool) as IMember?
		"""
		Unlike the inherited declForName(), this method follows the
		inheritance change and provides options for canBeMember and
		haveThis.
		"""
		# TODO: is canBeMember ever false?
		if not canBeMember
			return nil
		x = .declForName(name)
		if x and not haveThis
			if x.requiresThis
				return nil
		return x

	## INamedNode

	get typeForIdentifier as IType is override
		assert .compiler
		return .compiler.typeType

	get typeForReceiver as IType is override
		return this

	## Binding

	def _bindInt is override
		base._bindInt()
		.compiler.boxStack.push(this)
		try
			_bindInterfaces()
			for decl in _declsInOrder
				assert not decl is this, this
				decl.bindInt()
			for ol in _overloads
				ol.bindInt()
		finally
			.compiler.boxStack.pop()

	def _bindInterfaces
		# structs, classes and interfaces can all have 0 or more interfaces they inherit/implement
		assert _baseInterfaceNodes is not nil, this
		for node in _baseInterfaceNodes
			baseWhat = node.bindInt().namedType
			if baseWhat inherits Interface
				_baseInterfaces.add(baseWhat)
				_baseInterfaceTypes.add(baseWhat)
			else if baseWhat inherits QualifiedType
				if baseWhat.theWrappedType inherits Interface
					_baseInterfaces.add(baseWhat.theWrappedType to Interface)
					_baseInterfaceTypes.add(baseWhat)
				else
					_error('Cannot inherit "[baseWhat.theWrappedType.name]" which is a [baseWhat.theWrappedType.englishName].')
			else
				_error('Cannot inherit "[baseWhat.name]" which is a [baseWhat.englishName].')

	def _bindImp is override
		base._bindImp()
		assert .didBindInt
		.compiler.boxStack.push(this)
		try
			for decl in _declsInOrder
				assert not decl is this, this
				decl.bindImp()
			for ol in _overloads
				ol.bindImp()
		finally
			.compiler.boxStack.pop()


class Class
	inherits Box

	var _baseClass as Class?
	var _baseName as String

	def construct(token as IToken, name as String, paramList as List<of INode>, isNames as List<of String>, baseName as String?, implementsNodes as List<of INode>, docString as String?)
		base.construct(token, name, docString)
		_baseName = baseName ? "Object"  # TODO: this would pick up a local object instead of System.Object. Is that what's wanted?
		_baseInterfaceNodes = implementsNodes

	get baseClass from var

	def isAssignableTo(type as IType) as bool is override
		if type is .compiler.passThroughType
			return true
		# TODO:
		# if type inherits WrappedType
		#	return .isAssignableTo(type.wrappedType)
		return .isDescendantOf(type)

	def isDescendantOf(type as IType) as bool is override
		if not type.didBindInt
			type.bindInt()
		curClass as Class? = this  # CC: change to: curClass = this to ?
		while curClass is not nil
			if curClass is type
				return true
			assert curClass is not curClass.baseClass, curClass
			curClass = curClass.baseClass
		# TODO: handle interfaces
		return false

	def memberForName(name as String) as IMember? is override
		assert .didBindInt  # TODO: is this legit? if so, push up to Container
		m = base.memberForName(name)
		if m is nil and _baseClass is not nil
			m = _baseClass.memberForName(name)
		return m

	def symbolForName(name as String, canBeMember as bool, haveThis as bool) as IMember? is override
		"""
		Unlike the inherited declForName(), this method follows the
		inheritance change and provides options for canBeMember and
		haveThis.
		"""
		m = base.symbolForName(name, canBeMember, haveThis)
		if m is nil and _baseClass is not nil
			m = _baseClass.memberForName(name)
		return m

	def _bindInt is override
		# TODO: the following is a fix for SystemInterfaces.cobra.
		# Upon reading mscorlib.dll, this won't be necessary
		if _name=='Object' and .compiler.nameSpaceStack.peek().name=='System'
			assert _baseName=='Object'
			_baseName = ''
		if _baseName
			possible = .compiler.symbolForName(_baseName, false, false)  # should canBeMember be true?
			if possible is nil
				_error('Cannot locate base class named "[_baseName]" for class "[_name]".')
			if possible inherits Class
				_baseClass = possible
			else if possible inherits Interface
				_error('The base "[_baseName]" is an interface. Try "implements" instead of "inherits".')
			else if possible inherits Struct
				_error('The base "[_baseName]" is a struct. Classes cannot inherit from structs.')
			else
				_error('The base class "[_baseName]" is not actually a class, it is a "[possible.englishName]".')
		base._bindInt()

	get englishName as String is override
		return 'class'

	get superType as IType? is override
		assert .didBindInt
		return _baseClass


class Interface
	inherits Box

	def construct(token as IToken, name as String, paramList as List<of INode>, isNames as List<of String>, baseNodes as List<of INode>, docString as String?)
		base.construct(token, name, docString)
		_baseInterfaceNodes = baseNodes

	get englishName as String is override
		return 'interface'

	# TODO: 	def isDescendantOf(type as IType) as bool


class Struct
	inherits Box

	def construct(token as IToken, name as String, paramList as List<of INode>, isNames as List<of String>, baseName as String?, interfaceNodes as List<of INode>, docString as String?)
		base.construct(token, name, docString)
		_baseInterfaceNodes = interfaceNodes

	def _bindInt is override
		base._bindInt()


class ClassMember  # TODO: rename to BoxMember
	inherits NamedNode
	implements IMember

	shared
		var _accessLevels = ['public', 'protected', 'internal', 'protected internal', 'private']
			"""
			The access level names are the same in both Cobra and C#.
			"""

	var _box as Box
	var _docString as String?
	var _isNames as List<of String>?
	var _overloadGroup as MemberOverload?
	var _testMethod as TestMethod?

	def construct(token as IToken, box as Box, name as String)
		this.construct(token, box, name, nil)

	def construct(token as IToken, box as Box, name as String, docString as String?)
		base.construct(token, name)
		_box = box
		_docString = docString

	## Properties

	get box from var

	pro docString from var

	pro isNames from var

	pro overloadGroup from var

	pro testMethod from var

	get isCallable as bool
		return false

	get isShared as bool
		return 'shared' in _isNames

	get englishName as String
		throw OverrideException(.getType())
		return ''

	get defaultAccessLevel as String
		throw OverrideException(.getType())
		return ''

	get hasVariParams as bool
		"""
		Retuns true if the class member takes variable number of arguments.
		"""
		return false

	get hasParams as bool
		"""
		Returns true if the class member has one or more parameters defined.
		"""
		return false

	get params as List<of Param>
		"""
		Returns the list of params of this method, possibly empty.
		Checking hasParams first is recommended since it's more efficient.
		"""
		return List<of Param>()

	get isClassMember as bool
		return _box inherits Class

# TODO:
#	get isInterfaceMember as bool
#		return _box inherits Interface

	get requiresThis as bool
		return not _name.startsWith('_')

	get resultType as IType
		"""
		The result type of the var, method or property.
		"""
		throw OverrideException(.getType())
		return CobraType()

	## Other

	def defaultToVirtual
		"""
		Self utility method.
		"""
		require _isNames is not nil
		for name in ['nonvirtual', 'virtual', 'shared', 'override']
			if name in _isNames
				return
		_isNames.add('virtual')

	## INamedNode

	get typeForIdentifier as IType is override
		assert false, 'not expecting `typeForIdentifier` for a class member'

	get typeForReceiver as IType is override
		return .resultType


	## Binding

	def _bindInt is override
		base._bindInt()
		if _testMethod
			_testMethod.bindInt()

	def _bindImp is override
		base._bindImp()
		assert .didBindInt  # class members should have always received a bindInt first
		if _testMethod
			_testMethod.bindImp()


	## Fields

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)
		.addField('isNames', _isNames)

	def addRefFields is override
		base.addRefFields()
		.addField('classDecl', _box)

	def addSubFields is override
		base.addSubFields()
		.addField('docString', _docString)


class ClassVar
	inherits ClassMember
	implements IVar

	var _typeNode as INode
	var _type as IType?
	var _initExpr as Expr?
	var _ifInheritsStack as Stack<of IType>
	var _useCSNameStack as Stack<of String>

	def construct(token as IToken, box as Box, name as String, typeNode as INode, isNames as List<of String>, initExpr as Expr?, docString as String)
		base.construct(token, box, name, docString)
		_typeNode = typeNode
		_initExpr = initExpr
		_ifInheritsStack = Stack<of IType>()
		_useCSNameStack = Stack<of String>()  # for if-inherits

	get defaultAccessLevel as String is override
		return 'protected'

	def addRefFields is override
		base.addRefFields()
		if _type
			.addField('type', _type)
		else
			.addField('typeNode', _typeNode)

	def addSubFields is override
		base.addSubFields()
		.addField('initExpr', _initExpr)

	# TODO @@@ who calls this and when?
	def symbolForName(name as String, canBeMember as bool) as IMember?
		t as IType? = if(_ifInheritsStack, _ifInheritsStack.peek() to passthrough, _type)  # CC: get rid of cast and 'as'
		return t.memberForName(name)  # TODO is "true" the correct value here?

	get requiresDotPrefix as bool
		return _box is not nil and not _name.startsWith('_')

	def _bindInt is override
		base._bindInt()
		if _initExpr
			_initExpr.bindImp()  # that's bindImp intentionally
			if _type is nil
				_type = _initExpr.type
		if _type is nil
			assert _typeNode, 'typeNode should be set if _type is nil'
			_typeNode.bindInt()
			t = _typeNode.namedType
			t.bindInt()
			assert t, _typeNode
			if _initExpr and not _initExpr.isKindOf(t to IType)  # CC: axe cast when "assert foo" is understood to prove that foo is not nil
				_error('The expression type of [_initExpr.type] does not match the variable type of [t].')
			_type = t
		_type.bindInt()  # TODO: is this needed?

	get resultType as IType is override
		"""
		The result type of the var, method or property.
		"""
		if _type
			return _type to passthrough  # CC: axe cast
		else
			assert false, '_type is nil. this=[this]'

	## INamedNode

	get typeForIdentifier as IType is override
		return .resultType

	## IVar

	pro type as IType?
		get
			return .resultType
		set
			assert false, 'Cannot set the type of a ClassVar.'

	## Code Gen

	get csName as String
		return if(_useCSNameStack, _useCSNameStack.peek(), _name)

	get csAssignmentNames as List<of String>
		return List<of String>(_useCSNameStack)

#	get asCS as String is override  # TODO probably don't need both an asCS() and csName (above)
#		return .csName

#	def genCS(out)
#		out.write('%s%s %s' % (_isNamesCS(), _type.asCS(), _name))
#		if _initExpr
#			out.write(' = ')
#			_initExpr.genCS(out)
#		out.write(';\n')


interface ICodePart
	"""
	A code part responds to addStmt(stmt).

	It is the common interface to:
		- methods
		- inits (special methods)
		- property getter
		- property setter
		- nested method
		- anonymous method
	"""

	def addStmt(stmt as Stmt)

	def addLocal(local as LocalVar)

	def findLocal(name as String) as AbstractLocalVar?

	def findLocalCI(name as String) as AbstractLocalVar?



class OneCodeBlockMember
	inherits ClassMember
	implements ICodePart
	"""
	The abstract ancestor class for
		Constructor
		Method
		PropertyXetter

	But not for Property (which has two code blocks "get" and "set"),
	or other class decls like variables.

	Subclasses must set _params.
	"""

	var _returnTypeNode as INode
	var _returnType as IType?
	var _requirePart as Node?  # TODO: narrow
	var _ensurePart as Node?  # TODO: narrow
	var _oldExprs as List<of Expr>  # TODO: add a doc string for this
	var _params as List<of Param>
	var _locals as List<of LocalVar>
	var _stmts as List<of Stmt>
	var _csResultVarName as String?

	def construct(token as IToken, box as Box, name as String, docString as String, paramsList as List<of Param>)
		base.construct(token, box, name, docString)
		_params = paramsList
		_oldExprs = List<of Expr>()
		_locals = List<of LocalVar>()
		_stmts = List<of Stmt>()

	get hasParams as bool is override
		return _params.count > 0

	get params as List<of Param> is override
		return _params

	get defaultAccessLevel as String is override
		return 'public'

	get isCallable as bool is override
		return true

	def addStmt(stmt as Stmt)
		_stmts.add(stmt)

	get resultType as IType is override
		require
			.didBindInt
			_returnType!
		code
			return _returnType to IType  # CC: to !

	def findLocal(name as String) as AbstractLocalVar?  # TODO: narrow to common base of Param and LocalVar
		# TODO: does it really matter if a the symbols are traversed in reverse order?
		# TODO: should this use a dictionary lookup?
		i = _locals.count - 1
		while i>=0
			if _locals[i].name==name
				return _locals[i]
			i -= 1
		for param in _params
			if param.name==name
				return param
		return nil

	def findLocalCI(name as String) as AbstractLocalVar?
		name = name.toLower()
		# TODO: does it really matter if a the symbols are traversed in reverse order?
		# TODO: should this use a dictionary lookup?
		i = _locals.count - 1
		while i>=0
			if _locals[i].name.toLower()==name
				return _locals[i]
			i -= 1
		for param in _params
			if param.name.toLower()==name
				return param
		return nil

	def addLocal(local as LocalVar)
		require
			local.name
			.findLocal(local.name) is nil  # TODO: , 'symbol=[symbol], symbolForName=[.symbolForName(symbol.name)]'
		code
			other = .findLocalCI(local.name)
			if other!
				_error('Parameters and locals must vary by more than just their case. Change "[local.name]" or "[other.name]" to match, or rename one of them to something different.')
			local.isTracked = true
			_locals.add(local)

#	def dumpName(out)
#		name = getattr('name', '(noname)')
#		returnType = getattr('returnType', '(no return type)')
#		while iscallable(returnType)
#			returnType = returnType()
#		out.write('%s as %s  (%s)\n' % (name, returnType, .className))

# TODO: is pushName() needed?
#	def pushName(var)
#		.addSymbol(var)

#	def dumpNames(out)
#		out.write('%s\n' % .__class__.__name__)
#		out.indent()
#		for param in .params
#			param.dumpName(out)
#		for name in .names
#			name.dumpName(out)
#		out.dedent()

	def addOldExpr(oldExpr as Expr)  # TODO: can this be narrowed to OldExrp?
		_oldExprs.add(oldExpr)
# TODO:		oldExpr.csVarName = '_lh_old_' + _oldExprs.count.toString()

	def addRefFields is override
		base.addRefFields()
		.addField('returnTypeNode', _returnTypeNode)
		.addField('returnType', _returnType)

	def addSubFields is override
		base.addSubFields()
		.addField('params', _params)
		.addField('locals', _locals)
		.addField('stmts', _stmts)

	def _bindInt is override
		base._bindInt()
		.compiler.codeMemberStack.push(this)
		for param in _params
			param.bindInt()
		if _returnType is nil
			if _returnTypeNode is nil
				_returnType = .compiler.voidType
			else
				_returnTypeNode.bindInt()
				_returnType = _returnTypeNode.namedType
			assert _returnType, _returnTypeNode
		if _requirePart
			_requirePart.bindInt()
		if _ensurePart
			_ensurePart.bindInt()
		.compiler.codeMemberStack.pop()

	def _bindImp is override
		base._bindImp()
		.compiler.codeMemberStack.push(this)
		for param in _params
			param.bindImp()
		for local in _locals
			local.bindImp()
		# TODO re-enable the assertion below
		#assert compiler.opStack.count==0, repr(compiler.opStack._items)
		if _requirePart
			_requirePart.bindImp()
		if _ensurePart and _returnType is not nil and _returnType is not .compiler.voidType
			_csResultVarName = '_lh_result_[_box.makeNextPrivateSerialNumber()]'
		else
			_csResultVarName = nil
		for stmt in _stmts
			stmt.bindImp()
		if _ensurePart
			_ensurePart.bindImp()
		.compiler.codeMemberStack.pop()

#	def genCSLocals(out, locals=nil, open=true)
#		if open
#			out.writeAndIndent('{\n')
#		# record the `old` expressions in `ensure`
#		for oldExpr in .oldExprs
#			oldExpr.genCSAssignment(out)
#		if locals is nil
#			locals = .names
#		if locals
#			out.write('// locals\n')
#			for var in locals
#				if not var.isImplicit
#					init = var.type.csInit()
#					if init is nil
#						out.write('%s %s;\n' % (var.type.asCS(), var.name))
#					else
#						out.write('%s %s = %s;\n' % (var.type.asCS(), var.name, init))

#	def genCSParamCheck(param, out)
#		from Expressions import Param
#		assert inherits(param, Param)
#		if param.type.isReference and not inherits(param.type, NilableType)
#			out.write('if (%s==null) throw new ArgumentNullException("%s");\n' % (
#				param.name, param.name))
#			# TODO axe the code below or above
#			#out.write('if (%s==null) throw new ArgumentNullException("%s", string.Format("Object reference \\"%s\\" not set to an instance of an object."));\n' % (
#			#	param.name, param.name, param.name))

#	def genCSImp(out, skipFirst=false)
#		out.writeAndIndent('{\n')
#		if .compiler.hasSuperStackTraceOption
#			.genSSTHead(out)
#		for param in .params
#			.genCSParamCheck(param, out)
#		if .requirePart
#			.requirePart.genCS(out)
#		.genCSLocals(out, open=false)
#		if .ensurePart
#			if .csResultVarName  # set in _bindImp
#				out.write('%s %s = %s;\n' % (.returnType.asCS(), .csResultVarName, .returnType.csInit()))
#			out.writeAndIndent('try {\n')
#		.block.genCS(out, open=false, close=false, skipFirst=skipFirst)
#		if .ensurePart
#			out.dedentAndWrite('} finally { // ensure\n')
#			out.indent()
#			.ensurePart.genCS(out)
#			out.dedentAndWrite('}\n')
#		if .compiler.hasSuperStackTraceOption
#			.genSSTTail(out)
#		out.dedent()
#		out.write('}\n')
#		out.write('\n')

#	def genSSTHead(out)
#		out.write('CobraImp.PushFrame("%s", "%s"' % (.box.name, .name))
#		if not .isShared
#			out.write(', "this", this')
#		for param in .params
#			out.write(', "%s", %s' % (param.name, param.name))
#		out.write(');\n')
#		out.write('CobraImp.SetLine(%s);\n' % .token.lineNum)
#		out.writeAndIndent('try {\n')

#	def genSSTTail(out)
#		out.dedentAndWrite('} catch {\n')
#		out.indent()
#		out.write('CobraImp.CaughtUncaughtException();\n')
#		out.write('throw;\n')
#		out.dedentAndWrite('} finally {\n')
#		out.indent()
#		out.write('CobraImp.PopFrame();\n')
#		out.dedentAndWrite('}\n')


class Method
	inherits OneCodeBlockMember
	implements ICodePart

	var _implementsList as List<of INode>

	def construct(token as IToken, box as Box, name as String, paramsList as List<of Param>, returnTypeNode as INode, isNames as List<of String>, implementsList as List<of INode>, docString as String)
		base.construct(token, box, name, docString, paramsList)
		_returnTypeNode = returnTypeNode
		_isNames = isNames
		_implementsList = implementsList
		_stmts = List<of Stmt>()

	get englishName as String is override
		return 'method'

	get hasVariArgs as bool
		print 'TODO: complete Method.hasVariArgs'
		return false

	get isCallable as bool is override
		return true

	def addSubFields is override
		base.addSubFields()
		if _implementsList
			.addField('implementsList', _implementsList)

	def defaultToVirtual is override
		if .isClassMember and not _implementsList
			base.defaultToVirtual()


class ProperDexer
	inherits ClassMember
	"""
	The abstract base class for Property and Indexer.

	This captures some of the common interface between them--whatever happens to be needed
	(currenty by the parser only).

	Why not do an IProperDexer interface? Because it wouldn't be compatible with a ClassMember
	unless we also defined an IClassMember.
	"""

	def construct(token as IToken, box as Box, name as String, docString as String)
		base.construct(token, box, name, docString)

	def makeGetPart(token as IToken) as OneCodeBlockMember
		throw OverrideException()
		# CC: shouldn't need a return:
		return OneCodeBlockMember(token, Box(token, '', ''), '', '', List<of Param>())

	def makeSetPart(token as IToken) as OneCodeBlockMember
		throw OverrideException()
		# CC: shouldn't need a return:
		return OneCodeBlockMember(token, Box(token, '', ''), '', '', List<of Param>())


class MemberOverload
	inherits ClassMember

	var _members as List<of ClassMember>

	def construct(member as ClassMember)
		require
			member.name
			member.box
		code
			base.construct(member.token, member.box, member.name)
			_members = List<of ClassMember>()
			_isNames = member.isNames  # pick up 'shared' for example
			.addMember(member)

	def addSubFields is override
		base.addSubFields()
		.addField('members', _members)

	get members from var

	get englishName as String is override
		assert _members
		return _members[0].englishName

	get isCallable as bool is override
		assert _members
		return _members[0].isCallable

	def addMember(member as ClassMember)
		require
			member is not this
			not member inherits MemberOverload
			member.overloadGroup is nil
			member.name==.name # CC:, '.name=[.name], member.name=[member.name]'
			.members implies member not in .members # CC: , member
			.members implies member.getType() is .members[0].getType()
		code
			member.overloadGroup = this
			_members.add(member)

	get resultType as IType? is override
		assert .didBindInt
		assert _members[0] is not this
		return _members[0].resultType

	def _bindInt is override
		base._bindInt()
		# rename the test members of the overload by suffixing them with '_o1' '_o2' etc.
		i = 1
# TODO:
#		for member in _members
#			if member.testMethod
#				member.testMethod.name = member.testMethod.name + '_ol' + i.toString()
#			i += 1
		# TODO: error if the returnType is different among any members
		# TODO: error if the two members have the same arguments

	def _bindImp is override
		base._bindImp()


class TestMethod
	inherits Method
	"""
	TODO: It's weird that you have to pass voidType. Maybe Node should have a shared typeProvider
	like it has a shared compiler. The parser could set it.
	"""

	var _forMember as ClassMember?
	var _forBox as Box?

	def construct(token as IToken, member as ClassMember, voidType as IType)
		require
			member.box
			member.name
		code
			# CC: shouldn't the .getCompiler() work? C# code gen puts a "this" in there even though it's shared and C# chokes on it
			#base.construct(token, member.box, 'test_'+Utils.capped(member.name), List<of Param>(), .getCompiler().voidType, List<of String>(), List<of INode>(), '')
			base.construct(token, member.box, 'test_'+Utils.capped(member.name), List<of Param>(), voidType, List<of String>(), List<of INode>(), '')
			_forMember = member

	def construct(token as IToken, box as Box, voidType as IType)
		require
			box.name
		code
			# CC: shouldn't the .getCompiler() work? C# code gen puts a "this" in there even though it's shared and C# chokes on it
			# base.construct(token, box, 'test_class_'+Utils.capped(box.name), List<of Param>(), .getCompiler().voidType, List<of String>(), List<of INode>(), '')
			base.construct(token, box, 'test_class_'+Utils.capped(box.name), List<of Param>(), voidType, List<of String>(), List<of INode>(), '')
			_forBox = box


## TODO: Move the below items to Vars.cobra. Put IVar in there too.

class AbstractLocalVar
	inherits NamedNode
	implements IVar
	"""
	The base class for Param and LocalVar.
	"""

	var _type as IType?
	var _typeNode as INode?
	var _isImplicit as bool
	var _isTracked as bool
	var _ifInheritsStack = Stack<of IType>()
	var _useCSNameStack = Stack<of String>()  # for if-inherits

	def construct(token as IToken, type as IType, isImplicit as bool)
		base.construct(token, token.text)
		_type = type
		_isImplicit = isImplicit
		_isTracked = false

	def construct(token as IToken, typeNode as INode, isImplicit as bool)
		base.construct(token, token.text)
		_typeNode = typeNode
		_isImplicit = isImplicit
		_isTracked = false

	pro isTracked from var

#	def addMinFields is override
#		base.addMinFields()
#		.addMinField('name', .name)
#		if .isImplicit
#			.addMinField('isImplicit', .isImplicit)

	def toString as String is override
		type = if(_type, .type.name, "(no type)")
		return '[.getType().name]([.serialNum], [.token], [.name], [type])'

# TODO
#	def symbolForName(name, canBeMember=false)
#		t = .ifInheritsStack and .ifInheritsStack.peek() or .type
#		return t.symbolForName(name, true)  # TODO is "true" the correct value here?

#	def dumpName(out)
#		out.write('%s as %s  (%s)\n' % (.name, .type.name, .__class__.__name__))

	def _bindInt is override
		base._bindInt()
		_resolveType()

	def _bindImp is override
		base._bindImp()
		_resolveType()

	def _resolveType
		require _type! or _typeNode!
		if _type!
			return
		if _typeNode inherits IType
			_type = _typeNode to passthrough   # CC: shouldn't need the cast here
			return
		_type = _typeNode.bindAll().namedType
		if _type is nil
			_error('Cannot resolve type.')  # TODO: add the name of the wrappedTypeNode or something

	pro type as IType
		get
			require _type
			return if(_ifInheritsStack, _ifInheritsStack.peek(), _type to IType)  # CC: change last "to IType" to "to !" or make if() smarter
		set
			assert _type is nil  # TODO: in [nil, tpassthrough, tunknown)
			assert not _ifInheritsStack
			_type = value

	get typeNode from var

	get typeForIdentifier as IType is override
		return .type

	get typeForReceiver as IType is override
		return .type

	def csAssignmentNames as List<of String>
		return List<of String>(_useCSNameStack)

	get csName as String
		return if(_useCSNameStack, _useCSNameStack.peek(), .name)



class Param
	inherits AbstractLocalVar

	def construct(token as IToken, type as IType)
		.construct(token, type, false)

	def construct(token as IToken, typeNode as INode)
		.construct(token, typeNode, false)

	def construct(token as IToken, type as IType, isImplicit as bool)
		base.construct(token, type, isImplicit)

	def construct(token as IToken, typeNode as INode, isImplicit as bool)
		base.construct(token, typeNode, isImplicit)

# TODO
#	def genCS(out)
#		out.write('%s %s' % (.type.asCS(), .name))


class LocalVar
	inherits AbstractLocalVar

	def construct(token as IToken, type as IType)
		.construct(token, type, false)

	def construct(token as IToken, typeNode as INode)
		.construct(token, typeNode, false)

	def construct(token as IToken, type as IType, isImplicit as bool)
		base.construct(token, type as IType, isImplicit)

	def construct(token as IToken, typeNode as INode, isImplicit as bool)
		base.construct(token, typeNode, isImplicit)

	def addMinFields is override
		base.addMinFields()
		.addField('isTracked', _isTracked)


class ResultVar
	inherits LocalVar
	"""
	The implicit variable `result` used in `ensure` blocks.
	"""

	def construct(codeMember as ClassMember)
		base.construct(_makeToken(codeMember), codeMember.resultType, true)

	def _makeToken(codeMember as ClassMember) as IToken is shared
		token = codeMember.token.copy
		token.text = 'result'
		return token

	#._asCS = codeMember.csResultVarName

# TODO
#	def asCS
#		return ._asCS
