class Box
	inherits NamedNode
	"""
	The abstract base class for:
		* Class
		* Interface
		* Struct
	These are collectively known as "boxes".
	"""

	var _declsInOrder as List<of Node>  # TODO: can the inner list type be narrowed more? say to IClassMemberDecl or ClassMemberDecl

	def construct(token as IToken, name as String)
		base.construct(token, name)
		_declsInOrder = List<of Node>()

	get declsInOrder from var

	def addDecl(decl as Node)
		_declsInOrder.add(decl)

	get englishName as String
		"""
		Return the specific name of this type of box: class, interface, struct.
		"""
		return ''

	def addSubFields is override
		base.addSubFields()
		.addField('declsInOrder', _declsInOrder)


class Class
	inherits Box

	def construct(token as IToken, name as String, paramList as List<of Node>, isNames as List<of String>, baseName as String?, interfaceNames as List<of String>, docString as String?)
		base.construct(token, name)

	get englishName as String is override
		return 'class'


class Interface
	inherits Box

	def construct(token as IToken, name as String, paramList as List<of Node>, isNames as List<of String>, baseName as String?, interfaceNames as List<of String>, docString as String?)
		base.construct(token, name)

	get englishName as String is override
		return 'interface'


class ClassMember
	inherits NamedNode

	var _box as Box

	def construct(token as IToken, box as Box, name as String)
		base.construct(token, name)
		_box = box

	get englishName as String
		throw OverrideException()
		return ''

	get hasVariParams as bool
		"""
		Retuns true if the class member takes variable number of arguments.
		"""
		return false

	get hasParams as bool
		"""
		Returns true if the class member has one or more parameters defined.
		"""
		return false

	get params as List<of Param>
		"""
		Returns the list of params of this method, possibly empty.
		Checking hasParams first is recommended since it's more efficient.
		"""
		return List<of Param>()

	get isCallable as bool
		throw OverrideException()
		return false

	get resultType as IType
		"""
		The result type of the var, method or property.
		"""
		throw OverrideException()
		return CobraType()


interface ICodePart
	"""
	The common interface to:
		- methods
		- inits (special methods)
		- property getter
		- property setter
		- nested method
		- anonymous method
	"""

	def addStmt(stmt as Stmt)



class Method
	inherits ClassMember
	implements ICodePart

	var _params as List<of Param>
	var _returnTypeNode as Node
	var _returnType as IType?
	var _isNames as List<of String>
	var _implementsList as List<of Node>
	var _docString as String
	var _stmts as List<of Stmt>

	def construct(token as IToken, box as Box, name as String, paramsList as List<of Param>, returnTypeNode as Node, isNames as List<of String>, implementsList as List<of Node>, docString as String)
		base.construct(token, box, name)
		_params = paramsList
		_returnTypeNode = returnTypeNode
		_isNames = isNames
		_implementsList = implementsList
		_docString = docString
		_stmts = List<of Stmt>()

	def addStmt(stmt as Stmt)
		_stmts.add(stmt)

	get englishName as String is override
		return 'method'

	get hasVariArgs as bool
		print 'TODO: complete Method.hasVariArgs'
		return false

	get isCallable as bool is override
		return true

	get resultType as IType is override
		require
			.didBindInt
			_returnType!
		code
			return _returnType to IType  # CC: to !

	def addMinFields is override
		base.addMinFields()
		.addField('isNames', '_isNames')

	def addRefFields is override
		base.addRefFields()
		.addField('returnTypeNode', _returnTypeNode)
		.addField('returnType', _returnType)

	def addSubFields is override
		base.addSubFields()
		.addField('params', _params)
		if _implementsList
			.addField('implementsList', _implementsList)
		.addField('docString', _docString)
		.addField('stmts', _stmts)


class MemberOverload
	inherits ClassMember

	def construct(box as Box, name as String)
		base.construct(TokenFix.empty, box, name)


class AbstractLocalVar
	inherits NamedNode

	var _type as IType
	var _isImplicit as bool
	var _isTracked as bool
	var _ifInheritsStack = Stack<of IType>()
	var _useCSNameStack = Stack<of String>()  # for if-inherits

	def construct(token as IToken, type as IType, isImplicit as bool)
		base.construct(token, token.text)
		_type = type
		_isImplicit = isImplicit
		_isTracked = false

#	def addMinFields
#		base.addMinFields()
#		.addMinField('name', .name)
#		if .isImplicit
#			.addMinField('isImplicit', .isImplicit)

	def toString as String is override
		type = if(.type, .type.name, "(no type)")
		return '[.getType().name]([.serialNum], [.token], [.name], [type])'

# TODO
#	def symbolForName(name, canBeMember=false)
#		t = .ifInheritsStack and .ifInheritsStack.peek() or .type
#		return t.symbolForName(name, true)  # TODO is "true" the correct value here?

#	def dumpName(out)
#		out.write('%s as %s  (%s)\n' % (.name, .type.name, .__class__.__name__))

	def _bindInt is override
		base._bindInt()
		_type.bindInt()

	def _bindImp is override
		base._bindImp()
		_type.bindImp()
# TODO		_type = _type.namedType

	pro type as IType
		get
			return if(_ifInheritsStack, _ifInheritsStack.peek() to IType, _type)  # CC: axe to IType
		set
			assert _type is nil  # TODO: in [nil, tpassthrough, tunknown)
			assert not _ifInheritsStack
			_type = value

	def csAssignmentNames as List<of String>
		return List<of String>(_useCSNameStack)

	get csName as String
		return if(_useCSNameStack, _useCSNameStack.peek() to String, .name)  # CC: axe to String



class Param
	inherits AbstractLocalVar

	def construct(token as IToken, type as IType, isImplicit as bool)
		base.construct(token, type, isImplicit)

# TODO
#	def genCS(out)
#		out.write('%s %s' % (.type.asCS(), .name))


class LocalVar
	inherits AbstractLocalVar

	def construct(token as IToken, type as IType)
		.construct(token, type, false)

	def construct(token as IToken, type as IType, isImplicit as bool)
		base.construct(token, type as IType, isImplicit)


class ResultVar
	inherits LocalVar
	"""
	The implicit variable `result` used in `ensure` blocks.
	"""

	def construct(codeMember as ClassMember)
		base.construct(_makeToken(codeMember), codeMember.resultType, true)

	def _makeToken(codeMember as ClassMember) as IToken is shared
		token = codeMember.token.copy
		token.text = 'result'
		return token

	#._asCS = codeMember.csResultVarName

# TODO
#	def asCS
#		return ._asCS
