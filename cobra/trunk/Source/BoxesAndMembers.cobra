class Box
	inherits Container
	"""
	The abstract base class for:
		* Class
		* Interface
		* Struct
	These are collectively known as "boxes".
	"""

	# TODO: need to override greatestCommonDenominatorWith() to handle base interfaces

	var _params as List<of IType>  # as in generic parameters
	var _constructedTypes as Dictionary<of String, IType>?

	var _baseInterfaceNodes as List<of INode>
	var _baseInterfaces as List<of Interface>
	var _baseInterfaceTypes as List<of IType>  # can include interfaces and qualified types (containing interfaces) TODO: another example of why QualifiedType should be replaced by TypeIdentifier

	var _isNames as List<of String>

	var _overloads as List<of MemberOverload>
	var _nextPrivateSerialNumber = 1001

	var _testMethod as TestMethod


	def construct
		base.construct(TokenFix.empty, 'x', '')
		assert false, 'CC: remove this constructor when unnecessary return statements can be removed'

	def construct(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, docString as String?)
		base.construct(token, name, docString)
		_params = paramList
		for i = 0 .. _params.count
			p = _params[i]
			if p inherits GenericParam
				p.index = i
		_baseInterfaces = List<of Interface>()
		_baseInterfaceTypes = List<of IType>()
		_isNames = isNames
		_overloads = List<of MemberOverload>()

	def addMinFields is override
		base.addMinFields()
		.addField('isGeneric', .isGeneric)
		.addField('isGenericDef', .isGenericDef)

	def addSubFields is override
		base.addSubFields()
		.addField('params', _params)
		if _baseInterfaces
			.addField('baseInterfaces', _baseInterfaces)
		else
			.addField('baseInterfaceNodes', _baseInterfaceNodes)

	get overloads from var

	get rootName as String
		name = .name
		if name.indexOf('<')<>-1  # List<of>, Dictionary<of,>
			name = name.substring(0, name.indexOf('<'))
		return name

	pro testMethod from var

	get isFake as bool
		return 'fake' in _isNames

	get params from var

	def isDescendantOfInterface(inter as Interface) as bool
		if this is inter
			return true
		if this.serialNum is inter.serialNum
			# TODO: how in the hell do we get here instead of of the above "this is inter" kicking in? Looks like a bug to me.
			return true
		assert .didBindInt
		for bit in _baseInterfaces
			if bit.isDescendantOfInterface(inter)
				return true
		return false

	def interfaceMemberForName(name as String) as IMember?
		m = .declForName(name)
		if m is not nil
			return m
		for inter in _baseInterfaces
			m = inter.interfaceMemberForName(name)
			if m is not nil
				break
		return m

	def makeNextPrivateSerialNumber as int
		n = _nextPrivateSerialNumber
		_nextPrivateSerialNumber += 1
		return n

	def registerOverload(ol as MemberOverload)
		require
			ol.name
			ol not in _overloads
		code
			_overloads.add(ol)
			_declsByName[ol.name] = ol
			_declsByName[ol.name.toLower()] = ol

	def addDeclFromOverload(decl as IMember, ol as MemberOverload)
		require
			ol in .overloads
			decl.name == ol.name
		code
			_declsInOrder.add(decl)

	def paramForName(name as String) as IType?
		# TODO: make faster
		for param in _params
			if name==param.name
				return param
		return nil

	def symbolForName(name as String, canBeMember as bool, haveThis as bool) as IMember?
		"""
		Unlike the inherited declForName(), this method follows the
		inheritance change and provides options for canBeMember and
		haveThis.
		"""
		# TODO: is canBeMember ever false?
		if not canBeMember
			return nil
		if name==_name
			return this
		p = .paramForName(name)
		if p
			if haveThis
				_error('Cannot refer to a generic parameter ("[name]") through `this`.')
			else
				return p
		x = .declForName(name)
		if x and not haveThis
			if x.requiresThis
				return nil
		return x

	## INamedNode

	get typeForIdentifier as IType is override
		assert .compiler
		# return .compiler.typeType
		t = .compiler.libraryType('System', 'Type')
		assert t is not nil
		return t

	get typeForReceiver as IType is override
		return this

	## IType

	def indexType(argTypes as List<of IType>) as IType? is override
		"""
		Used by the IndexExpr to determine its type.
		"""
		indexer = .memberForName(r'[]')

		# TODO: check argTypes
		if indexer
			t = indexer.resultType
			if t inherits GenericParam
				return .typeForGenericParam(t)
			else
				return t
		if .isGeneric
			return .innerType
		return nil

	get innerType as IType? is override
		getEnum = .symbolForName('getEnumerator', true, true)
		if getEnum
			assert getEnum.didBindInt
			rt = getEnum.resultType
			if rt is .compiler.passThroughType
				return rt
			if rt.isGeneric
				# assert not rt.isGenericDef
				if rt inherits Box
					it = rt.params[0]
					if it inherits GenericParam
						#it = .typeForGenericParam(it) # CC: this fails because IType on the right is more general than GenericParam on the left. But I'm thinking Cobra should allow you to back up to the original type if you like
						return .typeForGenericParam(it)
					else
						return it
				else
					assert false, 'finish me'  # TODO
			else
				if rt is .compiler.libraryType('System', 'Collections', 'IEnumerator')
					return .compiler.libraryType('System', 'Object')
				else
					assert false, 'finish me'  # TODO
		return nil

	## Binding

	def _bindInt is override
		base._bindInt()
		.compiler.boxStack.push(this)
		try
			_bindInterfaces()
			for param in _params
				param.bindInt()
			for decl in _declsInOrder
				assert not decl is this, this
				decl.bindInt()
			for ol in _overloads
				ol.bindInt()
			if _testMethod
				_testMethod.bindInt()
		finally
			.compiler.boxStack.pop()

	def _bindInterfaces
		# structs, classes and interfaces can all have 0 or more interfaces they inherit/implement
		assert _baseInterfaceNodes is not nil, this
		for node in _baseInterfaceNodes
			baseWhat = node.bindInt().namedType
			# TODO: strongly consider getting rid of QualifiedType and using TypeIdentifier in its place
			if baseWhat inherits QualifiedType
				baseWhat.bindInt()
			if baseWhat is nil
				assert false, 'When does this happen?'
				_error('Cannot locate [node].')
			else if baseWhat inherits Interface
				_baseInterfaces.add(baseWhat)
				_baseInterfaceTypes.add(baseWhat)
			else if baseWhat inherits QualifiedType
				if baseWhat.theWrappedType inherits Interface
					_baseInterfaces.add(baseWhat.theWrappedType to Interface)
					_baseInterfaceTypes.add(baseWhat)
				else
					assert baseWhat.theWrappedType<>nil, baseWhat.toTechString()
					_error('Cannot inherit "[baseWhat.theWrappedType.name]" which is a [baseWhat.theWrappedType.englishName].')
			else
				_badInterfaceError(baseWhat to IType)  # CC: axe type cast

	def _badInterfaceError(type as IType)
		_error('Cannot inherit "[type.name]" which is a [type.englishName].')

	def _bindImp is override
		base._bindImp()
		assert .didBindInt
		.compiler.boxStack.push(this)
		try
			for decl in _declsInOrder
				assert not decl is this, this
				decl.bindImp()
			for ol in _overloads
				ol.bindImp()
			if _testMethod
				_testMethod.bindImp()
		finally
			.compiler.boxStack.pop()

	## Generics

	get isGenericDef as bool is override
		# TODO: make this more efficient, maybe be computing in the constructor
		if _params
			for param in _params
				if not param inherits GenericParam
					return false
			return true
		else
			return false

	get isGeneric as bool is override
		return _params.count>0

	get genericParams as List<of IType> is override
		require .isGeneric
		return _params

	def constructedTypeFor(typeArgs as List<of IType>) as IType is override
		require  # TODO: inherit this from the interface instead
			.isGenericDef
			typeArgs.count==.params.count
		code
			if _constructedTypes is nil
				_constructedTypes = Dictionary<of String, IType>()

			# CC: rewrite code below as:
			# key = Utils.join(',', for type in typeArgs give type.name)
			# key = for type in typeArgs get type.name joined by ','
			names = List<of String>()
			for type in typeArgs
				names.add(type.name)
			key = Utils.join(',', names)

			c = _constructedTypes to Dictionary<of String, IType>  # CC: axe this. it works around a bug

			if _constructedTypes.containsKey(key)
				# CC: return _contructedTypes[key]
				return c[key]

			t = .memberwiseClone() to Box
			t.cloneCollections()
			for i = 0 .. typeArgs.count
				#t.params[i] = typeArgs[i]
				$sharp(r't.Params[i] = typeArgs[i]')
			# TODO: should be cloning the declarations to also incorporate the typeArgs where they happen to refer to generic params
			# CC: _contructedTypes[key] = t
			c[key] = t
			return t

	def cloneCollections is override
		base.cloneCollections()
		_params = List<of IType>(_params)  # TODO: Can I just say _params.clone? Do I need the cast?
		if _constructedTypes<>nil
			# CC: _constructedTypes = Dictionary<of String, IType>(_constructedTypes)
			orig as Dictionary<of String, IType>?
			$sharp('orig = _constructedTypes;')
			$sharp(r'_constructedTypes = new Dictionary<String, IType>();')
			for key as String in orig.keys  # CC: shouldn't need "as String"
				$sharp(r'_constructedTypes[key] = orig[key];')
		_baseInterfaceNodes = List<of INode>(_baseInterfaceNodes)
		_baseInterfaces = List<of Interface>(_baseInterfaces)
		_baseInterfaceTypes = List<of IType>(_baseInterfaceTypes)
		_overloads = List<of MemberOverload>(_overloads)

	def typeForGenericParam(gp as GenericParam) as IType # TODO: is this needed for NilableType?
		"""
		Returns the specific type arg that corresponds to the given generic
		parameter. Used to match the gp's in method, properties, etc. against
		the actual types in a constructed type.
		"""
		require
			.isGeneric
			.params
		code
			return .params[gp.index]

	## Code gen

	get sharpKeyWord as String
		throw OverrideException(.getType())

	def writeSharpRef(sw as SharpWriter) is override
		if _params
			# generic
			name = .rootName
			sw.write(name)
			sw.write('<')
			sep = ''
			for param in _params
				sw.write(sep)
				param.writeSharpRef(sw)
				sep = ', '
			sw.write('>')
		else
			sw.write(.name)

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		if .isFake
			return
		sw.write('[.sharpKeyWord] [.rootName]')
		if _params
			sw.write('<')
			sep = ''
			for param in _params
				sw.write(sep)
				param.writeSharpDef(sw)
				sep = ', '
			sw.write('>')

		.writeSharpInheritance(sw)

		sep = ''
		for inter in _baseInterfaces
			sw.write(sep)
			inter.writeSharpRef(sw)
			sep = ', '

		if _params
			sw.indent()
			for param in _params
				if param inherits GenericParam
					param.writeSharpConstraint(sw)
			sw.dedent()

		sw.writeAndIndent('{\n')
		if _testMethod
			_testMethod.writeSharpDef(sw)
		for decl in _declsInOrder
			decl.writeSharpDef(sw)
		.writeSharpTest(sw)
		sw.dedentAndWrite('} // [.sharpKeyWord] [.name]\n')
		sw.write('\n')

	def writeSharpInheritance(sw as SharpWriter)
		"""
		Class uses this to write its base class declaration.
		No box uses this to write interface implementation--that's handled in the Box class.
		"""
		pass

	def writeSharpTest(sw as SharpWriter)
		sw.write('\nstatic [.rootName]() { RunTestsIfNeeded(); }\n')
		sw.write('\nprivate static bool __didStartTests = false;\n')
		newWord = .newForSharpTest
		sw.write('\npublic static[newWord] void RunTestsIfNeeded() { if (!__didStartTests) RunTests(); }\n')
		sw.write('\npublic static[newWord] void RunTests()')
		sw.writeAndIndent(' {\n')
		sw.write('__didStartTests = true;\n')
		sw.write('CobraImp.TestBegan("[.name]");\n')
		if _testMethod
			sw.write('[_testMethod.sharpName]();\n')
		for decl in _declsInOrder
			decl.writeSharpTestInvocation(sw)
		sw.write('CobraImp.TestEnded("[.name]");\n')
		sw.dedentAndWrite('}\n')

	def writeSharpTestInvocation(sw as SharpWriter) is override
		# used by the test option
		if not .isFake
			sw.write('\t\t[.rootName].RunTestsIfNeeded();\n')

	get newForSharpTest as String
		return ''


class Class
	inherits Box

	var _baseClass as Class?
	var _baseNode as INode?

	def construct(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, baseNode as INode?, implementsNodes as List<of INode>, docString as String?)
		base.construct(token, name, paramList, isNames, docString)
		_baseNode = baseNode
		_baseInterfaceNodes = implementsNodes

	def addRefFields is override
		base.addRefFields()
		.addField('baseClass', _baseClass)

	def addSubFields is override
		base.addSubFields()
		.addField('baseNode', _baseNode)

	get baseClass from var

	def isDescendantOf(type as IType) as bool is override
		if not type.didBindInt
			type.bindInt()
		if this is type
			return true
		if type inherits Interface
			if .isDescendantOfInterface(type)
				return true
		assert .baseClass is not this, this  # check for direct cycles
		if .baseClass<>nil
			return .baseClass.isDescendantOf(type)
		else
			return false

	get isReference as bool is override
		return true

	def memberForName(name as String) as IMember? is override
		# the next assertion fails for Tests\600-misc\404-implement-IEnumerable
		# could not fix. I'm confused. Something to do with generics. So bail on generics:
		# asserting .didBindInt is difficult because memberForName() gets invoked during bindInt
		# if not .isGeneric
		# 	assert .didBindInt  # TODO: is this legit? if so, push up to Container
		m = base.memberForName(name)
		if m is nil and _baseClass is not nil
			m = _baseClass.memberForName(name)
		if m is nil
			m = .interfaceMemberForName(name)
		return m

	def symbolForName(name as String, canBeMember as bool, haveThis as bool) as IMember? is override
		"""
		Unlike the inherited declForName(), this method follows the
		inheritance change and provides options for canBeMember and
		haveThis.
		"""
		m = base.symbolForName(name, canBeMember, haveThis)
		if m is nil and _baseClass is not nil
			m = _baseClass.memberForName(name)
		if m is nil
			m = .interfaceMemberForName(name)
		return m

	def _bindInt is override
		# TODO: the following is a fix for SystemInterfaces.cobra.
		# Upon reading mscorlib.dll, this won't be necessary
# @@@@ remove this
#		if _name=='Object' and .compiler.nameSpaceStack.peek().name=='System'
#			assert _baseName=='Object'
#			_baseName = ''
		if _baseNode
			_baseNode.bindInt()
			possible = _baseNode.namedType
# TODO: remove:			possible = .compiler.symbolForName(_baseName, false, false)  # should canBeMember be true?
			baseName = _baseNode.toString()
			if possible is nil
				_error('Cannot locate base class named "[baseName]" for class "[_name]".')
			if possible inherits QualifiedType
				possible.bindInt()  # TODO: another monkey wrench showing how QualifiedType should be retired
				$sharp('possible = ((QualifiedType)possible).TheWrappedType')
			if possible inherits Class
				_baseClass = possible
			else if possible inherits Interface
				_error('The base "[baseName]" is an interface. Try "implements" instead of "inherits".')
			else if possible inherits Struct
				_error('The base "[baseName]" is a struct. Classes cannot inherit from structs.')
			else
				_error('The base class "[baseName]" is not actually a class, it is a "[possible.englishName]".')
		else
			t = .compiler.libraryType('System', 'Object')
			if t inherits Class
				if this is not t  # don't want Object to inherit Object
					_baseClass = t
			else
				throw FallThroughException(t)
		base._bindInt()

	def _badInterfaceError(type as IType) is override
		msg = 'Cannot implement "[type.name]" which is a [type.englishName].'
		if type inherits Class
			msg += ' Use "inherits" instead.'
		_error(msg)

	get englishName as String is override
		return 'class'

	get superType as IType? is override
		assert .didBindInt
		return _baseClass

	## Code gen

	get csInit as String is override
		return 'null'

	get sharpKeyWord as String is override
		return 'class'

	def writeSharpInheritance(sw as SharpWriter) is override
		sw.write(' : ')
		if _baseNode inherits TypeIdentifier
			# needed QualifiedTypes such "inherits System.Collection.ArrayList". See Tests\300-misc\700-use-on-generice-IList
			_baseNode.actualType.writeSharpRef(sw)
			didWrite = true
		else if _baseClass
			_baseClass.writeSharpRef(sw)
			didWrite = true
		if didWrite
			if _baseInterfaces
				sw.write(', ')
			else
				sw.write(' ')

	get newForSharpTest as String is override
		return if(not _baseClass.isFake, ' new', '')


class Interface
	inherits Box

	def construct(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, baseNodes as List<of INode>, docString as String?)
		base.construct(token, name, paramList, isNames, docString)
		_baseInterfaceNodes = baseNodes

	get englishName as String is override
		return 'interface'

	get isReference as bool is override
		return true

	def isDescendantOf(type as IType) as bool is override
		if not type.didBindInt
			type.bindInt()
		if this is type
			return true
		if type inherits Interface
			if .isDescendantOfInterface(type)
				return true
		return false

	def memberForName(name as String) as IMember? is override
		assert .didBindInt  # TODO: is this legit? if so, push up to Container
		m = base.memberForName(name)
		if m is nil
			m = .interfaceMemberForName(name)
			if m is nil
				m = .compiler.libraryType('System', 'Object').memberForName(name)
		return m

	## Code gen

	get csInit as String is override
		return 'null'

	get sharpKeyWord as String is override
		return 'interface'

	def writeSharpInheritance(sw as SharpWriter) is override
		if _baseInterfaces
			sw.write(' : ')

	def writeSharpTest(sw as SharpWriter) is override
		# Static methods can't be put in interfaces. However, at some point Cobra should support
		# tests for interfaces which could then be run against the classes that implement them.
		# Just requires more code gen smarts.
		pass


class Struct
	inherits Box

	def construct(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, baseName as String?, interfaceNodes as List<of INode>, docString as String?)
		base.construct(token, name, paramList, isNames, docString)
		_baseInterfaceNodes = interfaceNodes

	def _bindInt is override
		base._bindInt()

	get isReference as bool is override
		return false

	## Code gen

	get sharpKeyWord as String is override
		return 'class'

	get csInit as String is override
		return ''  # blank to indicate there is no valid init


class GenericParam
	inherits CobraType
	"""
	A generic parameter *is* a type.
	"""

	var _name as String
	var _constraints as List<of GenericConstraint>
	var _index as int

	def construct(name as String)
		require name
		base.construct()
		_name = name
		_constraints = List<of GenericConstraint>()

	get name as String is override
		return _name

	get constraints from var

	pro index from var

	get isReference as bool is override
		# Well, it's hard to say if a GenericParam is a reference or value type, but CompareExpr() influences us to say "true".
		# TODO: if there are constraints examine them
		return true

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addSubFields is override
		base.addSubFields()
		.addField('constraints', _constraints)

	def declForName(name as String) as IMember? is override
		for constraint in _constraints
			decl = constraint.declForName(name)
			if decl
				return decl
		return nil

	def memberForName(name as String) as IMember? is override
		for constraint in _constraints
			member = constraint.memberForName(name)
			if member
				return member
		return nil

	def isDescendantOf(type as IType) as bool is override
		if type is .compiler.libraryType('System', 'Object')
			return true
		if type.superType is nil  # the root type
			return true
		for constraint in _constraints
			r = constraint.isDescendantOf(type)
			if r
				return true
		return false

	def _bindInt is override
		base._bindInt()
		for constraint in _constraints
			constraint.bindInt()

	get csInit as String is override
		return 'default([_name])'

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write(.name)

	def writeSharpConstraint(sw as SharpWriter)
		if _constraints
			sw.write('where [_name] :  ')
			sep = ''
			for constraint in _constraints
				sw.write(sep)
				constraint.writeSharpDef(sw)
				sep = ', '
			sw.write('\n')


class GenericConstraint
	inherits SyntaxNode

	def construct(token as IToken)
		base.construct(token)

	def isDescendantOf(type as IType) as bool
		return false

	def declForName(name as String) as IMember?
		"""
		Returns nil by default.
		"""
		return nil

	def memberForName(name as String) as IMember?
		"""
		Returns nil by default.
		"""
		return nil

	def _bindInt is override
		base._bindInt()


class GenericClassConstraint
	inherits GenericConstraint
	"""
	Represents the generic constraint class
	"""

	def construct(token as IToken)
		base.construct(token)

	def writeSharpDef(sw as SharpWriter) is override
		sw.write('class')


class GenericStructConstraint
	inherits GenericConstraint
	"""
	Represents the generic constraint class
	"""

	def construct(token as IToken)
		base.construct(token)

	def writeSharpDef(sw as SharpWriter) is override
		sw.write('struct')


class GenericCallableConstraint
	inherits GenericConstraint
	"""
	Represents the generic constraint callable
	"""

	def construct(token as IToken)
		base.construct(token)

	def writeSharpDef(sw as SharpWriter) is override
		sw.write('new')


class GenericTypeConstraint
	inherits GenericConstraint
	"""
	Represents the generic constraint callable
	"""

	var _representedType as IType?
	var _typeNode as ISyntaxNode

	def construct(typeNode as ISyntaxNode)
		base.construct(typeNode.token)
		_typeNode = typeNode

	def isDescendantOf(type as IType) as bool is override
		assert _representedType
		return _representedType.isDescendantOf(type)

# TODO?
#	def declForName(name as String) as IMember? is override
#		assert _representedType
#		return _representedType.declForName(name)

	def memberForName(name as String) as IMember? is override
		assert _representedType
		return _representedType.memberForName(name)

	def _bindInt is override
		base._bindInt()
		if _representedType is nil
			_typeNode.bindInt()
			_representedType = _typeNode.namedType
			assert _representedType
		if not _representedType inherits Class and not _representedType inherits Interface
			_error('A generic type constraint must be a class or an interface. "[_representedType.name]" is not.')

	def writeSharpDef(sw as SharpWriter) is override
		_representedType.writeSharpRef(sw)



# TODO: Move everything below to Members.cobra

class ClassMember  # TODO: rename to BoxMember
	inherits NamedNode
	implements IMember

	shared
		var _accessLevels = ['public', 'protected', 'internal', 'protected internal', 'private']
			"""
			The access level names are the same in both Cobra and C#.
			"""

	var _box as Box
	var _docString as String?
	var _isNames as List<of String>?
	var _overloadGroup as MemberOverload?
	var _testMethod as TestMethod?

	def construct(token as IToken, box as Box, name as String, isNames as List<of String>)
		this.construct(token, box, name, isNames, nil)

	def construct(token as IToken, box as Box, name as String, isNames as List<of String>, docString as String?)
		base.construct(token, name)
		_isNames = isNames
		_box = box
		_docString = docString
		.defaultToVirtual()

	## Properties

	get box from var

	pro docString from var

	pro isNames from var

	pro overloadGroup from var

	pro testMethod from var

	get isCallable as bool
		return false

	get isShared as bool
		return 'shared' in _isNames

	get englishName as String
		throw OverrideException(.getType())
		return ''

	get defaultAccessLevel as String
		throw OverrideException(.getType())
		return ''

	get hasVariParams as bool
		"""
		Retuns true if the class member takes variable number of arguments.
		"""
		return false

	get hasParams as bool
		"""
		Returns true if the class member has one or more parameters defined.
		"""
		return false

	get params as List<of Param>
		"""
		Returns the list of params of this method, possibly empty.
		Checking hasParams first is recommended since it's more efficient.
		"""
		return List<of Param>()

	get isClassMember as bool
		return _box inherits Class

	get isInterfaceMember as bool
		return _box inherits Interface

	get isStructMember as bool
		return _box inherits Struct

	get requiresThis as bool
		return not _name.startsWith('_')

	get resultType as IType
		"""
		The result type of the var, method or property.
		"""
		throw OverrideException(.getType())
		return CobraType()

	## Other

	def defaultToVirtual
		"""
		A hook for subclasses to add the virtual keyword to _isNames, if appropriate.
		"""
		require _isNames is not nil
		pass

	## INamedNode

	get typeForIdentifier as IType is override
		assert false, 'not expecting `typeForIdentifier` for a class member'

	get typeForReceiver as IType is override
		return .resultType


	## Binding

	def _bindInt is override
		base._bindInt()
		if _testMethod
			_testMethod.bindInt()

	def _bindImp is override
		base._bindImp()
		assert .didBindInt  # class members should have always received a bindInt first
		if _testMethod
			_testMethod.bindImp()


	## Fields

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)
		.addField('isNames', _isNames)

	def addRefFields is override
		base.addRefFields()
		.addField('classDecl', _box)

	def addSubFields is override
		base.addSubFields()
		if _isNames
			.addField('isNames', _isNames)
		.addField('docString', _docString)


	## Code gen

	def writeSharpTest(sw as SharpWriter)
		if _testMethod
			_testMethod.writeSharpDef(sw)

	def writeSharpTestInvocation(sw as SharpWriter)
		if _testMethod
			sw.write('[_testMethod.sharpName]();\n')

	def writeSharpParams(sw as SharpWriter)
		.writeSharpParams(sw, '()')

	def writeSharpParams(sw as SharpWriter, parens as String) # TODO: could this be pushed down to OneCodeBlockMember
		require parens.length==2
		sw.write(parens[0])
		sep = ''
		for param in .params
			sw.write(sep)
			param.writeSharpDef(sw)
			sep = ', '
		sw.write(parens[1].toString()+' ')

	def writeSharpIsNames(sw as SharpWriter)
		# TODO: cache this somewhere
		accessLevels = ['public', 'protected', 'internal', 'protected internal', 'private']
		# CC: accessLevels = 'public,protected,internal,protected internal,private'.split(c',')
			# same names in both Cobra and C#

		# TODO:
		# if isNames is nil
		#	isNames = _isNames
		isNames = List<of String>()
		if _isNames
			isNames.addRange(_isNames)
		if .defaultAccessLevel
			found = false
			for level as String in accessLevels  # CC: axe as
				if level in isNames
					found = true
			if not found
				isNames.insert(0, .defaultAccessLevel)
		isNameCS = {
			# only have to specify the ones that are different
			'shared': 'static',
			'nonvirtual': '',
		}
		sep = ''
		for name in isNames
			name = Utils.getSS(isNameCS to passthrough, name, name) to String # CC: to !
			sw.write(sep)
			sw.write(name)
			sep = ' '
		if sep
			sw.write(' ')


class ClassVar
	inherits ClassMember
	implements IVar

	var _typeNode as INode
	var _type as IType?
	var _initExpr as Expr?
	var _ifInheritsStack as Stack<of IType>
	var _useCSNameStack as Stack<of String>

	def construct(token as IToken, box as Box, name as String, typeNode as INode, isNames as List<of String>, initExpr as Expr?, docString as String)
		base.construct(token, box, name, isNames, docString)
		_typeNode = typeNode
		_initExpr = initExpr
		_ifInheritsStack = Stack<of IType>()
		_useCSNameStack = Stack<of String>()  # for if-inherits

	def addRefFields is override
		base.addRefFields()
		if _type
			.addField('type', _type)
		else
			.addField('typeNode', _typeNode)

	def addSubFields is override
		base.addSubFields()
		.addField('initExpr', _initExpr)

	get defaultAccessLevel as String is override
		return 'protected'

	pro ifInheritsStack from var

	get requiresDotPrefix as bool
		return _box is not nil and not _name.startsWith('_')

	get useCSNameStack from var

	# TODO @@@ who calls this and when?
	def symbolForName(name as String, canBeMember as bool) as IMember?
		t as IType? = if(_ifInheritsStack, _ifInheritsStack.peek() to passthrough, _type)  # CC: get rid of cast and 'as'
		return t.memberForName(name)  # TODO is "true" the correct value here?

	def _bindInt is override
		base._bindInt()
		if _initExpr
			_initExpr.bindImp()  # that's bindImp intentionally
			if _type is nil
				_type = _initExpr.type
		if _type is nil
			assert _typeNode, 'typeNode should be set if _type is nil'
			_typeNode.bindInt()
			t = _typeNode.namedType
			t.bindInt()
			assert t, _typeNode
			if _initExpr and not _initExpr.isKindOf(t to IType)  # CC: axe cast when "assert foo" is understood to prove that foo is not nil
				_error('The expression type of [_initExpr.type] does not match the variable type of [t].')
			_type = t
		_type.bindInt()  # TODO: is this needed?

	get resultType as IType is override
		"""
		The result type of the var, method or property.
		"""
		if _type
			return _type to passthrough  # CC: axe cast
		else
			assert false, '_type is nil. this=[this]'

	## INamedNode

	get typeForIdentifier as IType is override
		return .resultType

	get typeForReceiver as IType is override
		assert .resultType
		return if(_ifInheritsStack, _ifInheritsStack.peek(), .resultType to IType)

	## IVar

	pro type as IType?
		get
			require _type
			return if(_ifInheritsStack, _ifInheritsStack.peek(), .resultType)  # CC: change last "to IType" to "to !" or make if() smarter
		set
			assert false, 'Cannot set the type of a ClassVar.'
			# TODO: remove
			#assert _type is nil  # TODO: in [nil, tpassthrough, tunknown)
			#assert not _ifInheritsStack
			#_type = value

	## Code Gen

	get sharpAssignmentNames as List<of String>
		return List<of String>(_useCSNameStack)

	def writeSharpRef(sw as SharpWriter) is override
		name = if(_useCSNameStack, _useCSNameStack.peek(), _name)
		sw.write(name)

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		.writeSharpIsNames(sw)
		_type.writeSharpRef(sw)
		sw.write(' [_name]')
		if _initExpr
			sw.write(' = ')
			_initExpr.writeSharpDef(sw)
		sw.write(';\n')

	get sharpName as String is override
		return if(_useCSNameStack, _useCSNameStack.peek(), .name)


interface ICodePart
	"""
	A code part responds to addStmt(stmt).

	It is the common interface to:
		- methods
		- inits (special methods)
		- property getter
		- property setter
		- nested method
		- anonymous method
	"""

	get name as String

	def addStmt(stmt as Stmt)

	def addLocal(local as LocalVar)

	def findLocal(name as String) as AbstractLocalVar?

	def findLocalCI(name as String) as AbstractLocalVar?

	def removeLocal(name as String)

	pro hasReturnStmt as bool

	get resultType as IType

	pro requirePart as RequirePart?

	pro ensurePart as EnsurePart?

	def addOldExpr(oldExpr as OldExpr)

	get sharpResultVarName as String


class OneCodeBlockMember
	inherits ClassMember
	implements ICodePart
	"""
	The abstract ancestor class for
		Constructor
		Method
		PropertyXetter

	But not for Property (which has two code blocks "get" and "set"),
	or other class decls like variables.

	Subclasses must set _params.
	"""

	var _returnTypeNode as INode
	var _returnType as IType?
	var _requirePart as RequirePart
	var _ensurePart as EnsurePart
	var _oldExprs as List<of OldExpr>  # TODO: add a doc string for this
	var _params as List<of Param>
	var _locals as List<of LocalVar>
	var _stmts as List<of Stmt>
	var _hasReturnStmt as bool
	var _sharpResultVarName as String?

	def construct(token as IToken, box as Box, name as String, paramsList as List<of Param>, isNames as List<of String>, docString as String)
		base.construct(token, box, name, isNames, docString)
		_params = paramsList
		_oldExprs = List<of OldExpr>()
		_locals = List<of LocalVar>()
		_stmts = List<of Stmt>()

	get hasParams as bool is override
		return _params.count > 0

	get params as List<of Param> is override
		return _params

	get defaultAccessLevel as String is override
		if .isClassMember or .isStructMember
			return 'public'
		else if .isInterfaceMember
			return ''
		else
			throw FallThroughException(this)

	def defaultToVirtual is override
		if .isClassMember
			for name in ['nonvirtual', 'virtual', 'shared', 'override']
				if name in _isNames
					return
			_isNames.add('virtual')

	get isCallable as bool is override
		return true

	pro hasReturnStmt from var

	def addStmt(stmt as Stmt)
		_stmts.add(stmt)

	pro requirePart from var

	pro ensurePart from var

	get resultType as IType is override
		require
			.didBindInt
			_returnType!
		code
			return _returnType to IType  # CC: to !

	def findLocal(name as String) as AbstractLocalVar?  # TODO: narrow to common base of Param and LocalVar
		# TODO: does it really matter if a the symbols are traversed in reverse order?
		# TODO: should this use a dictionary lookup?
		i = _locals.count - 1
		while i>=0
			if _locals[i].name==name
				return _locals[i]
			i -= 1
		for param in _params
			if param.name==name
				return param
		return nil

	def findLocalCI(name as String) as AbstractLocalVar?
		name = name.toLower()
		# TODO: does it really matter if a the symbols are traversed in reverse order?
		# TODO: should this use a dictionary lookup?
		i = _locals.count - 1
		while i>=0
			if _locals[i].name.toLower()==name
				return _locals[i]
			i -= 1
		for param in _params
			if param.name.toLower()==name
				return param
		return nil

	def addLocal(local as LocalVar)
		require
			local.name
			.findLocal(local.name) is nil  # TODO: , 'symbol=[symbol], symbolForName=[.symbolForName(symbol.name)]'
		code
			other = .findLocalCI(local.name)
			if other!
				_error('Parameters and locals must vary by more than just their case. Change "[local.name]" or "[other.name]" to match, or rename one of them to something different.')
			local.isTracked = true
			_locals.add(local)

	def removeLocal(name as String)
		require
			name
			.findLocal(name) is not nil
		code
			for i = 0 .. _locals.count
				if _locals[i].name==name
					_locals.removeAt(i)
					break

#	def dumpName(sw)
#		name = getattr('name', '(noname)')
#		returnType = getattr('returnType', '(no return type)')
#		while iscallable(returnType)
#			returnType = returnType()
#		sw.write('%s as %s  (%s)\n' % (name, returnType, .className))

# TODO: is pushName() needed?
#	def pushName(var)
#		.addSymbol(var)

#	def dumpNames(sw)
#		sw.write('%s\n' % .__class__.__name__)
#		sw.indent()
#		for param in .params
#			param.dumpName(sw)
#		for name in .names
#			name.dumpName(sw)
#		sw.indent()

	def addOldExpr(oldExpr as OldExpr)
		_oldExprs.add(oldExpr)
		oldExpr.sharpVarName = '_lh_old_' + _oldExprs.count.toString()

	def addRefFields is override
		base.addRefFields()
		.addField('returnTypeNode', _returnTypeNode)
		.addField('returnType', _returnType)

	def addSubFields is override
		base.addSubFields()
		.addField('params', _params)
		if _returnType inherits QualifiedType  # TODO: another QualifiedType special case
			.addField('returnType', _returnType)
		.addField('locals', _locals)
		.addField('stmts', _stmts)

	def _bindInt is override
		base._bindInt()
		.compiler.codeMemberStack.push(this)
		for param in _params
			param.bindInt()
		if _returnType is nil
			if _returnTypeNode is nil
				_returnType = .compiler.voidType
			else
				_returnTypeNode.bindInt()
				_returnType = _returnTypeNode.namedType
				_returnType.bindInt()  # TODO: needs a test case. like: def foo as String?; return ''
			assert _returnType, _returnTypeNode
		if _requirePart
			_requirePart.bindInt()
		if _ensurePart
			_ensurePart.bindInt()
		.compiler.codeMemberStack.pop()

	def _bindImp is override
		base._bindImp()
		.compiler.codeMemberStack.push(this)
		for param in _params
			param.bindImp()
		for local in _locals
			local.bindImp()
		# TODO re-enable the assertion below
		#assert compiler.opStack.count==0, repr(compiler.opStack._items)
		if _requirePart
			_requirePart.bindImp()
		if _ensurePart and _returnType is not nil and _returnType is not .compiler.voidType
			_sharpResultVarName = '_lh_result_[_box.makeNextPrivateSerialNumber()]'
		else
			_sharpResultVarName = nil
		for stmt in _stmts
			stmt.bindImp()
			stmt.afterStatementBindImp()
		if _ensurePart
			_ensurePart.bindImp()
		.compiler.codeMemberStack.pop()

	## Code gen

	get sharpResultVarName from var

	def writeSharpImp(sw as SharpWriter, skipFirst as bool)
		sw.writeAndIndent('{\n')
		if .compiler.hasSuperStackTraceOption
			.writeSSTHead(sw)
		for param in _params
			.writeSharpParamCheck(param, sw)
		if _requirePart
			_requirePart.writeSharpDef(sw)
		.writeSharpLocals(sw, nil, false)
		if _ensurePart
			if _sharpResultVarName  # set in _bindImp
				_returnType.writeSharpRef(sw)
				sw.write(' [_sharpResultVarName] = [_returnType.csInit];\n')
			sw.writeAndIndent('try {\n')
		for stmt in _stmts
			if skipFirst
				skipFirst = false
				continue
			stmt.writeSharpStmt(sw)
		if _ensurePart
			sw.dedentAndWrite('} finally { // ensure\n')
			sw.indent()
			_ensurePart.writeSharpDef(sw)
			sw.dedentAndWrite('}\n')
		if .compiler.hasSuperStackTraceOption
			.writeSSTTail(sw)
		sw.dedent()
		sw.write('}\n')
		sw.write('\n')

	# TODO: axe?
#	def writeSharpLocals(sw as SharpWriter)
#		.writeSharpLocals(sw, nil, true)

	def writeSharpLocals(sw as SharpWriter, locals as List<of LocalVar>?, open as bool)
		if open
			sw.writeAndIndent('{\n')
		# record the `old` expressions for `ensure`
		for oldExpr in _oldExprs
			oldExpr.writeSharpAssignment(sw)
		if locals is nil
			locals = _locals
		if locals
			sw.write('// locals\n')
			for local in locals
				if not local.isImplicit
					local.type.writeSharpRef(sw)
					sw.write(' [local.name]')
					init = local.type.csInit
					if init
						sw.write(' = [init]')
					sw.write(';\n')

	def writeSharpParamCheck(param as Param, sw as SharpWriter)
		if param.type.isReference and not param.type inherits NilableType
			sw.write('if ([param.name]==null) throw new ArgumentNullException("[param.name]");\n')
			# TODO axe the code below or above
			#sw.write('if (%s==null) throw new ArgumentNullException("%s", string.Format("Object reference \\"%s\\" not set to an instance of an object."));\n' % (
			#	param.name, param.name, param.name))

	def writeSSTHead(sw as SharpWriter)
		assert false
		# TODO
		#sw.write('CobraImp.PushFrame("%s", "%s"' % (.box.name, .name))
		#if not .isShared
		#	sw.write(', "this", this')
		#for param in .params
		#	sw.write(', "%s", %s' % (param.name, param.name))
		#sw.write(');\n')
		#sw.write('CobraImp.SetLine(%s);\n' % .token.lineNum)
		#sw.writeAndIndent('try {\n')

	def writeSSTTail(sw as SharpWriter)
		assert false
		#sw.indentAndWrite('} catch {\n')
		#sw.indent()
		#sw.write('CobraImp.CaughtUncaughtException();\n')
		#sw.write('throw;\n')
		#sw.indentAndWrite('} finally {\n')
		#sw.indent()
		#sw.write('CobraImp.PopFrame();\n')
		#sw.indentAndWrite('}\n')



class Constructor
	inherits OneCodeBlockMember
	implements ICodePart  # TODO: should OneCodeBlockMember inherit ICodePart

	def construct(token as IToken, box as Box, paramsList as List<of Param>, isNames as List<of String>, docString as String)
		base.construct(token, box, 'construct', paramsList, isNames, docString)
		_isNames = isNames
		_stmts = List<of Stmt>()

	get englishName as String is override
		return 'method'

	get hasVariArgs as bool
		assert false, 'TODO: complete Method.hasVariArgs'
		return false

	get isCallable as bool is override
		return true

	def defaultToVirtual is override
		pass

	## Code gen

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		first = if(_stmts, _stmts[0], nil)
		callConstructor as String? = nil
		if first inherits DotExpr
			if (first.left inherits ThisLit or first.left inherits BaseLit) and (first.right to CallExpr).name=='construct'
				callConstructor = (first.left to AtomicLiteral).asSharp
				args = (first.right to CallExpr).args
		.writeSharpIsNames(sw)
		sw.write(' [.box.rootName]')
		.writeSharpParams(sw)
		if callConstructor
			sw.writeAndIndent('\n')
			sw.write(': [callConstructor](')
			sep = ''
			for arg in args
				sw.write(sep)
				arg.writeSharpDef(sw)
				sep = ', '
			sw.write(') ')
		.writeSharpImp(sw, if(callConstructor, true, false))
		.writeSharpTest(sw)


class Method
	inherits OneCodeBlockMember
	implements ICodePart

	var _implementsTypeNode as ISyntaxNode?
	var _implementsType as IType?

	def construct(token as IToken, box as Box, name as String, paramsList as List<of Param>, returnTypeNode as INode, implementsTypeNode as ISyntaxNode?, isNames as List<of String>, docString as String)
		base.construct(token, box, name, paramsList, isNames, docString)
		_returnTypeNode = returnTypeNode
		_implementsTypeNode = implementsTypeNode
		# TODO: feels kind of hacky:
		if 'virtual' in _isNames and _implementsTypeNode
			_isNames.remove('virtual')
		_stmts = List<of Stmt>()

	get englishName as String is override
		return 'method'

	get hasVariArgs as bool
		assert false, 'TODO: complete Method.hasVariArgs'
		return false

	get isCallable as bool is override
		return true

	def addRefFields is override
		base.addRefFields()
		.addField('implementsType', _implementsType)

	def addSubFields is override
		base.addSubFields()
		if _implementsTypeNode
			.addField('implementsTypeNode', _implementsTypeNode)

	get defaultAccessLevel as String is override
		dal = base.defaultAccessLevel
		if dal and not _implementsType and not _implementsTypeNode
			return dal
		else
			return ''

	def defaultToVirtual is override
		if .isClassMember and not _implementsTypeNode and not _implementsType
			base.defaultToVirtual()

	def _bindImp is override
		base._bindImp()
		numErrors = .compiler.errors.count
		if _implementsTypeNode is not nil
			_implementsTypeNode.bindAll()
			assert _implementsTypeNode.namedType
			_implementsType = _implementsTypeNode.namedType
			# TODO: make sure the type is among the interfaces of the box
		if .compiler.errors.count==numErrors and _returnType is not .compiler.voidType and not .hasReturnStmt and not .box.isFake and not .box inherits Interface
			_error('Missing return statement for method "[_name]" which returns [_returnType.name].')

	## Code gen

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		name = .sharpName
		returnType = _returnType ? .compiler.voidType to IType  # CC: axe cast
		if _implementsType
			name = _implementsType.name + '.' + name  # TODO: is name sufficient?
		.writeSharpIsNames(sw)
		returnType.writeSharpRef(sw)
		sw.write(' [name]')
		.writeSharpParams(sw)
		if .isInterfaceMember
			sw.write(';\n')
		else
			.writeSharpImp(sw, false)
			.writeSharpTest(sw)

	get sharpName as String is override
		return Utils.capped(.name)


class ProperDexer
	inherits ClassMember
	"""
	The abstract base class for Property and Indexer.

	This captures some of the common interface between them--whatever happens to be needed
	(currenty by the parser only).

	Why not do an IProperDexer interface? Because it wouldn't be compatible with a ClassMember
	unless we also defined an IClassMember.
	"""

	var _getPart as ProperDexerXetter?
	var _setPart as ProperDexerXetter?
	var _coverVar as ClassVar
	var _coverAccess as String
	var _returnType as IType?
	var _returnTypeNode as INode?

	def construct(token as IToken, box as Box, name as String, isNames as List<of String>, docString as String)
		base.construct(token, box, name, isNames, docString)

	def construct(token as IToken, box as Box, name as String, returnTypeOrNode as INode, isNames as List<of String>, docString as String)
		.construct(token, box, name, isNames, docString)
		if returnTypeOrNode
			if returnTypeOrNode inherits IType
				_returnType = returnTypeOrNode
				_returnTypeNode = nil
			else if returnTypeOrNode inherits INode
				_returnType = nil
				_returnTypeNode = returnTypeOrNode
			else
				throw FallThroughException(returnTypeOrNode)

	def makeGetPart(token as IToken) as OneCodeBlockMember
		throw OverrideException()
		# CC: shouldn't need a return:
		return nil to passthrough

	def makeSetPart(token as IToken) as OneCodeBlockMember
		throw OverrideException()
		# CC: shouldn't need a return:
		return nil to passthrough

	def addRefFields is override
		base.addRefFields()
		if _coverVar
			.addField('coverVar', _coverVar)
		if _returnType
			.addField('returnType', _returnType)
		else
			.addField('returnTypeNode', _returnTypeNode)

	def addSubFields is override
		base.addSubFields()
		if _getPart
			.addField('getPart', _getPart)
		if _setPart
			.addField('setPart', _setPart)

	get returnType from var

	get returnTypeNode from var

	get resultType as IType is override
		assert .didBindInt
		assert _returnType
		return _returnType to IType  # CC: axe when code flow understands the assert

	get getPart from var

	get setPart from var

	def defaultToVirtual is override
		# TODO: dup'ed in OneCodeBlockMember
		if .isClassMember
			for name in ['nonvirtual', 'virtual', 'shared', 'override']
				if name in _isNames
					return
			_isNames.add('virtual')

	get defaultAccessLevel as String is override
		if .isClassMember
			return 'public'
		else
			return ''

	def _bindInt is override
		base._bindInt()
		if _returnType is nil
			if _coverVar
				_coverVar.bindInt()
				assert _coverVar.resultType, _coverVar
				_returnType = _coverVar.resultType
			else
				assert _returnTypeNode
				_returnTypeNode.bindInt()
				_returnType = _returnTypeNode.namedType
		_returnType.bindInt()
		assert _returnType  # properties always have a return type
		if _getPart
			_getPart.bindInt()
		if _setPart
			_setPart.bindInt()

	def _bindImp is override
		base._bindImp()
		if _getPart
			_getPart.bindImp()
		if _setPart
			_setPart.bindImp()

	## Code gen

	def writeSharpBody(sw as SharpWriter)
		sw.write(' {\n')
		sw.indent()
		if _coverVar
			if _coverAccess in ['getset', 'get']
				sw.write('get { return [_coverVar.sharpName]; }')
			if _coverAccess in ['getset', 'set']
				sw.write('set { [_coverVar.sharpName] = value; }')
		else
			if _getPart
				if .isClassMember
					_getPart.writeSharpDef(sw)
				else if .isInterfaceMember
					sw.write('\tget;\n')
				else
					throw FallThroughException(this)
			if _setPart
				if .isClassMember
					_setPart.writeSharpDef(sw)
				else if .isInterfaceMember
					sw.write('\tset;\n')
				else
					throw FallThroughException(this)
		sw.dedent()
		sw.write('}\n')


class ProperDexerXetter
	inherits OneCodeBlockMember
	"""
	Base class for IndexerGetter, IndexerSetter, PropertyGetter and PropertySetter.
	"""

	var _parent as ProperDexer

	def construct(token as IToken, parent as ProperDexer, isNames as List<of String>)
		base.construct(token, parent.box, parent.name, List<of Param>(), isNames, '')  # TODO: should be docString, right?
		_name = parent.name + '.' + .xetPartName  # CC: somewhat awkward. belongs in the base.construct() call
		_parent = parent

	get parent from var

	get xetPartName as String  # CC: make abstract
		throw OverrideException(.getType())
		return '(override indexerPartName)'

	get isShared as bool is override
		return _parent.isShared

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write(.xetPartName)
		.writeSharpImp(sw, false)


class MemberOverload
	inherits ClassMember

	var _members as List<of ClassMember>

	def construct(member as ClassMember)
		require
			member.name
			member.box
		code
			base.construct(member.token, member.box, member.name, member.isNames)
			member.overloadGroup = this
			_members = [member]
			_isNames = member.isNames  # pick up 'shared' for example

	def addSubFields is override
		base.addSubFields()
		.addField('members', _members)

	get members from var

	get englishName as String is override
		assert _members
		return _members[0].englishName

	get isCallable as bool is override
		assert _members
		return _members[0].isCallable

	def addMember(member as ClassMember)
		require
			member is not this
			not member inherits MemberOverload
			member.overloadGroup is nil
			member.name==.name # CC:, '.name=[.name], member.name=[member.name]'
			.members implies member not in .members # CC: , member
			.members implies member.getType() is .members[0].getType()
		code
			member.overloadGroup = this
			_members.add(member)
			.box.addDeclFromOverload(member, this)

	get resultType as IType? is override
		assert .didBindInt
		assert _members[0] is not this
		return _members[0].resultType

	def _bindInt is override
		base._bindInt()
		# rename the test members of the overload by suffixing them with '_o1' '_o2' etc.
		i = 1
		for member in _members
			if member.testMethod
				member.testMethod.name = member.testMethod.name + '_ol' + i.toString()
			i += 1
		# TODO: error if the returnType is different among any members
		# TODO: error if the two members have the same arguments

	def _bindImp is override
		base._bindImp()


class TestMethod
	inherits Method
	"""
	TODO: It's weird that you have to pass voidType. Maybe Node should have a shared typeProvider
	like it has a shared compiler. The parser could set it.
	"""

	var _forMember as ClassMember?
	var _forBox as Box?

	def construct(token as IToken, member as ClassMember, voidType as IType)
		require
			member.box
			member.name
		code
			# CC: shouldn't the .getCompiler() work? C# code gen puts a "this" in there even though it's shared and C# chokes on it
			#base.construct(token, member.box, 'test_'+Utils.capped(member.name), List<of Param>(), .getCompiler().voidType, List<of String>(), nil, '')
			base.construct(token, member.box, 'test_'+Utils.capped(member.name), List<of Param>(), voidType, nil, List<of String>(), '')
			_forMember = member

	def construct(token as IToken, box as Box, voidType as IType)
		require
			box.name
		code
			# CC: shouldn't the .getCompiler() work? C# code gen puts a "this" in there even though it's shared and C# chokes on it
			# base.construct(token, box, 'test_class_'+Utils.capped(box.name), List<of Param>(), .getCompiler().voidType, List<of String>(), List<of INode>(), '')
			base.construct(token, box, 'test_class_'+Utils.capped(box.name), List<of Param>(), voidType, nil, List<of String>(), '')
			_forBox = box

	pro name as String # CC: is new
		"""
		NamedNode.name does not allow the name to be set because that could mess up dictionaries
		that index the node by name. However, there are no such dictionaries for TestMethod and
		MemberOverload() needs to mangle test method names so they don't collide.
		"""
		get
			return base.name
		set
			require value
			_name = value

	def defaultToVirtual is override
		_isNames.add('shared')


class ConditionPart
	inherits SyntaxNode
	"""
	TODO: Rename to ContractPart
	The abstract base class for RequirePart and EnsurePart.
	"""

	var _codeMember as ICodePart
	var _exprs as List<of Expr>

	def construct(token as IToken, codeMember as ICodePart, exprs as List<of Expr>)
		base.construct(token)
		_codeMember = codeMember
		_exprs = exprs

	def _bindImp is override
		base._bindImp()
		i = 0
		for expr as Expr in _exprs.toArray()  # CC: axe cast
			expr.bindImp()
			assert expr.type
			if expr.type is not .compiler.boolType
				expr = TruthExpr(expr).bindAll() to Expr # CC: axe cast when Cobra supports "as this"
				assert expr.type
				_exprs[i] = expr
			i += 1


class RequirePart
	inherits ConditionPart

	def construct(token as IToken, codeMember as ICodePart, exprs as List<of Expr>)
		base.construct(token, codeMember, exprs)
		codeMember.requirePart = this

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write('// require\n')
		for expr in _exprs
			sw.write('if (!')
			expr.writeSharpDef(sw)
			sw.write(') ')
			sw.indent()
			s = expr.toCobraSource()
			s = Utils.csStringLitFor(s)
			sw.write('throw new RequireException([Utils.csStringLitFor(_token.fileName)], [_token.lineNum], [s], null);\n')
			sw.dedent()
		sw.write('// end require\n')


class EnsurePart
	inherits ConditionPart

	def construct(token as IToken, codeMember as ICodePart, exprs as List<of Expr>)
		base.construct(token, codeMember, exprs)
		codeMember.ensurePart = this

	def _bindImp is override
		assert _codeMember.resultType
		if _codeMember.resultType is .compiler.voidType
			base._bindImp()
		else
			_codeMember.addLocal(ResultVar(.token, _codeMember))
			try
				base._bindImp()
			finally
				_codeMember.removeLocal('result')

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		for expr in _exprs
			sw.write('if (!')
			expr.writeSharpDef(sw)
			sw.write(') ')
			sw.indent()
			s = expr.toCobraSource()
			s = Utils.csStringLitFor(s)
			sw.write('throw new EnsureException([Utils.csStringLitFor(_token.fileName)], [_token.lineNum], [s], null);\n')
			sw.dedent()


## TODO: Move the below items to Vars.cobra. Put IVar in there too.

class AbstractLocalVar
	inherits NamedNode
	implements IVar
	"""
	The base class for Param and LocalVar.
	"""

	var _type as IType?
	var _typeNode as INode?
	var _isImplicit as bool
	var _isTracked as bool
	var _ifInheritsStack = Stack<of IType>()
	var _useCSNameStack = Stack<of String>()  # for if-inherits

	def construct(token as IToken, type as IType, isImplicit as bool)
		base.construct(token, token.text)
		_type = type
		_isImplicit = isImplicit
		_isTracked = false

	def construct(token as IToken, typeNode as INode, isImplicit as bool)
		base.construct(token, token.text)
		_typeNode = typeNode
		_isImplicit = isImplicit
		_isTracked = false

	pro ifInheritsStack from var

	get isImplicit from var

	pro isTracked from var

	get useCSNameStack from var

	def addMinFields is override
		base.addMinFields()
		if _isImplicit
			.addField('isImplicit', _isImplicit)
		.addField('isTracked', _isTracked)

	def addRefFields is override
		base.addRefFields()
		.addField('typeNode', _typeNode)
		.addField('type', _type)

	def toString as String is override
		type = if(_type, .type.name, "(no type)")
		return '[.getType().name]([.serialNum], [.token], [.name], [type])'

# TODO
#	def symbolForName(name, canBeMember=false)
#		t = .ifInheritsStack and .ifInheritsStack.peek() or .type
#		return t.symbolForName(name, true)  # TODO is "true" the correct value here?

#	def dumpName(sw)
#		sw.write('%s as %s  (%s)\n' % (.name, .type.name, .__class__.__name__))

	def _bindInt is override
		base._bindInt()
		_resolveType()
		assert _type
		_type.bindInt()

	def _bindImp is override
		base._bindImp()
		_resolveType()

	def _resolveType
		require _type! or _typeNode!
		if _type!
			return
		if _typeNode inherits IType
			_type = _typeNode to passthrough   # CC: shouldn't need the cast here
			return
		_type = _typeNode.bindAll().namedType
		if _type is nil
			_error('Cannot resolve type.')  # TODO: add the name of the wrappedTypeNode or something

	pro type as IType
		get
			require _type
			return if(_ifInheritsStack, _ifInheritsStack.peek(), _type to IType)  # CC: change last "to IType" to "to !" or make if() smarter
		set
			require .compiler
			assert _type is nil or _type is .compiler.unspecifiedType
			assert not _ifInheritsStack
			_type = value

	get typeNode from var

	get typeForIdentifier as IType is override
		return .type

	get typeForReceiver as IType is override
		assert _type
		return if(_ifInheritsStack, _ifInheritsStack.peek(), _type to IType)

	get sharpAssignmentNames as List<of String>
		return List<of String>(_useCSNameStack)

	get sharpName as String is override
		return if(_useCSNameStack, _useCSNameStack.peek(), .name)



class Param
	inherits AbstractLocalVar

	def construct(token as IToken, type as IType)
		.construct(token, type, false)

	def construct(token as IToken, typeNode as INode)
		.construct(token, typeNode, false)

	def construct(token as IToken, type as IType, isImplicit as bool)
		base.construct(token, type, isImplicit)

	def construct(token as IToken, typeNode as INode, isImplicit as bool)
		base.construct(token, typeNode, isImplicit)

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		.type.writeSharpRef(sw)
		sw.write(' [.name]')


class LocalVar
	inherits AbstractLocalVar

	def construct(token as IToken, type as IType)
		.construct(token, type, false)

	def construct(token as IToken, typeNode as INode)
		.construct(token, typeNode, false)

	def construct(token as IToken, type as IType, isImplicit as bool)
		base.construct(token, type as IType, isImplicit)

	def construct(token as IToken, typeNode as INode, isImplicit as bool)
		base.construct(token, typeNode, isImplicit)

	def addMinFields is override
		base.addMinFields()
		.addField('isTracked', _isTracked)


class ResultVar
	inherits LocalVar
	"""
	The implicit variable `result` used in `ensure` blocks.
	"""

	var _sharpName as String

	def construct(token as IToken, codePart as ICodePart)
		base.construct(_makeToken(token, codePart), codePart.resultType, true)
		_sharpName = codePart.sharpResultVarName

	def _makeToken(token as IToken, codePart as ICodePart) as IToken is shared
		token = token.copy
		token.text = 'result'
		return token

	get sharpName as String is override
		return _sharpName
