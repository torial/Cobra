"""
Cobra Command Line Program (compiler and more)

"""


class CommandLine
	"""
	The main options that control the command line's behavior are:
		run
		test
		compile
		testify
		help

	"testify" is private to the implementor of Cobra.

	"run" is the default if none are specified and at least one path is provided.

	If no arguments are passed at all, "help" becomes the default.

	You need to put at least one dash in front of an option. Also, you can leave
	out the ".cobra" extension if you like. For example:

		cobra -compile foo bar

	"""

	get versionString as String is shared
		return '0.5'

	var _optionSpecs as List<of Dictionary<of String, Object>>

	var _rawOptionSpecs = [
		{
			'name': 'about',
			'description': 'Print the name, copyright, etc. but no usage.',
			'type': 'main',
		},
		{
			'name': 'compile',
			'synonyms': ['c'],
			'description': 'Compile the library (to DLL) or the program (to EXE) without running the code.',
			'type': 'main',
		},
		{
			'name': 'debug',
			'type': 'string',
			'description': 'Turn on system debugging information. The value 1 implies full, which enables attaching a debugger to a running program.',
			'args': r'[=0|1|pdbonly|full]'
		},
		{
			'name': 'files',
			'isAccumulator': true,
			'description': 'Specify the files for Cobra to process. One per line; # comments respected.',
			'args': '=filename',
		},
		{
			'name': 'editor',
			'description': 'Specify an editor and command line options to invoke if there is a compile-time error. Use underscore (_) for space in the specification. Can also set via COBRA_EDITOR environment variable (in which case spaces work fine).',
			'example': ['uedit32_FILE/LINE', 'mate_FILE_-l_LINE'],
			'args': 'editor_spec_with_FILE_LINE',
		},
		{
			'name': 'help',
			'synonyms': ['h'],
			'type': 'main',
			'description': 'Display this help message.',
		},
		{
			'name': 'reference',
			'synonyms': ['r'],
			'isAccumulator': true,
			'description': 'Add a DLL reference.',
			'args': 'Some.dll',
		},
		{
			'name': 'run',
			'description': 'Runs the Cobra program. This is the default behavior if specify any Cobra source files.',
			'type': 'main',
		},
		{
			'name': 'superstacktrace',
			'synonyms': ['sst'],
			'type': 'bool',
			'description': 'Enable super stack trace which gives great postmortem information for uncaught exceptions, but slows execution.',
		},
		{
			'name': 'target',
			'description': 'Build a specific target.',
			'type': 'menu',
			'choices': ['exe', 'winexe', 'lib', 'module'],
			'args': 'exe|winexe|lib|module',
			'synonyms': ['t'],
		},
		{
			'name': 'test',
			'description': 'Run the unit tests in the code.',
			'type': 'main',
		},
		{
			'name': 'testify',
			'description': '...',
			'type': 'main',
			'hidden': true,
		},
		{
			'name': 'timeit',
			'description': 'Gives the total duration of running cobra (including the target program, if it is to be run). This is "wall time", not "cpu time".',
			# although this option is implied by 'testify', the description does not say so, since 'testify' is a hidden option
			'type': 'bool',
		},
		{
			'name': 'verbosity',
			'synonyms': ['verbose', 'v'],
			'type': 'int',
			'min': 0,
			'max': 5,
			'args': 'N',
			'description': 'Enable extra output from Cobra. Mostly useful for debugging Cobra. Values 0 - 5.',
		},
		{
			'name': 'version',
			'description': 'Print just the version number ([.versionString]).',
			'type': 'main',
		},
	]

	var _startTime as DateTime
	var _verbosity = 0

	var _optionDict as Dictionary<of String, Object>?
	var _pathList as List<of String>?

	def init
		_startTime = DateTime.now
		# prep the option specs
		_optionSpecs = List<of Dictionary<of String, Object>>()
		for specObj in _rawOptionSpecs
			# since some _optionSpecs are Dictionary<of String, Object> and others are
			# Dictionary<of String, String> then _optionSpecs ends up being
			# Dictionary<of String, Object>

			# CC: if foo is Dictionary<of String, Object>  ... does not seem to work
			if specObj inherits Dictionary<of String, Object>
				d = specObj
			else if specObj inherits Dictionary<of String, String>
				d = Dictionary<of String, Object>()
				for key in $sharp('((Dictionary<String, String>)loc_specObj).Keys')
					d[key to String] = $sharp(r'((Dictionary<String, String>)loc_specObj)[(String)loc_key]')
			else
				throw FallThroughException(specObj.getType)
			_optionSpecs.add(d)

	get cobraTestsPath as String
		"""
		Only used when --testify is passed with no path.
		--testify is an "internal" feature of the cobra command line front end.
		"""
		# -testify is often invoked out of the next-door directory "Source"
		# so check next door, first:
		slash = Path.directorySeparatorChar
		path = "..[slash]Tests"
		if Directory.exists(path)
			return Path.getFullPath(path)

		home = Environment.getEnvironmentVariable("HOME")
		path = '[home]' + r'[slash]Projects[slash]Cobra[slash]Workspace[slash]Tests'
		if Directory.exists(path)
			return Path.getFullPath(path)

		throw Exception(r'Cannot find Tests directory next door or in HOME\Projects\Cobra\Workspace\Tests')

	get verbosity as int
		return _verbosity

	def run
		"""
		Run the command line using the command line arguments.
		"""
		.run(CobraCore.commandLineArgs[1:])

	def run(args as List<of String>)
		"""
		Run the command line using the given arguments.
		The `args` should include only the arguments and not the executable/program name.
		"""
		if args.count == 0
			.doAbout
			return
		.parseArgs(args)
		d = _optionDict
		paths = _pathList to List<of String>  # CC: to !
		# TODO: use reflection here?
		if _getOne(d, 'testify')
			.doTestify(paths)
		else if _getOne(d, 'run')
			.doRun(paths)
		else if _getOne(d, 'test')
			.doTest(paths)
		else if _getOne(d, 'compile')
			.doCompile(paths)
		else if _getOne(d, 'help')
			.doHelp
		else if _getOne(d, 'version')
			.doVersion
		else if _getOne(d, 'about')
			.doAbout
		else if not paths.count
			.doHelp
		else
			.doRun(paths)

	def _getOne(d as Dictionary<of String, Object>?, name as String) as bool
		if d.containsKey(name)
			value = d[name]
			if value inherits bool
				return value
			else
				throw FallThroughException(value)
		else
			return false

	def parseArgs(args as List<of String>)
		"""
		Parse command line arguments.
		The `args` should include only the arguments and not the executable/program name.
		Sets _optionDict and _pathList.
		"""
		optionPrefix = '-'
		valuePrefix = c'='
		if not args.count
			_optionDict = Dictionary<of String, Object>()
			_optionDict.add('help', true)
			_pathList = List<of String>()
			return

		specDict = Dictionary<of String, Dictionary<of String, Object>>()
			# ^ will contain keys for all spec names and their synonyms
		synToName = Dictionary<of String, String>()
			# ^ maps synonyms to their full names
		synList = List<of String>()
		for d in _optionSpecs
			specDict[d['name'] to String] = d
			if d.containsKey('synonyms')
				syns = d['synonyms']
				for syn as String in (syns to System.Collections.IList) # CC: shouldn't need either cast
					assert not specDict.containsKey(syn)
					specDict[syn] = d
					synToName[syn] = d['name'] to String
					synList.add(syn)
			if not d.containsKey('type')
				d.add('type', 'string')

		valueDict = Dictionary<of String, Object>()
		fileList = List<of String>()
		value = "no-value" to Object  # for typing
		mainOptions = List<of String>()
		for arg in args
			if arg.startsWith(optionPrefix)
				isOption = true
				while arg.startsWith(optionPrefix)
					arg = arg.substring(1)
			else
				isOption = false
			if isOption
				parts = List<of String>(arg.split(@[valuePrefix], 2))  # CC: should not need the List<of String>() call
				if parts.count==1
					name = parts[0] to String
					if name.endsWith('+')
						name = name[:-1]
						valueStr = 'on'
					else if name.endsWith('-')
						name = name[:-1]
						valueStr = 'off'
					else
						valueStr = 'on'
				else
					assert parts.count==2
					name = parts[0]
					valueStr = parts[1]
				assert name, parts
				assert valueStr, parts
				name = Utils.getSS(synToName to passthrough, name, name) to String
				if not specDict.containsKey(name)
					msg = 'No such option "[name]".'
					if name.contains(':')
						msg += ' If you meant to specify an option value, use equals (=) instead of colon (:).'
					.error(msg)
				spec = specDict[name]
				if Utils.getSO(spec to passthrough, 'isAccumulator', false)
					# accumulators are always treated as strings. TODO: assert that
					if valueDict.containsKey(name)
						(valueDict[name] to System.Collections.IList).add(valueStr to passthrough)
					else
						valueDict[name] = [valueStr]
				else
					cannotProcess = false
					if name=='debug'
						# special case
						if valueStr=='pdbonly' or valueStr=='full'
							value = valueStr
						else
							try
								value = .boolForString(valueStr)
							catch FormatException
								cannotProcess = true
							success
								value = if(value, '+', '-')
					else
						branch spec['type'] to String
							on 'main'
								mainOptions.add(name)
								value = true
							on 'bool'
								try
									value = .boolForString(valueStr)
								catch FormatException
									cannotProcess = true
							on 'int'
								try
									value = int.parse(valueStr)
								catch FormatException
									cannotProcess = true
								catch OverflowException
									cannotProcess = true
								# TODO: check min and max
							on 'string'
								if valueStr.length==0
									cannotProcess = true
								value = valueStr
							on 'menu'
								if valueStr.length==0
									cannotProcess = true
								if not (spec['choices'] to System.Collections.IList).contains(valueStr)
									cannotProcess = true
								else
									value = valueStr
					if cannotProcess
						.error('Cannot process value "[valueStr]" for option "[name]".')
					valueDict[name] = value
			else # not isOption
				if File.exists(arg)
					fileList.add(arg)
				else if File.exists(arg+'.cobra')
					fileList.add(arg+'.cobra')
				else if Directory.exists(arg)
					fileList.add(arg)
				else
					msg = 'Cannot find "[arg]" as a file.'
					if arg.startsWith('/')
						msg += ' If you meant to specify an option, use dash (-) instead of slash (/).'
					.error(msg)

		# TODO: make the option names case-insensitive

		# handle synonyms
		for syn2 in synList  # CC: change syn2 to syn
			if valueDict.containsKey(syn2)
				valueDict[synToName[syn2]] = valueDict[syn2]
				valueDict.remove(syn2)

		# check for more than one main option
		if mainOptions.count > 1
			.error('Cannot have these main options at the same time: [Utils.join(", ", mainOptions)]')

		# unpack certain options into specific class fields
		if valueDict.containsKey('verbosity')
			_verbosity = valueDict['verbosity'] to int
		if not valueDict.containsKey('timeit') and valueDict.containsKey('testify')
			valueDict['timeit'] = true
		if valueDict.containsKey('timeit')
			CobraMain.willTimeIt = valueDict['timeit'] to bool
		if valueDict.containsKey('files')
			for fileName as String in (valueDict['files'] to System.Collections.IList)
				try
					for line as String in File.readAllLines(fileName)
						line = line.trim
						if line.length==0 or line.startsWith('#')
							continue
						# TODO: dup'ed above
						arg = line
						if File.exists(arg)
							fileList.add(arg)
						else if File.exists(arg+'.cobra')
							fileList.add(arg+'.cobra')
						else if Directory.exists(arg)
							fileList.add(arg)
						else
							msg = 'Cannot find "[arg]" as a file.'
							#if arg.startsWith('/')
							#	msg += ' If you meant to specify an option, use dash (-) instead of slash (/).'
							.error(msg)
						# end dup
				catch IOException
					.error('Cannot open file "[fileName]".')

		# set the class vars
		_optionDict = valueDict
		_pathList = fileList

	def doCompile(paths as List<of String>) as Compiler
		return .doCompile(paths, true, false)

	def doCompile(paths as List<of String>, willPrintSuccessMsg as bool, writeTestInvocation as bool) as Compiler
		c = Compiler(.verbosity)
		c.options = _optionDict to Dictionary<of String, Object>    # CC: to !, CC: use extended syntax  # TODO
		c.willPrintSuccessMsg = willPrintSuccessMsg
		try
			c.parseFilesNamed(paths)
			c.bindInt
			c.bindImp
			c.writeSharp
			if writeTestInvocation
				c.writeSharpTestInvocation
				c.compileCS('/main:RunTests')
			else
				c.compileCS
			c.printMessages
		catch StopCompilation
			# Each phase of the compiler may throw an exception to stop compilation.
			# Before doing so, it prints its errors.
			assert c.errors.count>0
			if _optionDict.containsKey('editor')
				spec = _optionDict['editor'] to String?
			else
				spec = Environment.getEnvironmentVariable('COBRA_EDITOR')
			if spec and spec <> ''
				if spec.indexOf('FILE')==-1
					.error('Missing FILE from editor spec.')
				if spec.indexOf('LINE')==-1
					.error('Missing LINE from editor spec.')
				i = spec.indexOf('_')
				if i == -1
					i = spec.indexOf(' ')
					if i == -1
						.error('Missing underscore or space from editor spec.')
				exeName = spec.substring(0, i)
				args = spec.substring(i+1)
				for error in c.errors
					if error inherits ISourceError
						if error.fileName and error.fileName.trim <> ''
							args = args.replace('FILE', error.fileName)
							args = args.replace('LINE', error.lineNum.toString)
							p as System.Diagnostics.Process = $sharp('new System.Diagnostics.Process()')
							p.startInfo.fileName = exeName
							p.startInfo.arguments = args
							if _verbosity >= 3
								print 'About to run: [p.startInfo.fileName] [p.startInfo.arguments]'
							p.startInfo.useShellExecute = false
							p.start
							p.waitForExit  # TODO: is this really needed?
							break
		return c

	def doTest(paths as List<of String>)
		c = .doCompile(paths, false, true)
		if c.errors.count
			print 'Not running tests due to errors above.'
			return
		testInvoker = c.modules[c.modules.count-1]  # CC: .last
		assert testInvoker inherits SharpModule
		assert testInvoker.fileName.startsWith('test-')
		File.delete(testInvoker.fileName)
		try
			p as System.Diagnostics.Process = $sharp('new System.Diagnostics.Process()')
			# TODO: support args to the program with a - or -- separator
			branch c.platform
				on PlatformEnum.Microsoft
					p.startInfo.fileName = c.baseExeFileName
				on PlatformEnum.Novell
					p.startInfo.fileName = 'mono'
					p.startInfo.arguments = c.fullExeFileName
				else
					throw FallThroughException(c.platform)
			if _verbosity >= 3
				print 'About to run: [p.startInfo.fileName] [p.startInfo.arguments]'
			p.startInfo.useShellExecute = false
			p.start
			p.waitForExit  # TODO: is this necessary?
		catch
			File.delete(c.fullExeFileName)
			throw
		success
			File.delete(c.fullExeFileName)

	def doRun(paths as List<of String>)
		c = .doCompile(paths, false, false)
		if c.errors.count
			print 'Not running due to errors above.'
		else
			p as System.Diagnostics.Process = $sharp('new System.Diagnostics.Process()')
			branch c.platform
				on PlatformEnum.Microsoft
					p.startInfo.fileName = c.baseExeFileName
					# TODO: support args to the program with a - or -- separator (and for Novell below)
					# p.startInfo.arguments = ...
				on PlatformEnum.Novell
					p.startInfo.fileName = 'mono'
					p.startInfo.arguments = c.fullExeFileName
				else
					throw FallThroughException(c.platform)
			if _verbosity >= 3
				print 'About to run: [p.startInfo.fileName] [p.startInfo.arguments]'
			p.startInfo.useShellExecute = false
			p.start
			p.waitForExit  # TODO: is this necessary?

	def doHelp
		# CC: multiline string
		.doAbout
		print ''
		print 'Usage:'
		print ''
		print '  cobra <options> <filename>'
		print '    * run filename'
		print '    * compile if needed'
		print '    * .cobra extension is optional'
		print ''
		print '  cobra <options> <command> <path(s)>'
		print '    * commands that operate on path(s) are:'
		print '      -compile ... Compile only.'
		print '      -run ....... Run the program (compile if necessary).'
		print '      -test ...... Run the unit tests of a library.'
		print ''
		print '  cobra <options> <command>'
		print '    * standalone commands are:'
		print '      -help ...... Print full help information.'
		print '      -about ..... Print name, copyright, etc. no usage.'
		print '      -version ... Print just the version number ([.versionString]).'
		print ''
		print '  <options> can be:'

		# print options from their specs (but not the main ones which are covered above)
		leftMargin = 8
		leftMarginStr = '        '
		consoleWidth = Console.windowWidth
		if consoleWidth < 1
			consoleWidth = Console.bufferWidth
		totalWidth = consoleWidth - 2
		if totalWidth < 0
			totalWidth = 0
		if totalWidth == 0
			totalWidth = 78
		else if totalWidth < 20
			totalWidth = 20
		assert totalWidth > 0
		width = totalWidth - leftMargin
		assert width > 0
		for spec in _optionSpecs
			if spec.containsKey('type') and spec['type']=='main' # CC: spec.get('main', '')
				continue
			print
			print '    -[spec["name"]]' stop
			if spec.containsKey('args')
				print '=[spec["args"]]'
			else if spec['type']=='bool'
				print r'[=0|1]'
			else
				print
			if spec.containsKey('synonyms')
				print '    ' stop
				sep = ''
				for syn as String in (spec['synonyms'] to System.Collections.IList) # CC: shouldn't need either cast
					print '[sep]-[syn]' stop
					sep = ', '
				print
			s = spec['description'] to String
			while s.length
				if s.length < width
					print '[leftMarginStr][s]'
					s = ''
				else
					# TODO: bug in here for narrow widths. try "width = 20" to reproduce
					j = width+1
					if j >= s.length
						j = s.length - 1
					while j > 0 and s[j] <> ' '
						j -= 1
					if j
						sub = s.substring(0, j)
						s = if(s.length, s.substring(j+1), '')
						print '[leftMarginStr][sub]'
			if spec.containsKey('example')
				if spec['example'] inherits System.Collections.IList
					first = true
					for example in spec['example'] to System.Collections.IList
						if first
							print '        Examples: ' stop
						else
							print '                  ' stop
						print '-[spec["name"]]=[example]'
						first = false
				else
					print '        Example: -[spec["name"]]=[spec["example"]]'

	def doAbout
		# CC: multiline string
		print 'The Cobra Programming Language [.versionString]'
		print 'Copyright (C) 2003-[DateTime.now.year] by Cobra Language LLC.  All Rights Reserved.'
		print ''
		print 'On the web:  http://CobraLang.com/'
		print 'License:     See Cobra/Docs/License.text'
		# TODO: print '             http://CobraLang.com/Docs/License.text'
		print 'Usage:       cobra -h'

	def doVersion
		print .versionString

	def boolForString(s as String) as bool
		if s.toLower in ['', '+', 'on', 'true', 'yes']
			return true
		else if s.toLower in ['-', 'off', 'false', 'no']
			return false
		else
			throw FormatException()

	## Self Services

	def error(msg as String)
		if msg.length
			print 'cobra: error: [msg]'
			print 'Run Cobra without options to get full usage information.'
		Environment.exit(1)

	def exit(codee as int)  # rename to code
		print 'Exiting with code [codee]'
		.testifyFinish('Failure.')
		Environment.exit(codee)


	## Testify

	var _testifyCount as int

	var _failureCount as int

	var _firstAttempt as bool

	# two writers for testify:
	var _statusWriter as IndentedWriter?
	var _statusCount as int
	var _resultsWriter as IndentedWriter?

	def doTestify(paths as List<of String>)
		"""
		Used internally for testing cobra during development.
		Why not just 'test'? because that is reserved for regular developers to run true unit tests.
		"""
		_statusWriter = IndentedWriter(Console.out)
		_statusWriter.indentString = '    '
		try
			using resultsWriter = File.createText('r-run')
				_resultsWriter = IndentedWriter(resultsWriter)
				print to _resultsWriter
					_innerDoTestify(paths)
		finally
			_statusWriter = nil

	def _testifyFlush
		_statusWriter.flush
		_resultsWriter.flush

	def _innerDoTestify(paths as List<of String>)
		# TODO Console.error = Console.out
		if paths.count==0
			paths = [.cobraTestsPath]
		_testifyCount = 0
		for pathName in paths
			if Directory.exists(pathName)
				.testifyDir(pathName)
			else if File.exists(pathName)
				_testifyCount += .testifyFile(pathName)
			else
				.error('No such directory or file named "[pathName]".')
		.testifyFinish(if(_failureCount, 'Failure.', 'Success.'))

	def testifyFinish(message as String)
		_testifyFinish(message, _statusWriter to TextWriter)  # CC: to !
		_testifyFinish(message, _resultsWriter to TextWriter)  # CC: to !

	def _testifyFinish(message as String, writer as TextWriter)
		print to writer
			duration = DateTime.now.subtract(_startTime)
			print
			print '[_testifyCount] Tests in [duration].'
			if _failureCount
				print '[_failureCount] Failures.'
			print
			print message

	def testifyDir(dirName as String)
		"""
		Returns the number tests that passed.
		"""
		# CC: baseNamex --> baseName
		baseNamex = Path.getFileName(dirName)  # gets rid of "." and ".." as prefix for relative dirs
		if baseNamex.startsWith('.') or baseNamex.startsWith('_')
			# examples: .svn, _svn. Also, _ is a nice way to temporarily exclude a directory if possible
			return
		_statusWriter.writeLine('[dirName]')
		_statusWriter.indent
		try
			print 'Running tests in [dirName]'
			saveDir = Environment.currentDirectory
			Directory.setCurrentDirectory(dirName)
			try
				paths = List<of String>(Directory.getFiles('.'))
				paths.addRange(Directory.getDirectories('.'))
				paths.sort
				for baseName in paths
					baseName = Utils.normalizePath(baseName)
					if baseName.endsWith('.cobra')
						_testifyCount += .testifyFile(baseName)
					else if Directory.exists(baseName)
						.testifyDir(baseName)
					_testifyFlush
			finally
				Directory.setCurrentDirectory(saveDir)
		finally
			_statusWriter.dedent
		_testifyFlush

	def testifyFile(baseName as String) as int
		save = _failureCount
		_firstAttempt = true
		try
			result1 = _testifyFile(baseName)
			if _failureCount > save
				print
				print
				print 'DUE TO FAILURE, RERUNNING WITH MORE OUTPUT:'
				_firstAttempt = false
				result2 = _testifyFile(baseName)
				if result1 <> result2
					throw Exception('Result mismatch. result1=[result1], result2=[result2]')
		finally
			_testifyFlush
		return result1

	def _testifyFile(baseName as String) as int
		verbose = not _firstAttempt
		if Path.pathSeparator in baseName
			return .testifyFilePath(baseName)

		_statusWriter.writeLine('([_statusCount]) [baseName]')
		_statusCount += 1
		assert File.exists(baseName)

		source = File.readAllText(baseName)
		bar = '----------------------------------------------------------------------------------------------------'

		print
		print
		print
		print 'RUN [baseName]'
		print '    [Utils.combinePaths(Environment.currentDirectory, baseName)]'
		print '    Test #[_testifyCount+1]'
		print bar
		print bar
		if verbose
			.printSource(source)
			print bar
		# TODO: why doesn't the following line work?
		# firstLine as String = source.split([c'\n'].toArray, 1)[0]  # CC: axe "as String"
		firstLine = source.split(c'\n')[0] to String

		firstLineInsensitive = firstLine.trim.replace(' ', '')
		if firstLineInsensitive.startsWith('#.error.')
			# CC: support split with a String extension method
			# error = firstLine.split('.error.',1)[1].trim.toLower
			index = firstLine.indexOf('.error.')
			error = firstLine.substring(index+7).trim.toLower
			try
				c = Compiler(_verbosity)
				c.parseFilesNamed([baseName])
				if verbose
					c.dumpModulesForTestify(_resultsWriter, 'Modules after parsing')
					print bar
				c.bindInt
				c.bindImp
				if verbose
					c.dumpModulesForTestify(_resultsWriter, 'Modules after binding')
					print bar
			catch StopCompilation
				assert c.errors
				expectedErrors = List<of String>(error.split(c'&')) # CC: axe List<of String> instantiation
				for i = 0 .. expectedErrors.count
					expectedError = expectedErrors[i].trim
					print 'Expecting error substring [i+1] of [expectedErrors.count]: **[expectedError]**'
					if i >= c.errors.count
						print 'Ran out of real errors.'
						.failed
						return 0
					actualError = c.errors[i]
					if actualError.message.toLower.indexOf(expectedError)==-1
						print 'Actual error is: **[actualError.message]**'
						.failed
						return 0
					else
						print 'Matches: "[actualError.message]"'
				if c.errors.count > expectedErrors.count
					print 'There are more actual errors than expected errors:'
					for j = expectedErrors.count .. c.errors.count  # CC: say for i
						print 'Another actual error: [c.errors[j].message]'
					.failed
					return 0
			catch exc as Exception
				print 'Internal exception: [exc]'
				.failed
				return 0
			success
				print 'Expecting error(s): [error]'
				print 'No error at all.'
				.failed
				return 0
			return 1

		if firstLineInsensitive.startsWith('#.warning.')
			index = firstLine.indexOf('.warning.')
			warning = firstLine.substring(index+9).trim.toLower
			# TODO: the following code both checks for warnings to be thrown as well as going through a list of warnings. Seems like it should just need to do one or the other.
			try
				c = Compiler(_verbosity)
				c.parseFilesNamed([baseName])
				if verbose
					c.dumpModulesForTestify(_resultsWriter, 'Modules after parsing')
					print bar
				c.bindInt
				c.bindImp
				if verbose
					c.dumpModulesForTestify(_resultsWriter, 'Modules after binding')
			catch StopCompilation
				print 'Expecting warning substring: "[warning]"'
				print 'But got errors.'
				.failed
				return 0
			catch exc as Exception
				print 'Internal exception: [exc]'
				.failed
				return 0
			expectedWarnings = List<of String>(warning.split(c'&')) # CC: axe List<of String> instantiation
			for i = 0 .. expectedWarnings.count
				expectedWarning = expectedWarnings[i].trim
				print 'Expecting warning substring [i+1] of [expectedWarnings.count]: **[expectedWarning]**'
				if i >= c.warnings.count
					print 'Ran out of real warnings.'
					.failed
					return 0
				actualWarning = c.warnings[i]
				if actualWarning.message.toLower.indexOf(expectedWarning)==-1
					print 'Actual warning is: **[actualWarning.message]**'
					.failed
					return 0
				else
					print 'Matches: "[actualWarning.message]"'
			if c.warnings.count > expectedWarnings.count
				print 'There are more actual warnings than expected warnings:'
				for j = expectedWarnings.count .. c.warnings.count  # CC: say for i
					print 'Another actual warning: [c.warnings[j].message]'
				.failed
				return 0
			return 1

		if firstLineInsensitive.startsWith('#.skip.')
			print 'Skipping per directive on first line of test source.'
			return 0

		if firstLineInsensitive.startsWith('#.multipart.')
			# .multi. is the one that gets run along with its associated files
			# the associated files then specify .multipart. and get skipped when encountered
			print 'Skipping per directive on first line of test source.'
			return 0

		fileNames = [baseName]

		if firstLineInsensitive.startsWith('#.multi.')
			print 'Running multiple files.'
			for fileName as String in firstLine.substring(firstLine.indexOf('.multi.')+8).split  # CC: axe "as String"
				if fileName.length
					fileNames.add(Utils.combinePaths(Path.getDirectoryName(baseName), fileName))
			print fileNames

		c = Compiler(_verbosity)

		try
			c.parseFilesNamed(fileNames)
			assert c.modules
			if verbose
				c.dumpModulesForTestify(_resultsWriter, 'Modules after parsing')
				print bar

			print 'Bind interface:'
			c.bindInt
			print 'Bind implementation:'
			c.bindImp
			if verbose
				c.dumpModulesForTestify(_resultsWriter, 'Modules after binding')
				print bar

			print 'Generate C#:'
			c.writeSharp
			if verbose
				# CC: shouldn't need to rename to 'module2'
				for module2 as Module in c.modules
					if not module2.isCobraLibrary
						.printSource(module2.csSource)
				print bar

			print 'Compile C#:'
			c.compileCS
			if verbose
				c.printMessages
				print bar
		catch StopCompilation
			.failed
			return 0
		catch exc as Exception
			print 'Internal exception: [exc]'
			.failed
			return 0

		print 'Run:'
		p as System.Diagnostics.Process = $sharp('new System.Diagnostics.Process()')
		if _verbosity >= 1
			print 'c.fullExeFileName = "[c.fullExeFileName]"'
		p.startInfo.fileName = c.baseExeFileName + if(c.platform==PlatformEnum.Novell, '.exe', '')
		if _verbosity >= 2
			print '[p.startInfo.fileName] [p.startInfo.arguments]'
		p.startInfo.redirectStandardOutput = true
		p.startInfo.redirectStandardError = true
		p.startInfo.useShellExecute = false
		output = CobraCore.runAndCaptureAllOutput(p)

		print 'Output:'
		print output
		if output.toLower.indexOf('unhandled exception')<>-1
			.failed
			return 0

		print bar

		return 1

	def failed
		"""
		Produces output and increments the failure count,
		but does not throw an exception or exit.
		"""
		if _firstAttempt
			_statusWriter.writeLine('FAILURE ----------------------------------------------------------------------')
			_failureCount += 1
			print
			print
			print 'TEST FAILURE. SEE BELOW FOR VERBOSE RERUN.'

	def testifyFilePath(pathName as String) as int
		dirName = Path.getDirectoryName(pathName)
		baseName = Path.getFileName(pathName)
		saveDir = Environment.currentDirectory
		Directory.setCurrentDirectory(dirName)
		try
			return .testifyFile(baseName)
		finally
			Directory.setCurrentDirectory(saveDir)

	def printSource(src as String)
		lineNum = 1
		for line as String in src.split(c'\n')  # CC: axe "as String"
			line = line.replace("\t", "    ")
			print '[lineNum]|[line]'  # CC: right align and pad 0 the lineNum
			lineNum += 1
