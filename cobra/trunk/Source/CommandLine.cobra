"""
Cobra Command Line Program (compiler and more)

"""


class CobraCommandLine

	var _startTime as DateTime
	var _verbosity = 3
	var _output as IndentedWriter

	def construct
		_startTime = DateTime.now
		_output = IndentedWriter(Console.out)
		_output.indentString = '    '

	get testPath as String
		return r'C:\All\echuck\Projects\Cobra\Cobra\Tests'

	get versionString as String
		return '0.2'

	get verbosity as int
		return _verbosity

	## Self Services

	def error(msg as String)
		if msg
			print 'cobra: error: [msg]'
			print 'Run Cobra without options to get full usage information.'
		Environment.exit(1)

	def exit(codee as int)  # rename to code
		print 'Exiting with code [codee]'
		.testifyFinish('Failure.')
		Environment.exit(codee)

	def run
		args = CobraCore.commandLineArgs
		if args.count==2
			.handle_testifyPaths([args[1]])
		else
			.handle_testify()

	def handle_compile(paths as List<of String>) as Compiler
		# paths = paths or self.fileList  # TODO
		c = Compiler(.verbosity)
		c.whenError = ErrorActionEnum.Exit  # CC: use extended syntax
		# c.options = _optionDict    # CC: use extended syntax  # TODO
		c.parseFilesNamed(filenames=paths)
		c.bindInt()
		c.bindImp()
		c.writeSharp()
		c.compileCS()
		return c

	var _testifyCount as int

	def handle_testify
		.handle_testifyPaths([.testPath])

	def handle_testifyPaths(paths as List<of String>)
		"""
		Used internally for testing cobra during development.
		Why not just 'test'? because that is reserved for regular developers to run true unit tests.
		"""
		# TODO Console.error = Console.out
		# TODO: respect command line args: paths = _fileList
		_testifyCount = 0
		for pathName in paths
			if Directory.exists(pathName)
				.testifyDir(pathName)
			else if File.exists(pathName)
				_testifyCount += .testifyFile(pathName)
			else
				.error('No such directory or file named "[pathName]".')
		.testifyFinish('Success.')

	def testifyFinish(message as String)
		duration = DateTime.now.subtract(_startTime)
		print
		print '[_testifyCount] Tests in [duration].'
		print
		print message

	def testifyDir(dirName as String)
		"""
		Returns the number tests that passed.
		"""
		print 'Running tests in [dirName]'
		saveDir = Environment.currentDirectory
		Directory.setCurrentDirectory(dirName)
		try
			paths = List<of String>(Directory.getFiles('.'))
			paths.addRange(Directory.getDirectories('.'))
			paths.sort()
			for baseName in paths
				pathName = Utils.combinePaths(dirName, baseName)
				if baseName.endsWith('.cobra')
					# used for profiling when not all tests passed
					#if _testifyCount>29
					#	print 'Exiting early on purpose.'
					#	return
					_testifyCount += .testifyFile(baseName)
				else if Directory.exists(baseName)
					.testifyDir(baseName)
		finally
			Directory.setCurrentDirectory(saveDir)

	def testifyFile(baseName as String) as int
		if Path.pathSeparator in baseName
			return .testifyFilePath(baseName)

		assert File.exists(baseName), baseName

		source = File.readAllText(baseName)
		bar = '----------------------------------------------------------------------------------------------------'

		print
		print
		print
		print 'RUN [baseName]'
		print '    [Utils.combinePaths(Environment.currentDirectory, baseName)]'
		print '    Test #[_testifyCount+1]'
		print bar
		print bar
		.printSource(source)

		print bar
		# TODO: why doesn't the following line work?
		# firstLine as String = source.split([c'\n'].toArray(), 1)[0]  # CC: axe "as String"
		firstLine = source.split(c'\n')[0] to String

		firstLineInsensitive = firstLine.trim().replace(' ', '')
		if firstLineInsensitive.startsWith('#.error.')
			# CC: support split() with a String extension method
			# error = firstLine.split('.error.',1)[1].trim().toLower()
			index = firstLine.indexOf('.error.')
			error = firstLine.substring(index+7).trim().toLower()
			try
				c = Compiler(_verbosity, ErrorActionEnum.Throw, WarningActionEnum.Print)
				c.parseFilesNamed([baseName])
				c.dumpModulesForTestify(_output, 'Modules after parsing')
				c.bindInt()
				c.bindImp()
				c.dumpModulesForTestify(_output, 'Modules after binding')
			catch ce as CobraException
				if ce.message.toLower().indexOf(error)==-1
					print 'Expecting error substring: **[error]**'
					print 'Actual error is: **[ce.message]**'
					.exit(1)
			success
				print 'Expecting error substring: [error]'
				print 'No error at all.'
				.exit(1)
			print 'Expected error occurred: [error] in "[ce.message]"'
			return 1

		if firstLineInsensitive.startsWith('#.warning.')
			index = firstLine.indexOf('.warning.')
			warning = firstLine.substring(index+9).trim().toLower()
			# TODO: the following code both checks for warnings to be thrown as well as going through a list of warnings. Seems like it should just need to do one or the other.
			try
				c = Compiler(_verbosity, ErrorActionEnum.Throw, WarningActionEnum.Throw)
				c.parseFilesNamed([baseName])
				c.dumpModulesForTestify(_output, 'Modules after parsing')
				c.bindInt()
				c.bindImp()
				c.dumpModulesForTestify(_output, 'Modules after binding')
			catch cw as CobraWarning
				if cw.message.toLower().indexOf(warning)==-1
					print 'Expecting warning substring: "[warning]"'
					print 'Actual warning is: "[cw.message]"'
					Environment.exit(1)
				print 'Expected warning occurred: "[warning]" in "[cw.message]"'
				return 1
			found = false
			for cw in c.warnings
				if cw.message.toLower().indexOf(warning)<>-1
					found = true
					break
			if found
				print 'Expected warning occurred: "[warning]" in "[cw.message]"'
				return 1
			else
				print 'Expecting warning substring: "[warning]"'
				print 'No warning at all.'
				Environment.exit(1)

		if firstLineInsensitive.startsWith('#.skip.')
			print 'Skipping per directive on first line of test source.'
			return 0

		if firstLineInsensitive.startsWith('#.multipart.')
			print 'Skipping per directive on first line of test source.'
			return 0

		fileNames = [baseName]

		if firstLineInsensitive.startsWith('#.multi.')
			print 'Running multiple files.'
			for fileName as String in firstLine.substring(firstLine.indexOf('.multi.')+8).split()  # CC: axe "as String"
				if fileName
					fileNames.add(Utils.combinePaths(Path.getDirectoryName(baseName), fileName))
			print fileNames

		c = Compiler(_verbosity, ErrorActionEnum.Exit)  # not expecting an error

		c.parseFilesNamed(fileNames)
		assert c.modules
		c.dumpModulesForTestify(_output, 'Modules after parsing')

		print 'Bind interface:'
		c.bindInt()
		print 'Bind implementation:'
		c.bindImp()
		c.dumpModulesForTestify(_output, 'Modules after binding')

		print bar
		print 'Generate C#:'
		c.writeSharp()
		# CC: shouldn't need to rename to 'module2'
		for module2 as Module in c.modules.getRange(1, c.modules.count-1)  # CC: axe "as Module"
			.printSource(module2.csSource)

		print bar
		print 'Compile C#:'
		c.compileCS()

#		print bar
#		print 'Run:'
#		childIn, childOut = os.popen4(c.exeFilename)
#		output = childOut.read()
#		sys.stdout.write(output)
#		if output.lower().find('unhandled exception')!=-1:
#			print
#			print
#			if 0:
#				# from Module.compile(); not yet adapted:
#				errors = []
#				for line in output.split('\n'):
#					if line.find(' error ')!=-1:
#						errors.append(line)
#			raise ExecutionError
		print bar

		return 1

	def testifyFilePath(pathName as String) as int
		dirName = Path.getDirectoryName(pathName)
		baseName = Path.getFileName(pathName)
		saveDir = Environment.currentDirectory
		Directory.setCurrentDirectory(dirName)
		try
			return .testifyFile(baseName)
		finally
			Directory.setCurrentDirectory(saveDir)

	def printSource(src as String)
		lineNum = 1
		for line as String in src.split(c'\n')  # CC: axe "as String"
			line = line.replace("\t", "    ")
			print '[lineNum]|[line]'  # CC: right align and pad 0 the lineNum
			lineNum += 1
