"""
Cobra Command Line Program (compiler and more)

"""


class CobraCommandLine  # TODO: rename to CommandLine

	get versionString as String
		return '0.2'

	var _optionSpecs = [
		{
			'name': 'reference',
			'synonyms': ['r'],
			'isAccumulator': true,
			'description': 'Add a DLL reference.',
		},
		{
			'name': 'superstacktrace',
			'synonyms': ['sst'],
			'type': 'bool',
			'description': 'Enable super stack trace which gives great postmortem information for uncaught exceptions, but slows execution.',
		},
		{
			'name': 'verbosity',
			'synonyms': ['verbose', 'v'],
			'type': 'int',
			'min': 0,
			'max': 1,
			'description': 'Enable extra output from Cobra. Mostly useful for debugging Cobra.',
		},
		{
			'name': 'help',
			'synonyms': ['h'],
			'type': 'bool',
			'description': 'Display this help message.',
		},
		{
			'name': 'debug',
			'type': 'bool',
			'description': 'Turn on system debugging information.',
		},
		{
			'name': 'editor',
			'description': 'Specify an editor and command line options to invoke if there is a compile-time error. Use underscore (_) for space in the specification.',
			'example': 'uedit32_FILE/LINE',
		},
		{
			'name': 'testify',
			'description': '...',
			'type': 'bool',
			'hidden': true,
			'excludes': ['run', 'compile', 'test'],
		},
		{
			'name': 'compile',
			'description': 'Compile the library (to DLL) or the program (to EXE) without running the code.',
			'type': 'bool',
			'excludes': ['run', 'test'],
		},
		{
			'name': 'test',
			'description': 'Run the unit tests in the code.',
			'type': 'bool',
			'excludes': ['compile', 'run'],
		},
		{
			'name': 'run',
			'description': 'Runs the Cobra program. This is the default behavior if specify any Cobra source files.',
			'type': 'bool',
			'excludes': ['compile', 'test'],
		},
	]

	var _startTime as DateTime
	var _verbosity = 0
	var _output as IndentedWriter

	var _optionDict as Dictionary<of String, Object>
	var _pathList as List<of String>

	def init
		_startTime = DateTime.now
		_output = IndentedWriter(Console.out)
		_output.indentString = '    '

	get cobraTestsPath as String
		"""
		Only used when --testify is passed with no path.
		--testify is an "internal" feature of the cobra command line front end.
		"""
		return r'C:\All\echuck\Projects\Cobra\Cobra\Tests'

	get verbosity as int
		return _verbosity

	def run
		"""
		Run the command line using the command line arguments.
		"""
		args = CobraCore.commandLineArgs # CC: [1:] and then axe next line
		args = args.getRange(1, args.count-1)
		.run(args)

	def run(args as List<of String>)
		"""
		Run the command line using the given arguments.
		The `args` should include only the arguments and not the executable/program name.
		"""
		.parseArgs(args)
		d = _optionDict
		paths = _pathList
		if _getOne(d, 'testify')
			.doTestify(paths)
		else if _getOne(d, 'run')
			.doRun(paths)
		else if _getOne(d, 'test')
			.doTest(paths)
		else if _getOne(d, 'compile')
			.doCompile(paths)
		else if _getOne(d, 'help')
			.doHelp()
		else
			.doRun(paths)

	def _getOne(d as Dictionary<of String, Object>, name as String) as bool
		if d.containsKey(name)
			value = d[name]
			if value inherits bool
				return value
			else
				throw FallThroughException(value)
		else
			return false

	def parseArgs(args as List<of String>)
		"""
		Parse command line arguments.
		The `args` should include only the arguments and not the executable/program name.
		Sets _optionDict and _pathList.
		"""
		optionPrefix = '-'
		valuePrefix = c'='
		# TODO: support a valuePrefix of :
		# TODO: support an optionPrefix of / on Windows, but not posix
		if not args
			.doHelp()
			return

		specDict = Dictionary<of String, Dictionary<of String, Object> >()
			# ^ will contain keys for all spec names and their synonyms
		synToName = Dictionary<of String, String>()
			# ^ maps synonyms to their full names
		synList = List<of String>()
		for specObj in _optionSpecs
			# since some _optionSpecs are Dictionary<of String, Object> and others are
			# Dictionary<of String, String> then _optionSpecs ends up being
			# Dictionary<of String, Object>

			# CC: if foo is Dictionary<of String, Object>  ... does not seem to work
			if specObj inherits Dictionary<of String, Object>
				d = specObj
			else if specObj inherits Dictionary<of String, String>
				d = Dictionary<of String, Object>()
				for key in $sharp('((Dictionary<String, String>)specObj).Keys')
					d[key to String] = $sharp(r'((Dictionary<String, String>)specObj)[(String)key]')
			else
				throw FallThroughException(specObj.getType())
			specDict[d['name'] to String] = d
			if d.containsKey('synonyms')
				syns = d['synonyms']
				if true
					for syn as String in (syns to System.Collections.IList) # CC: shouldn't need either cast
						assert not specDict.containsKey(syn), key
						specDict[syn] = d
						synToName[syn] = d['name'] to String
						synList.add(syn)
			if not d.containsKey('type')
				d.add('type', 'string')

		valueDict = Dictionary<of String, Object>()
		# TODO: remove: optionValueList = Dictionary<of String, List<of Object>>()
		fileList = List<of String>()
		value = "no-value" to Object  # for typing
		for arg in args
			if arg.startsWith(optionPrefix)
				isOption = true
				while arg.startsWith(optionPrefix)
					arg = arg.substring(1)
			else
				isOption = false
			if isOption
				parts = List<of String>(arg.split($sharp(r'new char[] {valuePrefix}'), 2))  # CC: should not need the List<of String() call
				if parts.count==1
					name = parts[0] to String
					if name.endsWith('+')
						name = name.substring(0, name.length-1) # [..-1]
						valueStr = 'on'
					else if name.endsWith('-')
						name = name.substring(0, name.length-1) # [..-1]
						valueStr = 'off'
					else
						valueStr = 'on'
				else
					assert parts.count==2
					name = parts[0]
					valueStr = parts[1]
				assert name, parts
				assert valueStr, parts
				name = Utils.getSS($sharp('synToName'), name, name) to String
				spec as Dictionary<of String, Object>?
				if specDict.containsKey(name)
					spec = specDict[name]
				if spec and Utils.getSO(spec to passthrough, 'isAccumulator', false)
					# accumulators are always treated as strings. TODO: assert that
					if valueDict.containsKey(name)
						(valueDict[name] to System.Collections.IList).add(valueStr to passthrough)
					else
						valueDict[name] = [valueStr]
				else
					cannotProcess = false
					branch spec['type'] to String
						on 'bool'
							if valueStr.toLower() in ['', '+', 'on', 'true', 'yes']
								value = true
							else if valueStr.toLower() in ['-', 'off', 'false', 'no']
								value = false
							else
								cannotProcess = true
						on 'int'
							try
								value = int.parse(valueStr)
							catch fe as FormatException
								cannotProcess = true
							catch oe as OverflowException
								cannotProcess = true
							# TODO: check min and max
						on 'string'
							if valueStr.length==0
								cannotProcess = true
					if cannotProcess
						.error('Cannot process value "[value]" for option "[name]".')
					valueDict[name] = value
				# TODO: remove: optionValueList.add((name, value))
			else # not isOption
				if File.exists(arg)
					fileList.add(arg)
				else if File.exists(arg+'.cobra')
					fileList.add(arg+'.cobra')
				else if Directory.exists(arg)
					fileList.add(arg)
				else
					.error('Cannot find "[arg]" as a file.')

		# TODO give an error for unknown command line options

		# TODO: remove: # TODO is the options list really needed?

		# TODO make the option names case-insensitive

		# handle synonyms
		for syn2 in synList  # CC: change syn2 to syn
			if valueDict.containsKey(syn2)
				valueDict[synToName[syn2]] = valueDict[syn2]
				valueDict.remove(syn2)

		# TODO: remove
		#if 0
		#	if len(optionList)<>len(optionDict)
		#		print '<> list = %r' % optionList
		#		print '<> dict = %r' % optionDict
		#		assert len(optionList)==len(optionDict)
		_optionDict = valueDict
		# TODO: remove: _optionList = optionList
		_pathList = fileList

		# unpack certain options into specific class fields
		if valueDict.containsKey('verbosity')
			_verbosity = valueDict['verbosity'] to int

		# TODO: enforce excludes


	def doCompile(paths as List<of String>) as Compiler
		# paths = paths or self.fileList  # TODO
		c = Compiler(.verbosity)
		c.whenError = ErrorActionEnum.Record  # CC: use extended syntax
		c.options = _optionDict    # CC: use extended syntax  # TODO
		try
			c.parseFilesNamed(paths)
			c.bindInt()
			c.bindImp()
			c.writeSharp()
			c.compileCS()
		catch ce as CobraException  # TODO: have Compiler._exitFromErrors throw a StopCompilationException instead
			# Each phase of the compiler may throw an exception to stop compilation.
			# Before doing so, it prints its errors.
			pass
		return c

	def doTestify
		.doTestify([.cobraTestsPath])

	def doTest(paths as List<of String>)
		.error('TEST: NOT IMPLEMENTED YET.')

	def doRun(paths as List<of String>)
		.error('RUN: NOT IMPLEMENTED YET.')

	def doHelp
		# CC: multiline string
		print 'The Cobra Programming Language [.versionString]'
		print 'Copyright (C) 2003-[DateTime.now.year] by Cobra Language LLC.  All Rights Reserved.'
		print ''
		print 'On the net:  http://CobraLang.com/'
		print 'License:     See License.text in Docs or'
		print '             http://CobraLang.com/Docs/License.text'
		print ''
		print 'Usage:'
		print ''
		print '  cobra <options> <filename>'
		print '    * run filename'
		print '    * compile if necessary'
		print '    * .cobra extension is optional'
		print ''
		print '  cobra <options> <command> <path>'
		print '    * path commands are:'
		print '      --compile ......... compile only'
		print '      --run ............. run the program (compile if necessary)'
		print '      --test ............ run the unit tests of a library'
		print ''
		print '  cobra <options> <command>'
		print '    * standalone commands are:'
		print '      --about ........... print name, copyright, etc. no usage'
		print '      --version ......... print just the version number (0.1.4)'
		print ''
		print '  <options> can be:'
		# TODO: complete this
#    --verbosity=N -- choose 0 to 5 for N. synonyms: -v=N, --verbose=N
#    --debug[=0|1] -- Emit debugging information.
#    --debug=(full|pdbonly) -- Specify debugging type ('full' is default and enables attaching
#                              a debugger to a running program)
#    --reference=Some.dll or -r=Some.dll -- Reference a DLL.

	## Self Services

	def error(msg as String)
		if msg
			print 'cobra: error: [msg]'
			print 'Run Cobra without options to get full usage information.'
		Environment.exit(1)

	def exit(codee as int)  # rename to code
		print 'Exiting with code [codee]'
		.testifyFinish('Failure.')
		Environment.exit(codee)


	## Testify

	var _testifyCount as int

	var _failureCount as int

	def doTestify(paths as List<of String>)
		"""
		Used internally for testing cobra during development.
		Why not just 'test'? because that is reserved for regular developers to run true unit tests.
		"""
		# TODO Console.error = Console.out
		# TODO: respect command line args: paths = _pathList
		if paths.count==0
			paths = [.cobraTestsPath]
		_testifyCount = 0
		for pathName in paths
			if Directory.exists(pathName)
				.testifyDir(pathName)
			else if File.exists(pathName)
				_testifyCount += .testifyFile(pathName)
			else
				.error('No such directory or file named "[pathName]".')
		.testifyFinish(if(_failureCount, 'Failure.', 'Success.'))

	def testifyFinish(message as String)
		duration = DateTime.now.subtract(_startTime)
		print
		print '[_testifyCount] Tests in [duration].'
		if _failureCount
			print '[_failureCount] Runtime Failures.'
		print
		print message

	def testifyDir(dirName as String)
		"""
		Returns the number tests that passed.
		"""
		print 'Running tests in [dirName]'
		saveDir = Environment.currentDirectory
		Directory.setCurrentDirectory(dirName)
		try
			paths = List<of String>(Directory.getFiles('.'))
			paths.addRange(Directory.getDirectories('.'))
			paths.sort()
			for baseName in paths
				pathName = Utils.combinePaths(dirName, baseName)
				if baseName.endsWith('.cobra')
					# used for profiling when not all tests passed
					#if _testifyCount>29
					#	print 'Exiting early on purpose.'
					#	return
					_testifyCount += .testifyFile(baseName)
				else if Directory.exists(baseName)
					.testifyDir(baseName)
		finally
			Directory.setCurrentDirectory(saveDir)

	def testifyFile(baseName as String) as int
		if Path.pathSeparator in baseName
			return .testifyFilePath(baseName)

		assert File.exists(baseName), baseName

		source = File.readAllText(baseName)
		bar = '----------------------------------------------------------------------------------------------------'

		print
		print
		print
		print 'RUN [baseName]'
		print '    [Utils.combinePaths(Environment.currentDirectory, baseName)]'
		print '    Test #[_testifyCount+1]'
		print bar
		print bar
		.printSource(source)

		print bar
		# TODO: why doesn't the following line work?
		# firstLine as String = source.split([c'\n'].toArray(), 1)[0]  # CC: axe "as String"
		firstLine = source.split(c'\n')[0] to String

		firstLineInsensitive = firstLine.trim().replace(' ', '')
		if firstLineInsensitive.startsWith('#.error.')
			# CC: support split() with a String extension method
			# error = firstLine.split('.error.',1)[1].trim().toLower()
			index = firstLine.indexOf('.error.')
			error = firstLine.substring(index+7).trim().toLower()
			try
				c = Compiler(_verbosity, ErrorActionEnum.Exit, WarningActionEnum.Print)
				c.parseFilesNamed([baseName])
				c.dumpModulesForTestify(_output, 'Modules after parsing')
				c.bindInt()
				c.bindImp()
				c.dumpModulesForTestify(_output, 'Modules after binding')
			catch ce as CobraException
				if ce.message.toLower().indexOf(error)==-1
					print 'Expecting error substring: **[error]**'
					print 'Actual error is: **[ce.message]**'
					.exit(1)
			success
				print 'Expecting error substring: [error]'
				print 'No error at all.'
				.exit(1)
			print 'Expected error occurred: [error] in "[ce.message]"'
			return 1

		if firstLineInsensitive.startsWith('#.warning.')
			index = firstLine.indexOf('.warning.')
			warning = firstLine.substring(index+9).trim().toLower()
			# TODO: the following code both checks for warnings to be thrown as well as going through a list of warnings. Seems like it should just need to do one or the other.
			try
				c = Compiler(_verbosity, ErrorActionEnum.Exit, WarningActionEnum.Throw)
				c.parseFilesNamed([baseName])
				c.dumpModulesForTestify(_output, 'Modules after parsing')
				c.bindInt()
				c.bindImp()
				c.dumpModulesForTestify(_output, 'Modules after binding')
			catch cw as CobraWarning
				if cw.message.toLower().indexOf(warning)==-1
					print 'Expecting warning substring: "[warning]"'
					print 'Actual warning is: "[cw.message]"'
					Environment.exit(1)
				print 'Expected warning occurred: "[warning]" in "[cw.message]"'
				return 1
			found = false
			for cw in c.warnings
				if cw.message.toLower().indexOf(warning)<>-1
					found = true
					break
			if found
				print 'Expected warning occurred: "[warning]" in "[cw.message]"'
				return 1
			else
				print 'Expecting warning substring: "[warning]"'
				print 'No warning at all.'
				Environment.exit(1)

		if firstLineInsensitive.startsWith('#.skip.')
			print 'Skipping per directive on first line of test source.'
			return 0

		if firstLineInsensitive.startsWith('#.multipart.')
			print 'Skipping per directive on first line of test source.'
			return 0

		fileNames = [baseName]

		if firstLineInsensitive.startsWith('#.multi.')
			print 'Running multiple files.'
			for fileName as String in firstLine.substring(firstLine.indexOf('.multi.')+8).split()  # CC: axe "as String"
				if fileName
					fileNames.add(Utils.combinePaths(Path.getDirectoryName(baseName), fileName))
			print fileNames

		c = Compiler(_verbosity, ErrorActionEnum.Exit)  # not expecting an error

		c.parseFilesNamed(fileNames)
		assert c.modules
		c.dumpModulesForTestify(_output, 'Modules after parsing')

		print 'Bind interface:'
		c.bindInt()
		print 'Bind implementation:'
		c.bindImp()
		c.dumpModulesForTestify(_output, 'Modules after binding')

		print bar
		print 'Generate C#:'
		c.writeSharp()
		# CC: shouldn't need to rename to 'module2'
		for module2 as Module in c.modules.getRange(1, c.modules.count-1)  # CC: axe "as Module"
			.printSource(module2.csSource)

		print bar
		print 'Compile C#:'
		c.compileCS()

		print bar
		print 'Run:'
		p as System.Diagnostics.Process = $sharp('new System.Diagnostics.Process()')
		p.startInfo.fileName = c.exeFileName
		# TODO: axe p.startInfo.arguments = options + ' ' + csFileNames + ' ' + cobraLangPath
		#if _verbosity >= 2  # TODO: restore
		if true
			print '[p.startInfo.fileName] [p.startInfo.arguments]'
		p.startInfo.redirectStandardOutput = true
		p.startInfo.redirectStandardError = true
		p.startInfo.useShellExecute = false
		# p.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden
		p.start()
		p.waitForExit()
		output = p.standardOutput.readToEnd()
		output += p.standardError.readToEnd()

		print 'Output:'
		print output
		if output.toLower().indexOf('unhandled exception')<>-1
			print
			print
			print 'RUNTIME TEST FAILURE. SEE ABOVE.'
			_failureCount += 1
		print bar

		return 1

	def testifyFilePath(pathName as String) as int
		dirName = Path.getDirectoryName(pathName)
		baseName = Path.getFileName(pathName)
		saveDir = Environment.currentDirectory
		Directory.setCurrentDirectory(dirName)
		try
			return .testifyFile(baseName)
		finally
			Directory.setCurrentDirectory(saveDir)

	def printSource(src as String)
		lineNum = 1
		for line as String in src.split(c'\n')  # CC: axe "as String"
			line = line.replace("\t", "    ")
			print '[lineNum]|[line]'  # CC: right align and pad 0 the lineNum
			lineNum += 1
