"""
Cobra Command Line Program (compiler and more)

"""


class CobraCommandLine

	var _startTime as DateTime
	var _verbosity = 3
	var _output as IndentedWriter

	def construct
		_startTime = DateTime.now
		_output = IndentedWriter(Console.out)
		_output.indentString = '    '

	get versionString as String
		return '0.1.1'

	get verbosity as int
		return _verbosity

	## Self Services

	def error(msg as String)
		if msg
			print 'cobra: error: [msg]'
			print 'Run Cobra without options to get full usage information.'
		Environment.exit(1)

	def run
		.handle_testify()

	def handle_compile(paths as List<of String>) as Compiler
		# paths = paths or self.fileList  # TODO
		c = Compiler(.verbosity)
		c.whenError = ProblemAction.Exit  # CC: use extended syntax
		# c.options = _optionDict    # CC: use extended syntax  # TODO
		c.parseFilesNamed(filenames=paths)
		c.bindInt()
		c.bindImp()
		c.genCS()
		c.compileCS()
		return c

	var _testifyCount as int

	def handle_testify
		"""
		Used internally for testing cobra during development.
		Why not just 'test'? because that is reserved for regular developers to run true unit tests.
		"""
		# TODO Console.error = Console.out
		# TODO: respect command line args: paths = _fileList
		paths = [r"C:\All\echuck\Projects\Cobra\Cobra\Tests"]
		_testifyCount = 0
		for pathName in paths
			if Directory.exists(pathName)
				.testifyDir(pathName)
			else if File.exists(pathName)
				.testifyFile(pathName)
			else
				.error('No such directory or file named "[pathName]".')
		.testifyFinish()

	def testifyFinish
		duration = DateTime.now.subtract(_startTime)
		print
		print '[_testifyCount] Tests Passed in [duration].'
		print
		print 'Success.'

	def testifyDir(dirName as String)
		"""
		Returns the number tests that passed.
		"""
		print 'Running tests in [dirName]'
		saveDir = Environment.currentDirectory
		Directory.setCurrentDirectory(dirName)
		try
			paths = List<of String>(Directory.getFiles('.'))
			paths.addRange(Directory.getDirectories('.'))
			paths.sort()
			for baseName in paths
				pathName = Path.combine(dirName, baseName)
				if baseName.endsWith('.cobra')
					_testifyCount += .testifyFile(baseName)
				else if Directory.exists(baseName)
					.testifyDir(baseName)
		finally
			Directory.setCurrentDirectory(saveDir)

	def testifyFile(baseName as String) as int
		if Path.pathSeparator in baseName
			return .testifyFilePath(baseName)

		assert File.exists(baseName), baseName

		source = File.readAllText(baseName)
		bar = '----------------------------------------------------------------------------------------------------'

		print
		print
		print
		print 'RUN [baseName]'
		print '    [Path.combine(Environment.currentDirectory, baseName)]'
		print '    Test #[_testifyCount+1]'
		print bar
		print bar
		.printSource(source)

		print bar
		firstLine as String = source.split([c'\n'].ToArray(), 1)[0]  # CC: axe "as String"
		firstLineInsensitive = firstLine.trim().replace(' ', '')
		if firstLineInsensitive.startsWith('#.error.')
			print 'TODO: cannot handle .error. test directive yet'
#			error = firstLine.split('.error.',1)[1].strip().lower()
#			success = false
#			try:
#				c = Compiler(self.verbosity, 'raise')
#				c.parseOne(filename=basename, source=source)
#				c.bindInt()
#				c.bindImp()
#				success = true
#			except CobraError, ce:
#				#if ce.errorMessage.lower().find(error)==-1:
#				if str(ce).lower().find(error)==-1:
#					print 'Expecting error substring: %r' % error
#					print 'Actual error is: %s' % ce
#					sys.exit(1)
#			if success:
#				print 'Expecting error substring: %r' % error
#				print 'No error at all.'
#				sys.exit(1)
#			print 'Expected error occurred: %r in %s' % (error, ce)
#			return 1

		if firstLineInsensitive.startsWith('#.warning.')
			print 'TODO: cannot handle .warning. directive yet'
#			warning = firstLine.split('.warning.',1)[1].strip().lower()
#			success = false
#			try:
#				c = Compiler(self.verbosity, 'raise')
#				c.parseOne(filename=basename, source=source, whenWarning='raise')
#				c.bindInt()
#				c.bindImp()
#				success = true
#			except CobraWarning, cw:
#				if str(cw).lower().find(warning)==-1:
#					print 'Expecting warning substring: %r' % warning
#					print 'Actual warning is: %s' % cw
#					sys.exit(1)
#				print 'Expected warning occurred: %r in %s' % (warning, cw)
#				return 1
#			found = false
#			for w in c.warnings:
#				if w.msg.lower().find(warning)!=-1:
#					found = true
#					break
#			if found:
#				print 'Expected warning occurred: %r in %s' % (warning, w.msg)
#				return 1
#			else:
#				print 'Expecting warning substring: %r' % warning
#				print 'No warning at all.'
#				sys.exit(1)

		if firstLineInsensitive.startsWith('#.skip.')
			print 'Skipping per directive on first line of test source.'
			return 0

		if firstLineInsensitive.startsWith('#.multipart.')
			print 'Skipping per directive on first line of test source.'
			return 0

		if firstLineInsensitive.startsWith('#.multi.')
			print 'TODO: cannot handle .multi. directive yet'
#			print 'Running multiple files.'
#			filenames = [basename] + firstLine[firstLine.find('.multi.')+8:].split()
#			print filenames
#		else:
#			filenames = nil

		# not expecting an error
		c = Compiler(_verbosity, ProblemAction.Exit)

#		if filenames:
#			c.parseFilesNamed(filenames=filenames)
#		else:
#			c.parseOne(filename=basename, source=source)

		c.parseFilesNamed([baseName])
		assert c.modules

		print 'Bind interface:'
		c.bindInt()
		print 'Bind implementation:'
		c.bindImp()

		print 'Modules:'
		_output.indent()
		try
			for module in c.modules
			# TODO when using SystemInterfaces.cobra: for module as Module in c.modules.getRange(1, c.modules.count-1)  # CC: axe "as Module"
				module.writeDeepString(_output)
		finally
			_output.dedent()

		print bar
		print 'Generate C#:'
		c.genCS()
		# CC: shouldn't need to rename to 'module2'
		for module2 as Module in c.modules.getRange(1, c.modules.count-1)  # CC: axe "as Module"
			.printSource(module2.csSource)

		print bar
		print 'Compile C#:'
		c.compileCS()

#		print bar
#		print 'Run:'
#		childIn, childOut = os.popen4(c.exeFilename)
#		output = childOut.read()
#		sys.stdout.write(output)
#		if output.lower().find('unhandled exception')!=-1:
#			print
#			print
#			if 0:
#				# from Module.compile(); not yet adapted:
#				errors = []
#				for line in output.split('\n'):
#					if line.find(' error ')!=-1:
#						errors.append(line)
#			raise ExecutionError
		print bar

		return 1

	def testifyFilePath(pathName as String) as int
		dirName = Path.getDirectoryName(pathName)
		baseName = Path.getFileName(pathName)
		saveDir = Environment.currentDirectory
		Directory.setCurrentDirectory(dirName)
		try
			return .testifyFile(baseName)
		finally
			Directory.setCurrentDirectory(saveDir)

	def printSource(src as String)
		lineNum = 1
		for line as String in src.split(c'\n')  # CC: axe "as String"
			line = line.replace("\t", "    ")
			print '[lineNum]|[line]'  # CC: right align and pad 0 the lineNum
			lineNum += 1
