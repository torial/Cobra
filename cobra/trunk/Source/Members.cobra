"""
This module contains ClassMember on down, except Property and Indexer which have their own files.
"""

class BoxMember
	inherits NamedNode
	implements IMember

	shared
		var _accessLevels = ['public', 'protected', 'internal', 'protected internal', 'private']
			"""
			The access level names are the same in both Cobra and C#.
			"""

	var _box as Box
	var _docString as String?
	var _isNames as List<of String>?  # CC: make a Set
	var _overloadGroup as MemberOverload?
	var _testMethod as TestMethod?
	var _matchingBaseMember as BoxMember?

	def init(token as IToken, box as Box, name as String, isNames as List<of String>)
		this.init(token, box, name, isNames, nil)

	def init(token as IToken, box as Box, name as String, isNames as List<of String>, docString as String?)
		base.init(token, name)
		_isNames = isNames
		_box = box
		_docString = docString
		.defaultToVirtual

	## Properties

	get box from var

	pro docString from var

	pro isNames from var

	pro overloadGroup from var

	pro testMethod from var

	get isCallable as bool
		return false

	get isOverride as bool
		return 'override' in _isNames

	get isShared as bool
		return 'shared' in _isNames

	get englishName as String
		throw OverrideException(.getType)
		return ''

	get defaultAccessLevel as String
		throw OverrideException(.getType)
		return ''

	get hasVariParams as bool
		"""
		Retuns true if the class member takes variable number of arguments.
		"""
		return false

	get hasParams as bool
		"""
		Returns true if the class member has one or more parameters defined.
		"""
		return false

	get params as List<of Param>
		"""
		Returns the list of params of this method, possibly empty.
		Checking hasParams first is recommended since it's more efficient.
		"""
		return List<of Param>()

	get isClassMember as bool
		return _box inherits Class

	get isInterfaceMember as bool
		return _box inherits Interface

	get isStructMember as bool
		return _box inherits Struct

	pro matchingBaseMember from var

	get requiresThis as bool
		return not _name.startsWith('_')

	get resultType as IType
		"""
		The result type of the var, method or property.
		"""
		throw OverrideException(.getType)
		return CobraType()

	## Other

	def defaultToVirtual
		"""
		A hook for subclasses to add the virtual keyword to _isNames, if appropriate.
		"""
		require _isNames is not nil
		pass

	## INamedNode

	get typeForIdentifier as IType is override
		return .resultType

	get typeForReceiver as IType is override
		return .resultType


	## Binding

	def _bindInt is override
		base._bindInt
		if _testMethod
			_testMethod.bindInt

	def _bindImp is override
		base._bindImp
		assert .didBindInt  # class members should have always received a bindInt first
		if _testMethod
			_testMethod.bindImp

	def usesBase
		# Needed by AbstractMethod and ProperDexer
		if 'new' in _isNames or 'override' in _isNames
			return
		# using base implies override, but only if the method sig in the base class is the same
		# (otherwise it's just an overload)
		if _box inherits Class
			assert _box.baseClass
			baseMember = _box.baseClass.memberForName(_name)
			if baseMember inherits BoxMember
				if .matchesSignature(baseMember)
					if 'nonvirtual' in baseMember.isNames
						_isNames.add('new')
					else
						_isNames.add('override')
					_isNames.remove('virtual')  # virtual is the default for properties and methods

	def matchesSignature(member as BoxMember) as bool
		if .name <> member.name
			return false
		params_ = .params
		otherParams = member.params
		if params_.count <> otherParams.count
			return false
		for i = 0 .. params_.count
			if params_[i].type <> otherParams[i].type
				return false
		return true


	## Fields

	def addMinFields is override
		base.addMinFields
		.addField('name', _name)
		.addField('isNames', _isNames)

	def addRefFields is override
		base.addRefFields
		.addField('classDecl', _box)

	def addSubFields is override
		base.addSubFields
		if _isNames
			.addField('isNames', _isNames)
		.addField('docString', _docString)


	## Code gen

	def writeSharpTest(sw as SharpWriter)
		if _testMethod
			_testMethod.writeSharpDef(sw)

	def writeSharpTestInvocation(sw as SharpWriter)
		if _testMethod
			sw.write('[_testMethod.sharpName]();\n')

	def writeSharpParams(sw as SharpWriter)
		.writeSharpParams(sw, '()')

	def writeSharpParams(sw as SharpWriter, parens as String)
		require parens.length==2
		sw.write(parens[0])
		sep = ''
		for param in .params
			sw.write(sep)
			param.writeSharpDef(sw)
			sep = ', '
		sw.write(parens[1].toString+' ')

	def writeSharpIsNames(sw as SharpWriter)
		# TODO:
		# if isNames is nil
		#	isNames = _isNames
		isNames = List<of String>()
		if _isNames
			isNames.addRange(_isNames)
		if .defaultAccessLevel
			found = false
			for level as String in _accessLevels  # CC: axe as
				if level in isNames
					found = true
			if not found
				isNames.insert(0, .defaultAccessLevel)
		isNameCS = {
			# only have to specify the ones that are different
			'shared': 'static',
			'nonvirtual': '',
		}
		sep = ''
		for name in isNames
			name = Utils.getSS(isNameCS to passthrough, name, name) to String # CC: to !
			sw.write(sep)
			sw.write(name)
			sep = ' '
		if sep
			sw.write(' ')


class ClassVar
	inherits BoxMember
	implements IVar

	var _typeNode as INode
	var _type as IType?
	var _initExpr as Expr?
	var _ifInheritsStack as Stack<of IType>
	var _useCSNameStack as Stack<of String>
	var _isAssignedTo as bool

	def init(token as IToken, box as Box, name as String, typeNode as INode, isNames as List<of String>, initExpr as Expr?, docString as String)
		base.init(token, box, name, isNames, docString)
		_typeNode = typeNode
		_initExpr = initExpr
		_ifInheritsStack = Stack<of IType>()
		_useCSNameStack = Stack<of String>()  # for if-inherits

	def addRefFields is override
		base.addRefFields
		if _type
			.addField('type', _type)
		else
			.addField('typeNode', _typeNode)

	def addSubFields is override
		base.addSubFields
		.addField('initExpr', _initExpr)

	get defaultAccessLevel as String is override
		return 'protected'

	pro isAssignedTo from var

	pro ifInheritsStack from var

	get requiresDotPrefix as bool
		return _box is not nil and not _name.startsWith('_')

	get useCSNameStack from var

	def _bindInt is override
		base._bindInt
		if _initExpr
			_initExpr.bindImp  # that's bindImp intentionally
			if _type is nil
				_type = _initExpr.type
		if _type is nil
			assert _typeNode, 'typeNode should be set if _type is nil'
			_typeNode.bindInt
			t = _typeNode.namedType
			t.bindInt
			assert t, _typeNode
			if _initExpr and not _initExpr.isKindOf(t to IType)  # CC: axe cast when "assert foo" is understood to prove that foo is not nil
				.throwError('The expression type of [_initExpr.type] does not match the variable type of [t].')
			_type = t

	get resultType as IType is override
		"""
		The result type of the var, method or property.
		"""
		if _type
			return _type to passthrough  # CC: axe cast
		else
			throw FallThroughException('_type is nil. this=[this]')

	## INamedNode

	get typeForReceiver as IType is override
		assert .resultType
		return if(_ifInheritsStack, _ifInheritsStack.peek, .resultType to IType)

	## IVar

	pro type as IType?
		get
			require _type
			return if(_ifInheritsStack, _ifInheritsStack.peek, .resultType)  # CC: change last "to IType" to "to !" or make if() smarter
		set
			assert false, 'Cannot set the type of a ClassVar.'

	## Code Gen

	get sharpAssignmentNames as List<of String>
		return List<of String>(_useCSNameStack)

	get sharpRef as String is override
		return if(_useCSNameStack, _useCSNameStack.peek, _name)

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		.writeSharpIsNames(sw)
		sw.write(_type.sharpRef)
		sw.write(' [_name]')
		if _initExpr
			sw.write(' = ')
			_initExpr.writeSharpDef(sw)
		sw.write(';\n')

	get sharpName as String is override
		return if(_useCSNameStack, _useCSNameStack.peek, .name)


class AbstractMethod
	inherits BoxMember
	"""
	The abstract ancestor class for
		Constructor
		Method
		PropertyXetter

	But not for Property (which has two code blocks "get" and "set"),
	or other class decls like variables.

	Subclasses must set _params.
	"""

	var _returnTypeNode as INode
	var _returnType as IType?
	var _requirePart as RequirePart
	var _ensurePart as EnsurePart
	var _oldExprs as List<of OldExpr>
	var _params as List<of Param>
	var _locals as List<of LocalVar>
	var _stmts as List<of Stmt>
	var _hasReturnStmt as bool
	var _sharpResultVarName as String?

	def init(token as IToken, box as Box, name as String, paramsList as List<of Param>, isNames as List<of String>, docString as String)
		base.init(token, box, name, isNames, docString)
		_params = paramsList
		_oldExprs = List<of OldExpr>()
		_locals = List<of LocalVar>()
		_stmts = List<of Stmt>()

	get hasParams as bool is override
		return _params.count > 0

	get params as List<of Param> is override
		return _params

	get defaultAccessLevel as String is override
		if .isClassMember or .isStructMember
			return 'public'
		else if .isInterfaceMember
			return ''
		else
			throw FallThroughException(this)

	def defaultToVirtual is override
		if .isClassMember
			for name in ['nonvirtual', 'virtual', 'shared', 'override']
				if name in _isNames
					return
			_isNames.add('virtual')

	get isCallable as bool is override
		return true

	pro hasReturnStmt from var

	def addStmt(stmt as Stmt)
		_stmts.add(stmt)

	pro requirePart from var

	pro ensurePart from var

	get resultType as IType is override
		require
			.didBindInt
			_returnType is not nil
		body
			return _returnType to IType  # CC: to !

	def findLocal(name as String) as AbstractLocalVar?
		# TODO: should this use a dictionary lookup?
		for local in _locals
			if local.name==name
				return local
		for param in _params
			if param.name==name
				return param
		return nil

	def findLocalCI(name as String) as AbstractLocalVar?
		name = name.toLower
		# TODO: should this use a dictionary lookup?
		for local in _locals
			if local.name.toLower==name
				return local
		for param in _params
			if param.name.toLower==name
				return param
		return nil

	def addLocal(local as LocalVar)
		require
			local.name
			.findLocal(local.name) is nil  # TODO: , 'symbol=[symbol], symbolForName=[.symbolForName(symbol.name)]'
		body
			other = .findLocalCI(local.name)
			if other is not nil
				.throwError('Parameters and locals must vary by more than just their case. Change "[local.name]" or "[other.name]" to match, or rename one of them to something different.')
			local.isTracked = true
			_locals.add(local)

	def removeLocal(name as String)
		require
			name
			.findLocal(name) is not nil
		body
			for i = 0 .. _locals.count
				if _locals[i].name==name
					_locals.removeAt(i)
					break

	def addOldExpr(oldExpr as OldExpr)
		_oldExprs.add(oldExpr)
		oldExpr.sharpVarName = '_lh_old_' + _oldExprs.count.toString

	def addRefFields is override
		base.addRefFields
		.addField('returnTypeNode', _returnTypeNode)
		.addField('returnType', _returnType)

	def addSubFields is override
		base.addSubFields
		.addField('params', _params)
		if _returnType inherits QualifiedType  # TODO: another QualifiedType special case
			.addField('returnType', _returnType)
		.addField('requirePart', _requirePart)
		.addField('ensurePart', _ensurePart)
		.addField('locals', _locals)
		.addField('stmts', _stmts)

	def _bindInt is override
		base._bindInt
		.compiler.codeMemberStack.push(this)
		for param in _params
			param.bindInt
		if _returnType is nil
			if _returnTypeNode is nil
				_returnType = .compiler.voidType
			else
				_returnTypeNode.bindInt
				_returnType = _returnTypeNode.namedType
			assert _returnType, _returnTypeNode
		_returnType.bindInt  # TODO: needs a test case. like: def foo as String?; return ''
		if _requirePart is nil
			_requirePart = RequirePart(this)
		_requirePart.bindInt
		if _ensurePart is nil
			_ensurePart = EnsurePart(this)
		_ensurePart.bindInt
		.compiler.codeMemberStack.pop

	def _bindImp is override
		base._bindImp
		.compiler.codeMemberStack.push(this)
		for param in _params
			param.bindImp
		for local in _locals
			local.bindImp
		if _requirePart
			_requirePart.bindImp
		if _ensurePart and _returnType is not nil and _returnType is not .compiler.voidType
			_sharpResultVarName = '_lh_result_[_box.makeNextPrivateSerialNumber]'
		else
			_sharpResultVarName = nil
		for stmt in _stmts
			try
				stmt.bindImp
				stmt.afterStatementBindImp  # to let expressions know when they are used as statements
			catch ne as NodeException
				.compiler.recordError(ne)
		if _ensurePart
			_ensurePart.bindImp
		.computeMatchingBaseMember
		.checkForUnmarkedOverrideOrNew  # have to do this after statements bind imp since using base can add `override`
		.checkForUnusedVariables
		.compiler.codeMemberStack.pop

	def computeMatchingBaseMember
		if _box inherits Class
			if _box.baseClass is not nil
				baseMember = _box.baseClass.memberForName(_name)
				if baseMember is nil
					pass
				else if baseMember inherits AbstractMethod
					if .matchesSignature(baseMember)
						_matchingBaseMember = baseMember
				else if baseMember inherits MemberOverload
					if baseMember.members[0] inherits AbstractMethod
						for member in baseMember.members
							if .matchesSignature(member)
								_matchingBaseMember = member
					else
						cannotRedeclare = true
				else
					cannotRedeclare = true
				if cannotRedeclare
					.recordError('Cannot declare a [.englishName] named "[.name]" because the base member "[.name]" is a [.englishName]. this=[.getType.name], baseMember=[baseMember.getType.name]')

	def checkForUnmarkedOverrideOrNew
		# require called computeMatchingBaseMember  # CC:? TODO?
		if 'new' not in _isNames and 'override' not in _isNames and _matchingBaseMember is not nil
			.throwError('Member "[_name]" also exists in the base class. You must specify "is override" or "is new", or change the name.')

	def checkForUnusedVariables
		for local in _locals
			if not local.isUsed
				.compiler.warning(local, 'The value of variable "[local.name]" is never used.')

	## Code gen

	get sharpResultVarName from var

	def writeSharpImp(sw as SharpWriter, skipFirst as bool)
		sw.writeAndIndent('{\n')
		if .compiler.hasSuperStackTraceOption
			.writeSSTHead(sw)
		for param in _params
			.writeSharpParamCheck(param, sw)
		if _requirePart
			_requirePart.writeSharpDef(sw)
		.writeSharpLocals(sw, nil, false)
		if _ensurePart
			sw.write('bool _lh_canEnsure = true;\n')
			if _sharpResultVarName  # set in _bindImp
				sw.write('[_returnType.sharpRef] [_sharpResultVarName] = [_returnType.csInit];\n')
			sw.writeAndIndent('try {\n')
		for stmt in _stmts
			if skipFirst
				skipFirst = false
				continue
			stmt.writeSharpStmt(sw)
		if _ensurePart
			sw.dedentAndWrite('} catch {\n')
			sw.indent
			sw.write('_lh_canEnsure = false;\n')
			sw.write('throw;\n')
			sw.dedentAndWrite('} finally { // ensure\n')
			sw.indentAndWrite('if (_lh_canEnsure) {\n')
			sw.indent
			_ensurePart.writeSharpDef(sw)
			sw.dedentAndWrite('}\n')
			sw.dedentAndWrite('}\n')
		if .compiler.hasSuperStackTraceOption
			.writeSSTTail(sw)
		sw.dedent
		sw.write('}\n')
		sw.write('\n')

	def writeSharpPassArgs(sw as SharpWriter)
		sw.write('(')
		sep = ''
		for param in _params
			sw.write(sep)
			sw.write(param.name)
			sep = ', '
		sw.write(')')

	# TODO: axe?
#	def writeSharpLocals(sw as SharpWriter)
#		.writeSharpLocals(sw, nil, true)

	def writeSharpLocals(sw as SharpWriter, locals as List<of LocalVar>?, open as bool)
		if open
			sw.writeAndIndent('{\n')
		# record the `old` expressions for `ensure`
		for oldExpr in _oldExprs
			oldExpr.writeSharpAssignment(sw)
		if locals is nil
			locals = _locals
		if locals
			sw.write('// locals\n')
			for local in locals
				if not local.isImplicit
					sw.write('[local.type.sharpRef] [local.name]')
					init = local.type.csInit
					if init
						sw.write(' = [init]')
					sw.write(';\n')

	def writeSharpParamCheck(param as Param, sw as SharpWriter)
		if param.type.isReference and not param.type inherits NilableType
			sw.write('if ([param.name]==null) throw new ArgumentNullException("[param.name]");\n')
			# TODO axe the code below or above
			#sw.write('if (%s==null) throw new ArgumentNullException("%s", string.Format("Object reference \\"%s\\" not set to an instance of an object."));\n' % (
			#	param.name, param.name, param.name))

	def writeSSTHead(sw as SharpWriter)
		sw.write('CobraImp.PushFrame("[.box.name]", "[.name]"')
		if not .isShared
			sw.write(', "this", this')
		for param in .params
			sw.write(', "[param.name]", [param.name]')
		sw.write(');\n')
		sw.write('CobraImp.SetLine([.token.lineNum]);\n')
		sw.writeAndIndent('try {\n')

	def writeSSTTail(sw as SharpWriter)
		sw.dedentAndWrite('} catch {\n')
		sw.indent
		sw.write('CobraImp.CaughtUncaughtException();\n')
		sw.write('throw;\n')
		sw.dedentAndWrite('} finally {\n')
		sw.indent
		sw.write('CobraImp.PopFrame();\n')
		sw.dedentAndWrite('}\n')


class Constructor
	inherits AbstractMethod

	def init(token as IToken, box as Box, paramsList as List<of Param>, isNames as List<of String>, docString as String)
		base.init(token, box, 'init', paramsList, isNames, docString)
		_isNames = isNames
		_stmts = List<of Stmt>()

	get englishName as String is override
		return 'constructor'

	get hasVariArgs as bool
		assert false, 'TODO: complete Constructor.hasVariArgs'
		return false

	get isCallable as bool is override
		return true

	get isMethod as bool is override
		return true  # because this is needed for "base.init" without ()s

	def defaultToVirtual is override
		pass

	def usesBase is override
		# constructors cannot be virtual and don't require "is new"
		pass

	def checkForUnmarkedOverrideOrNew is override
		# constructors don't say override or new
		pass

	## Code gen

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		first = if(_stmts, _stmts[0], nil)
		callConstructor as String? = nil
		if first inherits DotExpr
			if first.left inherits ThisLit or first.left inherits BaseLit
				doIt = false
				if first.right inherits CallExpr and (first.right to CallExpr).name=='init'
					doIt = true
					args = (first.right to CallExpr).args
				else if first.right inherits MemberExpr and (first.right to MemberExpr).name=='init'
					doIt = true
					args = List<of Expr>()
				if doIt
					callConstructor = (first.left to AtomicLiteral).asSharp
		.writeSharpIsNames(sw)
		sw.write(' [.box.rootName]')
		.writeSharpParams(sw)
		if callConstructor
			sw.writeAndIndent('\n')
			sw.write(': [callConstructor](')
			sep = ''
			for arg in args
				sw.write(sep)
				arg.writeSharpDef(sw)
				sep = ', '
			sw.write(') ')
			sw.dedent()
		.writeSharpImp(sw, if(callConstructor, true, false))
		if _requirePart
			_requirePart.writeSharpMethod(sw)
		.writeSharpTest(sw)


class Method
	inherits AbstractMethod

	var _implementsTypeNode as ISyntaxNode?
	var _implementsType as IType?

	def init(token as IToken, box as Box, name as String, paramsList as List<of Param>, returnTypeNode as INode, implementsTypeNode as ISyntaxNode?, isNames as List<of String>, docString as String)
		base.init(token, box, name, paramsList, isNames, docString)
		_returnTypeNode = returnTypeNode
		_implementsTypeNode = implementsTypeNode
		# TODO: feels kind of hacky:
		if 'virtual' in _isNames and _implementsTypeNode
			_isNames.remove('virtual')
		_stmts = List<of Stmt>()

	get englishName as String is override
		return 'method'

	get hasVariArgs as bool
		assert false, 'TODO: complete Method.hasVariArgs'
		return false

	get isCallable as bool is override
		return true

	get isMethod as bool is override
		return true

	def addRefFields is override
		base.addRefFields
		.addField('implementsType', _implementsType)

	def addSubFields is override
		base.addSubFields
		if _implementsTypeNode
			.addField('implementsTypeNode', _implementsTypeNode)

	get defaultAccessLevel as String is override
		dal = base.defaultAccessLevel
		if dal and not _implementsType and not _implementsTypeNode
			return dal
		else
			return ''

	def defaultToVirtual is override
		if .isClassMember and not _implementsTypeNode and not _implementsType
			base.defaultToVirtual

	def _bindImp is override
		numErrors = .compiler.errors.count
		base._bindImp
		if _implementsTypeNode is not nil
			_implementsTypeNode.bindAll
			assert _implementsTypeNode.namedType
			_implementsType = _implementsTypeNode.namedType
			# TODO: make sure the type is among the interfaces of the box
		if .compiler.errors.count==numErrors and _returnType is not .compiler.voidType and not .hasReturnStmt and not .box.isFake and not .box inherits Interface
			.throwError('Missing return statement for method "[_name]" which returns [_returnType.name].')

	## Code gen

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		name = .sharpName
		returnType = _returnType ? .compiler.voidType to IType  # CC: axe cast
		if _implementsType
			name = _implementsType.name + '.' + name  # TODO: is name sufficient?
		.writeSharpIsNames(sw)
		sw.write('[returnType.sharpRef] [name]')
		.writeSharpParams(sw)
		if .isInterfaceMember
			sw.write(';\n')
		else
			.writeSharpImp(sw, false)
			if _requirePart
				_requirePart.writeSharpMethod(sw)
			.writeSharpTest(sw)

	get sharpName as String is override
		return Utils.capped(.name)


class ProperDexer
	inherits BoxMember
	"""
	The abstract base class for Property and Indexer.

	This captures some of the common interface between them--whatever happens to be needed
	(currently by the parser only).

	Why not do an IProperDexer interface? Because it wouldn't be compatible with a ClassMember
	unless we also defined an IClassMember.
	"""

	var _getPart as ProperDexerXetter?
	var _setPart as ProperDexerXetter?
	var _coverVar as ClassVar
	var _coverAccess as String
	var _returnType as IType?
	var _returnTypeNode as INode?

	def init(token as IToken, box as Box, name as String, isNames as List<of String>, docString as String)
		base.init(token, box, name, isNames, docString)

	def init(token as IToken, box as Box, name as String, returnTypeOrNode as INode, isNames as List<of String>, docString as String)
		.init(token, box, name, isNames, docString)
		if returnTypeOrNode
			if returnTypeOrNode inherits IType
				_returnType = returnTypeOrNode
				_returnTypeNode = nil
			else if returnTypeOrNode inherits INode
				_returnType = nil
				_returnTypeNode = returnTypeOrNode
			else
				throw FallThroughException(returnTypeOrNode)

	def makeGetPart(token as IToken) as AbstractMethod
		require .getPart is nil
		ensure .getPart is not nil
		throw OverrideException()
		# CC: shouldn't need a return:
		return nil to passthrough

	def makeSetPart(token as IToken) as AbstractMethod
		require .setPart is nil
		ensure .setPart is not nil
		throw OverrideException()
		# CC: shouldn't need a return:
		return nil to passthrough

	def addRefFields is override
		base.addRefFields
		if _coverVar
			.addField('coverVar', _coverVar)
		if _returnType
			.addField('returnType', _returnType)
		else
			.addField('returnTypeNode', _returnTypeNode)

	def addSubFields is override
		base.addSubFields
		if _getPart
			.addField('getPart', _getPart)
		if _setPart
			.addField('setPart', _setPart)

	get returnType from var

	get returnTypeNode from var

	get resultType as IType is override
		assert .didBindInt
		assert _returnType
		return _returnType to IType  # CC: axe when code flow understands the assert

	get getPart from var

	get setPart from var

	def defaultToVirtual is override
		# TODO: dup'ed in AbstractMethod
		if .isClassMember
			for name in ['nonvirtual', 'virtual', 'shared', 'override']
				if name in _isNames
					return
			_isNames.add('virtual')

	get defaultAccessLevel as String is override
		if .isClassMember
			return 'public'
		else
			return ''

	def _bindInt is override
		base._bindInt
		if _returnType is nil
			if _coverVar
				_coverVar.bindInt
				assert _coverVar.resultType, _coverVar
				_returnType = _coverVar.resultType
			else
				assert _returnTypeNode
				_returnTypeNode.bindInt
				_returnType = _returnTypeNode.namedType
		_returnType.bindInt
		assert _returnType  # properties always have a return type
		if _getPart
			_getPart.bindInt
		if _setPart
			_setPart.bindInt

	def _bindImp is override
		base._bindImp
		if _getPart
			_getPart.bindImp
		if _setPart
			_setPart.bindImp

	## Code gen

	def writeSharpBody(sw as SharpWriter)
		sw.write(' {\n')
		sw.indent
		if _coverVar
			if _coverAccess in ['getset', 'get']
				sw.write('get { return [_coverVar.sharpName]; }')
			if _coverAccess in ['getset', 'set']
				sw.write('set { [_coverVar.sharpName] = value; }')
		else
			if _getPart
				if .isClassMember
					_getPart.writeSharpDef(sw)
				else if .isInterfaceMember
					sw.write('\tget;\n')
				else
					throw FallThroughException(this)
			if _setPart
				if .isClassMember
					_setPart.writeSharpDef(sw)
				else if .isInterfaceMember
					sw.write('\tset;\n')
				else
					throw FallThroughException(this)
		sw.dedent
		sw.write('}\n')


class ProperDexerXetter
	inherits AbstractMethod
	"""
	Base class for IndexerGetter, IndexerSetter, PropertyGetter and PropertySetter.
	"""

	var _parent as ProperDexer

	def init(token as IToken, parent as ProperDexer, isNames as List<of String>)
		base.init(token, parent.box, parent.name, List<of Param>(), isNames, '')  # TODO: should be docString, right?
		_name = parent.name + '.' + .xetPartName  # CC: somewhat awkward. belongs in the base.init() call
		_parent = parent

	get parent from var

	get xetPartName as String  # CC: make abstract
		throw OverrideException(.getType)
		return '(override indexerPartName)'

	get isShared as bool is override
		return _parent.isShared

	def usesBase is override
		# it's the property that needs to compute the "is override" or "is new" for itself,
		# not the get or set part
		_parent.usesBase

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write(.xetPartName)
		.writeSharpImp(sw, false)


class MemberOverload
	inherits BoxMember

	var _members as List<of BoxMember>

	def init(member as BoxMember)
		require
			member.name
			member.box
		ensure
			.members
			.members[0]==member
		body
			base.init(member.token, member.box, member.name, member.isNames)
			member.overloadGroup = this
			_members = [member]
			_isNames = member.isNames  # pick up 'shared' for example

	def addSubFields is override
		base.addSubFields
		.addField('members', _members)

	get members from var

	get englishName as String is override
		assert _members
		return _members[0].englishName

	get isCallable as bool is override
		assert _members
		return _members[0].isCallable

	get isMethod as bool is override
		return _members[0] inherits Method

	def addMember(member as BoxMember)
		require
			member is not this
			not member inherits MemberOverload
			member.overloadGroup is nil
			member.name==.name # CC:, '.name=[.name], member.name=[member.name]'
			.members implies member not in .members # CC: , member
			.members implies member.getType is .members[0].getType
		body
			member.overloadGroup = this
			_members.add(member)
			.box.addDeclFromOverload(member, this)

	def addInheritedMember(member as BoxMember)
		require
			member is not this
			not member inherits MemberOverload
			member.name==.name
			member.box is not .box
			.members implies member not in .members # CC: , member
			.members implies member.getType is .members[0].getType
		body
			_members.add(member)



	get resultType as IType? is override
		assert .didBindInt
		assert _members[0] is not this
		return _members[0].resultType

	def _bindInt is override
		base._bindInt
		# rename the test members of the overload by suffixing them with '_o1' '_o2' etc.
		i = 1
		for member in _members
			if member.testMethod
				member.testMethod.name = member.testMethod.name + '_ol' + i.toString
			i += 1
		# TODO: error if the returnType is different among any members
		# TODO: error if the two members have the same arguments

	def _bindImp is override
		base._bindImp


class TestMethod
	inherits Method
	"""
	TODO: It's weird that you have to pass voidType. Maybe Node should have a shared typeProvider
	like it has a shared compiler. The parser could set it.
	"""

	var _forMember as BoxMember?
	var _forBox as Box?

	def init(token as IToken, member as BoxMember, voidType as IType)
		require
			member.box
			member.name
		body
			# CC: shouldn't the .getCompiler() work? C# code gen puts a "this" in there even though it's shared and C# chokes on it
			#base.init(token, member.box, 'test_'+Utils.capped(member.name), List<of Param>(), .getCompiler.voidType, List<of String>(), nil, '')
			base.init(token, member.box, 'test_'+Utils.capped(member.name), List<of Param>(), voidType, nil, List<of String>(), '')
			_forMember = member

	def init(token as IToken, box as Box, voidType as IType)
		require
			box.name
		body
			# CC: shouldn't the .getCompiler work? C# code gen puts a "this" in there even though it's shared and C# chokes on it
			# base.init(token, box, 'test_class_'+Utils.capped(box.name), List<of Param>(), .getCompiler.voidType, List<of String>(), List<of INode>(), '')
			base.init(token, box, 'test_class_'+Utils.capped(box.name), List<of Param>(), voidType, nil, List<of String>(), '')
			_forBox = box

	pro name as String is new
		"""
		NamedNode.name does not allow the name to be set because that could mess up dictionaries
		that index the node by name. However, there are no such dictionaries for TestMethod and
		MemberOverload() needs to mangle test method names so they don't collide.
		"""
		get
			return base.name
		set
			require value
			_name = value

	def defaultToVirtual is override
		_isNames.add('shared')


class ConditionPart
	inherits SyntaxNode
	"""
	TODO: Rename to ContractPart
	TODO: make abstract
	The abstract base class for RequirePart and EnsurePart.
	"""

	var _connectToken as IToken?
	var _codeMember as AbstractMethod
	var _exprs as List<of Expr>
	var _isImplicit as bool # meaning the source code did not define this object

	def init(codeMember as AbstractMethod)
		base.init(codeMember.token)
		_isImplicit = true
		_codeMember = codeMember
		_exprs = List<of Expr>()

	def init(connectToken as IToken?, mainToken as IToken, codeMember as AbstractMethod, exprs as List<of Expr>)
		base.init(mainToken)
		_connectToken = connectToken
		_codeMember = codeMember
		_exprs = exprs

	def addMinFields
		base.addMinFields
		.addField('connectToken', _connectToken)
		.addField('isImplicit', _isImplicit)

	def addSubFields
		base.addSubFields
		.addField('exprs', _exprs)

	get connectWord as String
		return ''  # TODO: make abstract instead

	get isImplicit from var

	def _bindImp is override
		base._bindImp
		isNames = _codeMember.isNames
		if not _isImplicit
			if _connectToken
				if 'override' not in isNames
					.recordError('The contract was specified with "[_connectToken.text]", but the code member is neither an "override" or "new".')
			else
				if 'override' in isNames
					what = if('override' in isNames, 'override', 'new')
					.recordError('The contract requires an "[.connectWord]" because the code member is "[what]".')
		i = 0
		for expr as Expr in _exprs.toArray  # CC: axe as
			expr.bindImp  # TODO: error recovery
			assert expr.type
			if expr.type is not .compiler.boolType
				expr = TruthExpr(expr).bindAll to Expr # CC: axe cast when Cobra supports "as this"
				assert expr.type
				_exprs[i] = expr
			i += 1

	def writeSharpMethod(sw as SharpWriter)  # TODO: is abstract
		pass


class RequirePart
	inherits ConditionPart

	var _sharpMethodName as String?

	def init(codeMember as AbstractMethod)
		base.init(codeMember)

	def init(connectToken as IToken?, mainToken as IToken, codeMember as AbstractMethod, exprs as List<of Expr>)
		base.init(connectToken, mainToken, codeMember, exprs)
		codeMember.requirePart = this

	get connectWord as String is override
		return 'or'

	get sharpMethodName as String
		if _sharpMethodName is nil
			name = 'require_[_codeMember.sharpName]_[_codeMember.serialNum]_[_codeMember.box.name]'
			name = name.replace(r'[]', 'Item') # indexer # TODO: maybe Indexer should return 'Item' in the first place
			# properindexers like "name.get" have '.'
			# generics have < > and ,
			for ch in [c'.', c'<', c'>', c',']
				name = name.replace(ch, c'_')
			_sharpMethodName = name
		return _sharpMethodName to String  # CC: axe cast

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write('if (CobraCore._willCheckRequire) {\n')
		sw.indent
		if _codeMember.isOverride
			# Note that in Cobra, when the top level class does not define `require` then that is the
			# same as saying `require true`--there is no requirement for calling the method. But when
			# an overriding method does not define `require` then it is inheriting the `require` of
			# its matching base method.
			codeMember = _codeMember
			assert codeMember is not nil
			count = 0
			n = 1
			while codeMember is not nil  # CC: make 'post'
				if not codeMember.box.isFake and codeMember.requirePart is not nil and (not codeMember.requirePart.isImplicit or codeMember.matchingBaseMember is nil)
					count += 1
					sw.write('try {\n')
					sw.indent
					sw.write('[codeMember.requirePart.sharpMethodName]')
					_codeMember.writeSharpPassArgs(sw)  # always use *our* code member since the arg names can be different than base classes
					sw.write(';\n')
					sw.dedent
					sw.write('} catch (RequireException re[n]) {\n')
					sw.indent
					if n>1
						sw.write('re[n-1].Next = re[n];\n')
					n += 1
				codeMember = codeMember.matchingBaseMember to AbstractMethod  # TODO: should a cast really be needed here?
			# at this point in C# code, all requirements have failed
			if n > 1
				sw.write('throw re1;\n')
			for m = 1 .. n
				sw.dedent
				sw.write('}\n')
				count -= 1
		else
			sw.write('[.sharpMethodName]')
			_codeMember.writeSharpPassArgs(sw)
			sw.write(';\n')
		sw.dedent
		sw.write('}\n')

	def writeSharpMethod(sw as SharpWriter) is override
		if _codeMember.isInterfaceMember
			# contracts on interface members are not supported yet
			# and when they are, these methods will have to be written outside the interface
			return
		static_ = if(_codeMember.isShared, 'static ', '')
		sw.write('[static_]protected void [.sharpMethodName]')
		_codeMember.writeSharpParams(sw)
		sw.write(' {\n')
		sw.indent
		passThis = if(_codeMember.isShared, 'typeof([_codeMember.box.sharpName])', 'this')
		for expr in _exprs
			sw.write('if (!')
			expr.writeSharpDef(sw)
			sw.write(') ')
			sw.indent
			s = expr.toCobraSource
			s = Utils.csStringLitFor(s)
			sw.write('throw new RequireException([Utils.csStringLitFor(expr.token.fileName)], [expr.token.lineNum], [s], [passThis]);\n')
			sw.dedent
		sw.dedent
		sw.write('}\n\n')

class EnsurePart
	inherits ConditionPart

	def init(codeMember as AbstractMethod)
		base.init(codeMember)

	def init(connectToken as IToken?, mainToken as IToken, codeMember as AbstractMethod, exprs as List<of Expr>)
		base.init(connectToken, mainToken, codeMember, exprs)
		codeMember.ensurePart = this

	get connectWord as String is override
		return 'and'

	def _bindImp is override
		assert _codeMember.resultType
		if _codeMember.resultType is .compiler.voidType
			base._bindImp
		else
			_codeMember.addLocal(ResultVar(.token, _codeMember))
			try
				base._bindImp
			finally
				_codeMember.removeLocal('result')

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		passThis = if(_codeMember.isShared, 'typeof([_codeMember.box.sharpName])', 'this')
		for expr in _exprs
			sw.write('if (!')
			expr.writeSharpDef(sw)
			sw.write(') ')
			sw.indent
			s = expr.toCobraSource
			s = Utils.csStringLitFor(s)
			sw.write('throw new EnsureException([Utils.csStringLitFor(expr.token.fileName)], [expr.token.lineNum], [s], [passThis]);\n')
			sw.dedent


