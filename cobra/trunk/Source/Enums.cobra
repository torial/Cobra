class EnumDecl
	inherits Container

	# TODO: defaultAccessLevel = 'public'

	var _storageTypeNode as ITypeProxy?
	var _storageType as IType?

	def init(token as IToken, name as String, isNames as List<of String>, storageTypeNode as ITypeProxy?, docString as String, enumMembers as List<of EnumMember>)
		base.init(token, name, isNames, docString)
		_storageTypeNode = storageTypeNode
		for em in enumMembers
			.addDecl(em)
			em.enumDecl = this

	get defaultAccessLevel as String is override
		return 'public'

	get englishName as String is override
		return 'enumeration type'

	get isShared as bool is override
		return true

	get isReference as bool is override
		# enums are not reference types
		return false

	get typeForIdentifier as IType is override
		return .compiler.typeType

	get typeForReceiver as IType is override
		return this

	def _bindInt is override
		base._bindInt()
		if _storageTypeNode
			_storageTypeNode.bindInt()
			_storageType = _storageTypeNode.realType
			# TODO: give error if _storageType is not some kind of int

	def _bindImp() is override
		base._bindImp()
		if _storageType
			_storageType.bindImp()

	def memberForName(name as String) as IMember?
		m = base.memberForName(name)
		if m is nil
			objClass = .compiler.libraryType('System', 'Object')
			return objClass.memberForName(name)
		return m

	get csInit as String is override
		return _name + '.' + _declsInOrder[0].name

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		if 'fake' in _isNames
			return
		.writeSharpIsNames(sw)
		sw.write('enum [_name]')
		storageType = _storageType
		if storageType and storageType is not .compiler.intType
			sw.write(' [storageType.sharpRef]')
		sw.write(' {\n')
		sw.indent()
		sep = ''
		i = 0
		for em as EnumMember in .declsInOrder
			sw.write(sep)
			sw.write(Utils.capped(em.name))
			if em.value
				sw.write(' = [em.value]')
			i += 1
			sep = ',\n'
		sw.write('\n')
		sw.dedent()
		sw.write('}\n\n')

	get sharpRef as String is override
		return .name


class EnumMember
	inherits NamedNode
	implements IMember
	"""
	Holds the name and (optionally) value of a member of an EnumDecl.
	"""

	var _value as int?
	var _enumDecl as EnumDecl?

	def init(token as IToken, value as int?)
		require token.which=='ID'
		base.init(token, token.text)
		_value = value

	def addMinFields is override
		base.addMinFields()
		.addField('value', _value)

	pro enumDecl from var

	get isCallable as bool
		return false

	get isShared as bool
		return true

	get englishName as String
		return 'enumeration value'

	pro nameSpace as NameSpace?
		get
			return nil
		set
			throw NotSupportedException()

	get requiresThis as bool
		# This property probably doesn't make much sense for an enum member which must always
		# be accessed via its containg enum type.
		return false

	get resultType as IType
		require _enumDecl
		return _enumDecl to IType # CC: axe typecast

	get value from var

	def writeSharpTestInvocation(sw as SharpWriter)
		pass
