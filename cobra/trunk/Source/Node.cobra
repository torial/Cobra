class CobraException
	inherits SystemException

	def init(msg as String)
		base.init(msg)


class NodeException
	inherits CobraException

	var _node as INode

	def init(node as INode, msg as String)
		base.init(msg)
		_node = node

	get node from var

	get message as String is override
		if _node inherits SyntaxNode
			return '[_node.token.fileName]([_node.token.lineNum]): [base.message]'
		else
			return base.message


interface INode
	"""
	Just about everything in the Cobra compiler that forms a data
	structure of a program ultimately inherits from Node. For example,
	all types and ASTs descend from Node.

	However, the tokenizer, parser, compiler object and command line
	objects do not. They don't form the data structure that represents a
	program.
	"""

	get serialNum as int

	pro superNode as INode?


	##
	## Inquiries
	##

	get namedType as IType?
		"""
		If this node represents a type, this property returns it.
		Otherwise, returns nil (which is the default behavior).
		Implemented by TypeExpr and IdentifierExpr.
		TODO: Can this be moved down to Expr?
		"""


	##
	## Binding
	##

	def bindInt as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""

	def bindImp as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""

	def bindAll as INode  # CC: as this

	get didBindInt as bool

	get didBindImp as bool


	##
	## Converting to string
	##

	def toTechString as String

	get minimalString as String
		"""
		Includes only atomic data like numbers and strings.
		"""

	get shallowString as String
		"""
		Includes minimal string plus references to other objects (their minimal strings).
		"""

	get deepString as String
		"""
		Includes shallow string plus subobjects (their deep strings).
		"""

	def writeDeepString(iw as IndentedWriter)

	def writeDeepString
		"""
		Wraps Console.out in an IndentedWriter.
		"""


class Node
	implements INode
	"""
	Just about everything in the Cobra compiler that forms a data
	structure of a program ultimately inherits from Node. For example,
	all types and ASTs descend from Node.

	However, the tokenizer, parser, compiler object and command line
	objects do not.
	"""

	shared
		var _nextNodeSerialNum = 1001
		var _compiler as Compiler?

		pro compiler from var

		def setCompiler(c as Compiler?) # CC: axe this method after the shared property is working
			_compiler = c

		def getCompiler as Compiler
			assert _compiler
			return _compiler to Compiler  # CC: axe cast

	var _serialNum as int

	var _didBindInt as bool
	var _didBindImp as bool

	var _isBindingInt as bool
	var _isBindingImp as bool

	var _didBindIntBase as bool
	var _didBindImpBase as bool

	var _superNode as INode?
		"""
		Possibly points to the node that owns this node.
		But this is not strictly required. It's used only when needed (typically in expressions).
		"""


	def init
		ensure
			.serialNum > 1000
			not .didBindInt
			not .didBindImp
		body
			_serialNum = _nextNodeSerialNum
			_nextNodeSerialNum += 1

	get serialNum from var

	pro superNode as INode?
		get
			return var
		set
			var = value


	##
	## Inquiries
	##

	get namedType as IType?
		"""
		If this node represents a type, this property returns it.
		Otherwise, returns nil (which is the default behavior).
		Implemented by TypeExpr and IdentifierExpr.
		TODO: Can this be moved down to Expr?
		"""
		return nil


	##
	## Binding
	##

	def bindInt as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""
		require .compiler
		if not _didBindInt and not _isBindingInt
			_isBindingInt = true
			try
				_didBindIntBase = false
				if .compiler.verbosity>3
					print '<> will _bindInt() on ' stop
					.writeDeepString()
				_bindInt()
				assert _didBindIntBase, this
				_didBindInt = true
			finally
				_isBindingInt = false
		return this

	def _bindInt
		"""
		Bind interface elements such as return types and parameter types.
		Override this method; do not send it. Invoke base.
		"""
		require .compiler
		_didBindIntBase = true

	def bindImp as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""
		require .compiler
		if not _didBindImp and not _isBindingImp
			_isBindingImp = false
			try
				_didBindImpBase = false
				if .compiler.verbosity>3
					print '<> will _bindImp() on ' stop
					.writeDeepString()
				_bindImp()
				assert _didBindImpBase, this
				_didBindImp = true
			finally
				_isBindingImp = false
		return this

	def _bindImp
		"""
		Bind implementation elements such as statements and expressions.
		Override this method; do not send it. Invoke base.
		"""
		require .compiler
		_didBindImpBase = true

	def bindAll as INode  # CC: as this
		.bindInt()
		.bindImp()
		return this

	get didBindInt from var

	get didBindImp from var


	##
	## Errors
	##

	def _error(msg as String)
		throw NodeException(this, msg)

	# TODO: push this down to IdentifierExpr
	def errorUnknownId(name as String)
		require name
		msg = 'Unknown identifier: "[name]".'
		if .compiler.unknownSuggestions.containsKey(name)
			sug = .compiler.unknownSuggestions[name]
		if sug
			msg += ' Maybe you should try "[sug]".'
		_error(msg)


	##
	## Converting to string
	##

	def toString as String is override
		return .shallowString

	def toTechString as String
		return .deepString

	get minimalString as String
		"""
		Includes only atomic data like numbers and strings.
		"""
		return _toString(true, false, false)

	get shallowString as String
		"""
		Includes minimal string plus references to other objects (their minimal strings).
		"""
		return _toString(true, true, false)

	get deepString as String
		"""
		Includes shallow string plus subobjects (their deep strings).
		"""
		return _toString(true, true, true)

	def addMinFields
		"""
		Subclasses should override to add minimal fields.
		"""
		pass

	def addRefFields
		pass

	def addSubFields
		pass

	def addField(name as String, value as Object?)
		"""
		Subclasses invoke this from their overrides of `addMinFields`,
		`addRefFields` and `addSubFields`.
		"""
		__curFields.add(Field(name, value))

	def addField(value as Object)
		.addField('', value)

	var __curFields as List<of Field>?

	def _toString(doMin as bool, doRef as bool, doSub as bool) as String
		"""
		This is the implementation for minimalString, shallowString and deepString.
		"""
		if doSub
			tag = 'de' # for deep
		else if doRef
			tag = 'sh' # for shallow
		else
			tag = 'mi' # for minimal

		sb = StringBuilder('[.getType().name]-[tag]([.serialNum]')

		if doMin
			__curFields = List<of Field>()
			try
				.addMinFields()
				for field in __curFields
					if field.name
						sb.append(', [field.name]=[field.value]')
					else
						sb.append(', [field.value]')
			finally
				__curFields = nil

		if doRef
			__curFields = List<of Field>()
			try
				.addRefFields()
				for field in __curFields
					value as Object?
					if field.value inherits Node
						value = (field.value to Node).minimalString
					else
						value = field.value
					sb.append(', [field.name]=[value]')
			finally
				__curFields = nil

		if doSub
			__curFields = List<of Field>()
			try
				.addSubFields()
				for field in __curFields
					value as Object?
					if field.value inherits Node
						value = (field.value to Node).minimalString
					else
						value = field.value
					sb.append(', [field.name]=[field.value]')
			finally
				__curFields = nil

		sb.append(')')
		s = sb.toString()
		if s.length>100
			s = s.substring(0, s.length-1) + ', [.serialNum])'

		return s

	def writeDeepString
		.writeDeepString(IndentedWriter(Console.out))

	def writeDeepString(iw as IndentedWriter)
		_writeDeepString(iw, this, true, true, true)

	def _writeDeepString(iw as IndentedWriter, obj as INode, doMin as bool, doRef as bool, doSub as bool)
		if doSub
			iw.write(obj.shallowString)
			iw.write('\n')
			iw.indent()
			try
				__curFields = List<of Field>()
				try
					.addSubFields()
					for field in __curFields
						value = field.value
						if value inherits Node
							iw.write('[field.name]=')
							value._writeDeepString(iw, value, doMin, doRef, doSub)
							#iw.write('\n')
						else if $sharp('value is System.Collections.IList')
							# CC: should not need the 'v' local below
							v as System.Collections.IList = value to System.Collections.IList
							iw.write('[field.name]=' + r'[')  # CC: should be able to say: '[name]=\[\n'
							iw.writeLine('')
							iw.indent()
							try
								for i = 0 .. v.count
									iw.write('[i]=')
									# CC: should not need the typecasts below
									if v[i] inherits Node
										(v[i] to Node)._writeDeepString(iw, v[i] to Node, doMin, doRef, doSub)
									else
										# TODO: fix this to work for nested lists like those found in DictLit
										iw.write(v[i].toString())
							finally
								iw.dedent()
							iw.write(']\n')
						else
							iw.write('[field.name]=[value]\n')
				finally
					__curFields = nil
			finally
				iw.dedent()
			return
		if doRef
			iw.write(obj.shallowString)
			return
		if doMin
			iw.write(obj.minimalString)

	## Code gen

	def writeSharpDef(sw as SharpWriter)
		require .didBindInt or .didBindImp
		pass


interface ISyntaxNode
	inherits INode

	get token as IToken


class SyntaxNode
	inherits Node
	implements ISyntaxNode
	"""
	An abstract tree syntax node (AST).
	Also: a node with a token.
	Also: a node that came from parsing.

	Descendants include NamedNode, Box (indirectly), Stmt and Expr.
	"""

	var _token as IToken

	def init(token as IToken)
		_token = token

	get token from var

	get fileName as String
		return _token.fileName

	get lineNum as int
		return _token.lineNum

	def addMinFields is override
		base.addMinFields()
		.addField('token', .token.toTechString())

	## Code gen

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.node(this)

	def writeSharpSetLine(sw as SharpWriter)
		if .compiler.hasSuperStackTraceOption and .lineNum>0
			sw.write('CobraImp.SetLine([.lineNum]);\n')


interface INamedNode
	inherits INode
	"""
	A NamedNode is just a syntax node plus a name.

	There is both a typeForIdentifier and typeForReceiver. That's
	because some NamedNodes like Class are a Type in the first case (`t
	= Console`) and themselves in the second case (`Console.out').

	TODO: can typeForIdentifier and typeForReceiver be moved down to
	IMember?
	"""

	get name as String

	get typeForIdentifier as IType
		"""
		The type that should be used when an identifier refers to this
		NamedNode as in "c = Console". See IdentifierExpr.
		"""

	get typeForReceiver as IType
		"""
		The type that should be used when a dotted expression refers to
		this NamedNode on the left side of the dot. See IdentifierExpr.
		"""

	get sharpName as String
		"""
		Return the name that should be used in C# source code.
		"""


interface INamedSyntaxNode
	inherits INamedNode, ISyntaxNode


class NamedNode
	inherits SyntaxNode
	implements INamedNode

#	invariant
#		.name

	var _name as String

	def init(token as IToken, name as String)
		require name
		base.init(token)
		_name = name

	get name from var

	def addMinFields is override
		base.addMinFields()
		.addField('name', .name)

	get typeForIdentifier as IType
		throw OverrideException(.getType())

	get typeForReceiver as IType
		throw OverrideException(.getType())

	## Code gen

	def writeSharpRef(sw as SharpWriter)
		sw.write(.name)

	get sharpName as String
		return _name


class Field

	var _name as String
	var _value as Object?

	def init(name as String, value as Object?)
		_name = name
		_value = value

	get name from var

	get value from var



namespace System

	namespace Diagnostics

		class Process
			is fake

			var _startInfo as StartInfo

			pro startInfo from var

			def start
				pass

			def waitForExit
				pass

			get standardOutput as System.IO.TextReader
				return nil to passthrough

			get standardError as System.IO.TextReader
				return nil to passthrough

		class StartInfo
			is fake

			pro fileName as String
				get
					return ''
				set
					pass

			pro arguments as String
				get
					return ''
				set
					pass

			pro redirectStandardOutput as bool
				get
					return true
				set
					pass

			pro redirectStandardError as bool
				get
					return true
				set
					pass

			pro useShellExecute as bool
				get
					return true
				set
					pass
