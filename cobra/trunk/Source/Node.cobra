class CobraException
	inherits SystemException

	def init(msg as String)
		base.init(msg)


class CobraMultiException
	inherits CobraException
	"""
	To provide good error recovery and to fully report all errors, it can be useful for parts of
	the code to catch exceptions that they then may need to throw all at once. Hence, the
	CobraMultiException. At least BinaryOpExpr uses it and Compiler.recordErrorAndThrow() checks
	for it.
	"""

	var _exceptions as List<of CobraException>

	def init(exceptions as vari CobraException)
		"""
		As a convenience to the caller, nil exceptions are quietly ignored.
		"""
		base.init('multi exception')
		_exceptions = List<of CobraException>()
		for exc in exceptions
			if $sharp('exc!=null')
				_exceptions.add($sharp('exc'))

	get exceptions from var


class NodeException
	inherits CobraException

	var _node as INode
	var _message as String

	def init(node as INode, msg as String)
		base.init(msg)
		_node = node
		_message = msg

	get node from var

	get message as String is override
		if _node inherits SyntaxNode
			return '[_node.token.fileName]([_node.token.lineNum]): [_message]'
		else
			return _message

	def prefixMessage(s as String)
		_message = s + _message


interface ISourceError
	"""
	All exceptions that represent errors in the Cobra source code being compiled implement ISourceError.
	"""

	get hasSourceInfo as bool
		"""
		Return true if the error really has source information (filename and line number). The
		`fileName` and `lineNum` properties will not be invoked if this returns false.
		"""

	get fileName as String
		# CC: require .hasSourceInfo

	get lineNum as int
		# CC: require .lineNum


class SyntaxNodeException
	inherits NodeException
	implements ISourceError

	var _synNode as ISyntaxNode

	def init(node as ISyntaxNode, msg as String)
		require
			node.token
			node.token.fileName
			node.token.lineNum
		body
			base.init(node, msg)
			_synNode = node

	get hasSourceInfo as bool
		return true

	get fileName as String
		return _synNode.token.fileName

	get lineNum as int
		return _synNode.token.lineNum


interface INode
	"""
	Just about everything in the Cobra compiler that forms a data
	structure of a program ultimately inherits from Node. For example,
	all types and ASTs descend from Node.

	However, the tokenizer, parser, compiler object and command line
	objects do not. They don't form the data structure that represents a
	program.
	"""

	get serialNum as int

	pro superNode as INode?


	##
	## Inquiries
	##

	get namedType as IType?
		"""
		If this node represents a type, this property returns it.
		Otherwise, returns nil (which is the default behavior).
		Implemented by TypeExpr and IdentifierExpr.
		TODO: Can this be moved down to Expr?
		"""


	##
	## Binding
	##

	def bindInt as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""

	def bindImp as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""

	def bindAll as INode  # CC: as this

	get didBindInt as bool

	get didBindImp as bool

	def _error(msg as String)


	##
	## Converting to string
	##

	def toTechString as String

	get minimalString as String
		"""
		Includes only atomic data like numbers and strings.
		"""

	get shallowString as String
		"""
		Includes minimal string plus references to other objects (their minimal strings).
		"""

	get deepString as String
		"""
		Includes shallow string plus subobjects (their deep strings).
		"""

	def writeDeepString(iw as IndentedWriter)

	def writeDeepString
		"""
		Wraps Console.out in an IndentedWriter.
		"""


class Node
	implements INode
	"""
	Just about everything in the Cobra compiler that forms a data
	structure of a program ultimately inherits from Node. For example,
	all types and ASTs descend from Node.

	However, the tokenizer, parser, compiler object and command line
	objects do not.
	"""

	shared
		var _nextNodeSerialNum = 1001
		var _compiler as Compiler?

		pro compiler from var

		def setCompiler(c as Compiler?) # CC: axe this method after the shared property is working
			_compiler = c

		def getCompiler as Compiler
			assert _compiler
			return _compiler to Compiler  # CC: axe cast

	var _serialNum as int

	var _didBindInt as bool
	var _didBindImp as bool

	var _isBindingInt as bool
	var _isBindingImp as bool

	var _didBindIntBase as bool
	var _didBindImpBase as bool

	var _superNode as INode?
		"""
		Possibly points to the node that owns this node.
		But this is not strictly required. It's used only when needed (typically in expressions).
		"""


	def init
		ensure
			.serialNum > 1000
			not .didBindInt
			not .didBindImp
		body
			_serialNum = _nextNodeSerialNum
			_nextNodeSerialNum += 1

	get serialNum from var

	pro superNode as INode?
		get
			return var
		set
			var = value


	##
	## Inquiries
	##

	get namedType as IType?
		"""
		If this node represents a type, this property returns it.
		Otherwise, returns nil (which is the default behavior).
		Implemented by TypeExpr and IdentifierExpr.
		TODO: Can this be moved down to Expr?
		"""
		return nil


	##
	## Binding
	##

	def bindInt as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""
		require .compiler
		if not _didBindInt and not _isBindingInt
			_isBindingInt = true
			try
				_didBindIntBase = false
				if .compiler.verbosity>3
					print '<> will _bindInt() on ' stop
					.writeDeepString()
				_bindInt()
				assert _didBindIntBase, this
				_didBindInt = true
			finally
				_isBindingInt = false
		return this

	def _bindInt
		"""
		Bind interface elements such as return types and parameter types.
		Override this method; do not send it. Invoke base.
		"""
		require .compiler
		_didBindIntBase = true

	def bindImp as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""
		require .compiler
		if not _didBindImp and not _isBindingImp
			_isBindingImp = false
			try
				_didBindImpBase = false
				if .compiler.verbosity>3
					print '<> will _bindImp() on ' stop
					.writeDeepString()
				_bindImp()
				assert _didBindImpBase, this
				_didBindImp = true
			finally
				_isBindingImp = false
		return this

	def _bindImp
		"""
		Bind implementation elements such as statements and expressions.
		Override this method; do not send it. Invoke base.
		"""
		require .compiler
		_didBindImpBase = true

	def bindAll as INode  # CC: as this
		.bindInt()
		.bindImp()
		return this

	get didBindInt from var

	get didBindImp from var


	##
	## Errors
	##

	# TODO: rename _error to something like _reportError and _recordedError to _error

	def _error(msg as String)
		"""
		Subclasses should invoke this method whenever they detect an error during compilation
		(bindInt and bindImp, but not code gen).
		"""
		ne = NodeException(this, msg)
		_recordedError = ne
		throw ne

	var _recordedError as NodeException?

	get recordedError from var

	def recordErrorAndThrow(ce as CobraException) as bool
		"""
		Subclasses should invoke this error message as part of the error recovery process--
		a process that should be implemented in various for..in loops that enumerate over
		subnodes.
		"""
		require .compiler
		return .compiler.recordErrorAndThrow(ce)


	##
	## Converting to string
	##

	def toString as String is override
		return .shallowString

	def toTechString as String
		return .deepString

	get minimalString as String
		"""
		Includes only atomic data like numbers and strings.
		"""
		return _toString(true, false, false)

	get shallowString as String
		"""
		Includes minimal string plus references to other objects (their minimal strings).
		"""
		return _toString(true, true, false)

	get deepString as String
		"""
		Includes shallow string plus subobjects (their deep strings).
		"""
		return _toString(true, true, true)

	def addMinFields
		"""
		Subclasses should override to add minimal fields.
		"""
		pass

	def addRefFields
		pass

	def addSubFields
		pass

	def addField(name as String, value as Object?)
		"""
		Subclasses invoke this from their overrides of `addMinFields`,
		`addRefFields` and `addSubFields`.
		"""
		__curFields.add(Field(name, value))

	def addField(value as Object)
		.addField('', value)

	var __curFields as List<of Field>?

	def _toString(doMin as bool, doRef as bool, doSub as bool) as String
		"""
		This is the implementation for minimalString, shallowString and deepString.
		"""
		if doSub
			tag = 'de' # for deep
		else if doRef
			tag = 'sh' # for shallow
		else
			tag = 'mi' # for minimal

		sb = StringBuilder('[.getType.name]-[tag]([.serialNum]')

		if doMin
			__curFields = List<of Field>()
			try
				.addMinFields()
				for field in __curFields
					if field.name
						sb.append(', [field.name]=[field.value]')
					else
						sb.append(', [field.value]')
			finally
				__curFields = nil

		if doRef
			__curFields = List<of Field>()
			try
				.addRefFields()
				for field in __curFields
					value as Object?
					if field.value inherits Node
						value = (field.value to Node).minimalString
					else
						value = field.value
					sb.append(', [field.name]=[value]')
			finally
				__curFields = nil

		if doSub
			__curFields = List<of Field>()
			try
				.addSubFields()
				for field in __curFields
					value as Object?
					if field.value inherits Node
						value = (field.value to Node).minimalString
					else
						value = field.value
					sb.append(', [field.name]=[field.value]')
			finally
				__curFields = nil

		sb.append(')')
		s = sb.toString
		if s.length>100
			s = s.substring(0, s.length-1) + ', [.serialNum])'

		return s

	def writeDeepString
		.writeDeepString(IndentedWriter(Console.out))

	def writeDeepString(iw as IndentedWriter)
		_writeDeepString(iw, this, true, true, true)

	def _writeDeepString(iw as IndentedWriter, obj as INode, doMin as bool, doRef as bool, doSub as bool)
		if doSub
			iw.write(obj.shallowString)
			iw.write('\n')
			iw.indent()
			try
				__curFields = List<of Field>()
				try
					.addSubFields()
					for field in __curFields
						value = field.value
						if value inherits Node
							iw.write('[field.name]=')
							value._writeDeepString(iw, value, doMin, doRef, doSub)
							#iw.write('\n')
						else if $sharp('value is System.Collections.IList')
							# CC: should not need the 'v' local below
							v as System.Collections.IList = value to System.Collections.IList
							iw.write('[field.name]=' + r'[')  # CC: should be able to say: '[name]=\[\n'
							iw.writeLine('')
							iw.indent()
							try
								for i = 0 .. v.count
									iw.write('[i]=')
									# CC: should not need the typecasts below
									if v[i] inherits Node
										(v[i] to Node)._writeDeepString(iw, v[i] to Node, doMin, doRef, doSub)
									else
										# TODO: fix this to work for nested lists like those found in DictLit
										iw.write(v[i].toString)
							finally
								iw.dedent()
							iw.write(']\n')
						else
							iw.write('[field.name]=[value]\n')
				finally
					__curFields = nil
			finally
				iw.dedent()
			return
		if doRef
			iw.write(obj.shallowString)
			return
		if doMin
			iw.write(obj.minimalString)

	## Code gen

	def writeSharpDef(sw as SharpWriter)
		require .didBindInt or .didBindImp
		pass


interface ISyntaxNode
	inherits INode

	get token as IToken


class SyntaxNode
	inherits Node
	implements ISyntaxNode
	"""
	An abstract tree syntax node (AST).
	Also: a node with a token.
	Also: a node that came from parsing.

	Descendants include NamedNode, Box (indirectly), Stmt and Expr.
	"""

	var _token as IToken

	def init(token as IToken)
		_token = token

	get token from var

	get fileName as String
		return _token.fileName

	get lineNum as int
		return _token.lineNum

	def addMinFields is override
		base.addMinFields()
		.addField('token', .token.toTechString())

	def _error(msg as String) is override
		ne = SyntaxNodeException(this, msg)
		_recordedError = ne
		throw ne

	## Code gen

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.node(this)

	def writeSharpSetLine(sw as SharpWriter)
		if .compiler.hasSuperStackTraceOption and .lineNum>0
			sw.write('CobraImp.SetLine([.lineNum]);\n')


interface INamedNode
	inherits INode
	"""
	A NamedNode is just a syntax node plus a name.

	There is both a typeForIdentifier and typeForReceiver. That's
	because some NamedNodes like Class are a Type in the first case (`t
	= Console`) and themselves in the second case (`Console.out').

	TODO: can typeForIdentifier and typeForReceiver be moved down to
	IMember?
	"""

	get name as String

	get typeForIdentifier as IType
		"""
		The type that should be used when an identifier refers to this
		NamedNode as in "c = Console". See IdentifierExpr.
		"""

	get typeForReceiver as IType
		"""
		The type that should be used when a dotted expression refers to
		this NamedNode on the left side of the dot. See IdentifierExpr.
		"""

	get isMethod as bool
		"""
		Returns true if the named node is effectively a method. You might think
		"obj inherits Method" would suffice, but MemberOverload may also return true.
		"""

	get sharpName as String
		"""
		Return the name that should be used in C# source code.
		"""


interface INamedSyntaxNode
	inherits INamedNode, ISyntaxNode


class NamedNode
	inherits SyntaxNode
	implements INamedNode

#	invariant
#		.name

	var _name as String

	def init(token as IToken, name as String)
		require name
		base.init(token)
		_name = name

	get name from var

	def addMinFields is override
		base.addMinFields()
		.addField('name', .name)

	get typeForIdentifier as IType
		throw OverrideException(.getType)

	get typeForReceiver as IType
		throw OverrideException(.getType)

	get isMethod as bool
		return false

	## Code gen

	get sharpRef as String
		return .name

	get sharpName as String
		return _name


class Field

	var _name as String
	var _value as Object?

	def init(name as String, value as Object?)
		_name = name
		_value = value

	get name from var

	get value from var
