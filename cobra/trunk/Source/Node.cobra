class CobraException
	inherits SystemException

	def init(msg as String)
		base.init(msg)


class NodeException
	inherits CobraException

	var _node as INode
	var _message as String

	def init(node as INode, msg as String)
		base.init(msg)
		_node = node
		_message = msg

	get node from var

	get message as String is override
		if _node inherits SyntaxNode
			return '[_node.token.fileName]([_node.token.lineNum]): [_message]'
		else
			return _message

	def prefixMessage(s as String)
		_message = s + _message


class NodeMultiException
	inherits NodeException
	"""
	To provide good error recovery and to fully report all errors, it can be useful for parts of
	the code to catch exceptions that they then may need to throw all at once. Hence, the
	NodeMultiException. At least BinaryOpExpr uses it and Compiler.recordErrorAndThrow() checks
	for it.
	"""

	var _exceptions as List<of NodeException>

	def init(exceptions as vari NodeException)
		"""
		As a convenience to the caller, nil exceptions are quietly ignored and
		NodeMultiExceptions are recursively processed.
		"""
		base.init(Node(), 'multi exception')
		_exceptions = List<of NodeException>()
		_addExceptions(exceptions to passthrough)
		assert _exceptions, 'At least on exception must exist.'

	def _addExceptions(exceptions as IEnumerable<of NodeException?>)
		for exc in exceptions
			if exc
				if exc inherits NodeMultiException
					_addExceptions(exc.exceptions to passthrough)
				else
					_exceptions.add(exc)

	get exceptions from var


interface ISourceError
	"""
	All exceptions that represent errors in the Cobra source code being compiled implement ISourceError.
	"""

	get hasSourceInfo as bool
		"""
		Return true if the error really has source information (filename and line number). The
		`fileName` and `lineNum` properties will not be invoked if this returns false.
		"""

	get fileName as String
		# CC: require .hasSourceInfo

	get lineNum as int
		# CC: require .lineNum


class SyntaxNodeException
	inherits NodeException
	implements ISourceError

	var _synNode as ISyntaxNode

	def init(node as ISyntaxNode, msg as String)
		require
			node.token
			node.token.fileName
			node.token.lineNum
		body
			base.init(node, msg)
			_synNode = node

	get hasSourceInfo as bool
		return true

	get fileName as String
		return _synNode.token.fileName

	get lineNum as int
		return _synNode.token.lineNum


interface INode
	"""
	Just about everything in the Cobra compiler that forms a data
	structure of a program ultimately inherits from Node. For example,
	all types and ASTs descend from Node.

	However, the tokenizer, parser, compiler object and command line
	objects do not. They don't form the data structure that represents a
	program.
	"""

	get serialNum as int

	pro superNode as INode?


	##
	## Inquiries
	##

	get namedType as IType?
		"""
		If this node represents a type, this property returns it.
		Otherwise, returns nil (which is the default behavior).
		Implemented by TypeExpr and IdentifierExpr.
		TODO: Can this be moved down to Expr?
		"""


	##
	## Binding
	##

	def bindInt as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""

	def bindImp as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""

	def bindAll as INode  # CC: as this

	get didBindInt as bool

	get didBindImp as bool

	def throwError(msg as String)
		"""
		Sometimes an object detects an error in a subobject or argument. On that occasion,
		invoke `throwError` on that object. There are other error related methods and
		properties in Node.
		"""


	##
	## Converting to string
	##

	def toTechString as String

	get minimalString as String
		"""
		Includes only atomic data like numbers and strings.
		"""

	get shallowString as String
		"""
		Includes minimal string plus references to other objects (their minimal strings).
		"""

	get deepString as String
		"""
		Includes shallow string plus subobjects (their deep strings).
		"""

	def writeDeepString(iw as IndentedWriter)

	def writeDeepString
		"""
		Wraps Console.out in an IndentedWriter.
		"""


class Node
	implements INode
	"""
	Just about everything in the Cobra compiler that forms a data
	structure of a program ultimately inherits from Node. For example,
	all types and ASTs descend from Node.

	However, the tokenizer, parser, compiler object and command line
	objects do not.
	"""

	shared
		var _nextNodeSerialNum = 1001
		var _compiler as Compiler?

		pro compiler from var

		def setCompiler(c as Compiler?) # CC: axe this method after the shared property is working
			_compiler = c

		def getCompiler as Compiler
			assert _compiler
			return _compiler to Compiler  # CC: axe cast

	var _serialNum as int

	var _didBindInt as bool
	var _didBindImp as bool

	var _isBindingInt as bool
	var _isBindingImp as bool

	var _didBindIntBase as bool
	var _didBindImpBase as bool

	var _superNode as INode?
		"""
		Possibly points to the node that owns this node.
		But this is not strictly required. It's used only when needed (typically in expressions).
		"""


	def init
		ensure
			.serialNum > 1000
			not .didBindInt
			not .didBindImp
		body
			_serialNum = _nextNodeSerialNum
			_nextNodeSerialNum += 1

	get serialNum from var

	pro superNode as INode?
		get
			return var
		set
			var = value


	##
	## Inquiries
	##

	get namedType as IType?
		"""
		If this node represents a type, this property returns it.
		Otherwise, returns nil (which is the default behavior).
		Implemented by TypeExpr and IdentifierExpr.
		TODO: Can this be moved down to Expr?
		"""
		return nil


	##
	## Binding
	##

	def bindInt as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""
		require
			.compiler
			.compiler.globalNS
		body
			if not _didBindInt and not _isBindingInt
				_isBindingInt = true
				try
					_didBindIntBase = false
					if .compiler.verbosity>3
						print '<> will _bindInt() on ' stop
						.writeDeepString()
					_bindInt()
					assert _didBindIntBase, this
					_didBindInt = true
				finally
					_isBindingInt = false
			return this

	def _bindInt
		"""
		Bind interface elements such as return types and parameter types.
		Override this method; do not send it. Invoke base.
		"""
		require .isBindingInt
		_didBindIntBase = true

	def bindImp as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""
		require
			.compiler
			.compiler.globalNS
		body
			if not _didBindImp and not _isBindingImp
				_isBindingImp = true
				try
					_didBindImpBase = false
					if .compiler.verbosity>3
						print '<> will _bindImp() on ' stop
						.writeDeepString()
					_bindImp()
					assert _didBindImpBase, this
					_didBindImp = true
				finally
					_isBindingImp = false
			return this

	def _bindImp
		"""
		Bind implementation elements such as statements and expressions.
		Override this method; do not send it. Invoke base.
		"""
		require .isBindingImp
		_didBindImpBase = true

	def bindAll as INode  # CC: as this
		.bindInt()
		.bindImp()
		return this

	get isBindingInt from var

	get isBindingImp from var

	get didBindInt from var

	get didBindImp from var


	##
	## Errors
	##

	var _errors as List<of NodeException>?

	get errors from var

	def throwError(ne as NodeException)
		"""
		Subclasses should invoke this method whenever they detect an error during compilation
		(bindInt and bindImp, but not code gen during which no user errors should occur).
		The error will be recorded by the node, but not explicitly noted by the compiler.
		Control flow does not return to the caller because the exception is thrown.
		In practice, this exception will be caught at some level as part of error recovery.
		"""
		require ne.node is this
		_recordError(ne)
		throw ne

	def throwError(msg as String)
		.throwError(NodeException(this, msg))

	def recordError(ne as NodeException)
		"""
		Record an error for this node with the given message.
		The error will be noted by the compiler.
		No exception is thrown and control returns to the caller.

		Note that when catching errors from subobjects, the correct invocation is
		`.compiler.recordError()` since the caught error would have already been
		recorded by that object.
		"""
		require
			.compiler
			ne.node is this
		body
			_recordError(ne)
			.compiler.recordError(ne)

	def recordError(msg as String)
		.recordError(NodeException(this, msg))

	def _recordError(ne as NodeException)
		"""
		Records the error without notifying the compiler or throwing an exception--those are done
		by the public `throwError` and `recordError` methods.
		"""
		require ne.node is this
		if _errors is nil
			_errors = List<of NodeException>()
		else
			assert ne not in _errors
		_errors.add(ne)


	##
	## Converting to string
	##

	def toString as String is override
		return .shallowString

	def toTechString as String
		return .deepString

	get minimalString as String
		"""
		Includes only atomic data like numbers and strings.
		"""
		return _toString(true, false, false)

	get shallowString as String
		"""
		Includes minimal string plus references to other objects (their minimal strings).
		"""
		return _toString(true, true, false)

	get deepString as String
		"""
		Includes shallow string plus subobjects (their deep strings).
		"""
		return _toString(true, true, true)

	def addMinFields
		"""
		Subclasses should override to add minimal fields.
		"""
		if .isBindingInt
			.addField('isBindingInt', .isBindingInt)
		.addField('didBindInt', .didBindInt)
		if .isBindingImp
			.addField('isBindingImp', .isBindingImp)
		.addField('didBindImp', .didBindImp)

	def addRefFields
		pass

	def addSubFields
		pass

	def addField(name as String, value as Object?)
		"""
		Subclasses invoke this from their overrides of `addMinFields`,
		`addRefFields` and `addSubFields`.
		"""
		__curFields.add(Field(name, value))

	def addField(value as Object)
		.addField('', value)

	var __curFields as List<of Field>?

	def _toString(doMin as bool, doRef as bool, doSub as bool) as String
		"""
		This is the implementation for minimalString, shallowString and deepString.
		"""
		if doSub
			tag = 'de' # for deep
		else if doRef
			tag = 'sh' # for shallow
		else
			tag = 'mi' # for minimal

		sb = StringBuilder('[.getType.name]-[tag]([.serialNum]')

		if doMin
			__curFields = List<of Field>()
			try
				.addMinFields()
				for field in __curFields
					if field.name
						sb.append(', [field.name]=[field.value]')
					else
						sb.append(', [field.value]')
			finally
				__curFields = nil

		if doRef
			__curFields = List<of Field>()
			try
				.addRefFields()
				for field in __curFields
					value as Object?
					if field.value inherits Node
						value = (field.value to Node).minimalString
					else
						value = field.value
					sb.append(', [field.name]=[value]')
			finally
				__curFields = nil

		if doSub
			__curFields = List<of Field>()
			try
				.addSubFields()
				for field in __curFields
					value as Object?
					if field.value inherits Node
						value = (field.value to Node).minimalString
					else
						value = field.value
					sb.append(', [field.name]=[field.value]')
			finally
				__curFields = nil

		sb.append(')')
		s = sb.toString
		if s.length>100
			s = s.substring(0, s.length-1) + ', [.serialNum])'

		return s

	def writeDeepString
		.writeDeepString(IndentedWriter(Console.out))

	def writeDeepString(iw as IndentedWriter)
		_writeDeepString(iw, this, true, true, true)

	def _writeDeepString(iw as IndentedWriter, obj as INode, doMin as bool, doRef as bool, doSub as bool)
		if doSub
			iw.write(obj.shallowString)
			iw.write('\n')
			iw.indent()
			try
				__curFields = List<of Field>()
				try
					.addSubFields()
					for field in __curFields
						value = field.value
						if value inherits Node
							iw.write('[field.name]=')
							value._writeDeepString(iw, value, doMin, doRef, doSub)
							#iw.write('\n')
						else if $sharp('loc_value is System.Collections.IList')
							# CC: should not need the 'v' local below
							v as System.Collections.IList = value to System.Collections.IList
							iw.write('[field.name]=' + r'[')  # CC: should be able to say: '[name]=\[\n'
							iw.writeLine('')
							iw.indent()
							try
								for i = 0 .. v.count
									iw.write('[i]=')
									# CC: should not need the typecasts below
									if v[i] inherits Node
										(v[i] to Node)._writeDeepString(iw, v[i] to Node, doMin, doRef, doSub)
									else
										# TODO: fix this to work for nested lists like those found in DictLit
										iw.write(v[i].toString)
							finally
								iw.dedent()
							iw.write(']\n')
						else
							iw.write('[field.name]=[value]\n')
				finally
					__curFields = nil
			finally
				iw.dedent()
			return
		if doRef
			iw.write(obj.shallowString)
			return
		if doMin
			iw.write(obj.minimalString)

	## Code gen

	def writeSharpDef(sw as SharpWriter)
		require .didBindInt or .didBindImp
		pass


interface ISyntaxNode
	inherits INode

	get token as IToken


class SyntaxNode
	inherits Node
	implements ISyntaxNode
	"""
	An abstract tree syntax node (AST).
	Also: a node with a token.
	Also: a node that came from parsing.

	Descendants include NamedNode, Box (indirectly), Stmt and Expr.
	"""

	var _token as IToken

	def init(token as IToken)
		_token = token

	get token from var

	get fileName as String
		return _token.fileName

	get lineNum as int
		return _token.lineNum

	def addMinFields is override
		base.addMinFields()
		.addField('token', .token.toTechString())

	def throwError(msg as String) is override
		.throwError(SyntaxNodeException(this, msg))

	# CC: axe this:
	def throwError(ne as NodeException) is override
		base.throwError(ne)

	def recordError(msg as String) is override
		.recordError(SyntaxNodeException(this, msg))

	# CC: axe this
	def recordError(ne as NodeException) is override
		base.recordError(ne)

	## Code gen

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.node(this)


interface INamedNode
	inherits INode
	"""
	A NamedNode is just a syntax node plus a name.

	There is both a typeForIdentifier and typeForReceiver. That's
	because some NamedNodes like Class are a Type in the first case (`t
	= Console`) and themselves in the second case (`Console.out').

	TODO: can typeForIdentifier and typeForReceiver be moved down to
	IMember?
	"""

	get name as String

	get typeForIdentifier as IType
		"""
		The type that should be used when an identifier refers to this
		NamedNode as in "c = Console". See IdentifierExpr.
		"""

	get typeForReceiver as IType
		"""
		The type that should be used when a dotted expression refers to
		this NamedNode on the left side of the dot. See IdentifierExpr.
		"""

	get isMethod as bool
		"""
		Returns true if the named node is effectively a method. You might think
		"obj inherits Method" would suffice, but MemberOverload may also return true.
		"""

	pro isUsed as bool
		"""
		Defaults to false and is set to true when a node is used/read.
		This can then be inspected to generate warnings about unused declarations.
		"""

	get sharpName as String
		"""
		Return the name that should be used in C# source code.
		"""


interface INamedSyntaxNode
	inherits INamedNode, ISyntaxNode


class NamedNode
	inherits SyntaxNode
	implements INamedNode

#	invariant
#		.name

	var _name as String
	var _isUsed as bool

	def init(token as IToken, name as String)
		require name
		base.init(token)
		_name = name

	get name from var

	def addMinFields is override
		.addField('name', .name)
		base.addMinFields()

	get typeForIdentifier as IType
		throw OverrideException(.getType)

	get typeForReceiver as IType
		throw OverrideException(.getType)

	get isMethod as bool
		return false

	pro isUsed from var

	## Code gen

	get sharpRef as String
		return .name

	get sharpName as String
		return _name


class Field

	var _name as String
	var _value as Object?

	def init(name as String, value as Object?)
		_name = name
		_value = value

	get name from var

	get value from var
