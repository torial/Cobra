class CobraException
	inherits SystemException

	def construct(msg as String)
		base.construct(msg)


class NodeException
	inherits CobraException

	var _node as INode

	def construct(node as INode, msg as String)
		base.construct(msg)
		_node = node

	get node from var


interface INode
	"""
	Just about everything in the Cobra compiler that forms a data
	structure of a program ultimately inherits from Node. For example,
	all types and ASTs descend from Node.

	However, the tokenizer, parser, compiler object and command line
	objects do not.
	"""

	get serialNum as int

	pro superNode as INode?


	##
	## Inquiries
	##

	get namedType as IType?
		"""
		If this node represents a type, this property returns it.
		Otherwise, returns nil (which is the default behavior).
		Implemented by TypeExpr and IdentifierExpr.
		TODO: Can this be moved down to Expr?
		"""


	##
	## Binding
	##

	def bindInt as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""

	def bindImp as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""

	def bindAll as INode  # CC: as this

	get didBindInt as bool

	get didBindImp as bool


	##
	## Converting to string
	##

	def toTechString as String

	get minimalString as String
		"""
		Includes only atomic data like numbers and strings.
		"""

	get shallowString as String
		"""
		Includes minimal string plus references to other objects (their minimal strings).
		"""

	get deepString as String
		"""
		Includes shallow string plus subobjects (their deep strings).
		"""

	def writeDeepString(iw as IndentedWriter)


class Node
	implements INode
	"""
	Just about everything in the Cobra compiler that forms a data
	structure of a program ultimately inherits from Node. For example,
	all types and ASTs descend from Node.

	However, the tokenizer, parser, compiler object and command line
	objects do not.
	"""

	shared
		var _nextNodeSerialNum = 1001
		var _compiler as Compiler?

		pro compiler from var

		def setCompiler(c as Compiler?) # CC: axe this method after the shared property is working
			_compiler = c

	var _serialNum as int

	var _didBindInt as bool
	var _didBindImp as bool
	var _superNode as INode?
		"""
		Possibly points to the node that owns this node.
		But this is not strictly required. It's used only when needed (typically in expressions).
		"""


	def construct
		ensure
			.serialNum > 1000
			not .didBindInt
			not .didBindImp
		code
			_serialNum = _nextNodeSerialNum
			_nextNodeSerialNum += 1

	get serialNum from var

	pro superNode as INode?
		get
			return var
		set
			var = value


	##
	## Inquiries
	##

	get namedType as IType?
		"""
		If this node represents a type, this property returns it.
		Otherwise, returns nil (which is the default behavior).
		Implemented by TypeExpr and IdentifierExpr.
		TODO: Can this be moved down to Expr?
		"""
		return nil


	##
	## Binding
	##

	# TODO: sent _didBindInt in bindInt and _didBindImp in bindImp *AND* add in a _didBindIntBase/Imp to test that base._bindInt()/Imp() was called. test for that in the outer methods bindInt/Imp

	def bindInt as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""
		require .compiler
		if not _didBindInt
			_bindInt()
			assert _didBindInt
		return this

	def _bindInt
		"""
		Bind interface elements such as return types and parameter types.
		Override this method; do not send it. Invoke base.
		"""
		require .compiler
		_didBindInt = true

	def bindImp as INode  # CC: as this
		"""
		Invoke this method; do not override it.
		"""
		if not _didBindImp
			_bindImp()
			assert _didBindImp
		return this

	def _bindImp
		"""
		Bind implementation elements such as statements and expressions.
		Override this method; do not send it. Invoke base.
		"""
		require .compiler
		_didBindImp = true

	def bindAll as INode  # CC: as this
		.bindInt()
		.bindImp()
		return this

	get didBindInt from var

	get didBindImp from var


	##
	## Errors
	##

	def _error(msg as String)
		throw NodeException(this, msg)


	##
	## Converting to string
	##

	def toString as String is override
		return .shallowString

	def toTechString as String
		return .deepString

	get minimalString as String
		"""
		Includes only atomic data like numbers and strings.
		"""
		return _toString(true, false, false)

	get shallowString as String
		"""
		Includes minimal string plus references to other objects (their minimal strings).
		"""
		return _toString(true, true, false)

	get deepString as String
		"""
		Includes shallow string plus subobjects (their deep strings).
		"""
		return _toString(true, true, true)

	def addMinFields
		"""
		Subclasses should override to add minimal fields.
		"""
		pass

	def addRefFields
		pass

	def addSubFields
		pass

	def addField(name as String, value as Object?)
		"""
		Subclasses invoke this from their overrides of `addMinFields`,
		`addRefFields` and `addSubFields`.
		"""
		__curFields.add(Field(name, value))

	def addField(value as Object)
		.addField('', value)

	var __curFields as List<of Field>?

	def _toString(doMin as bool, doRef as bool, doSub as bool) as String
		"""
		This is the implementation for minimalString, shallowString and deepString.
		"""
		if doSub
			tag = 'd' # for deep
		else if doRef
			tag = 's' # for shallow
		else
			tag = 'm' # for minimal

		sb = StringBuilder('[.getType().name]-[tag]([.serialNum]')

		if doMin
			__curFields = List<of Field>()
			try
				.addMinFields()
				for field in __curFields
					if field.name
						sb.append(', [field.name]=[field.value]')
					else
						sb.append(', [field.value]')
			finally
				__curFields = nil

		if doRef
			__curFields = List<of Field>()
			try
				.addRefFields()
				for field in __curFields
					value as Object?
					if field.value inherits Node
						value = (field.value to Node).minimalString
					else
						value = field.value
					sb.append(', ref:[field.name]=[value]')
			finally
				__curFields = nil

		if doSub
			__curFields = List<of Field>()
			try
				.addSubFields()
				for field in __curFields
					value as Object?
					if field.value inherits Node
						value = (field.value to Node).minimalString
					else
						value = field.value
					sb.append(', sub:[field.name]=[field.value]')
			finally
				__curFields = nil

		sb.append(')')
		s = sb.toString()
		if s.length>100
			s = s.substring(0, s.length-1) + ', [.serialNum])'

		return s

	def writeDeepString(iw as IndentedWriter)
		_writeDeepString(iw, this, true, true, true)

	def _writeDeepString(iw as IndentedWriter, obj as INode, doMin as bool, doRef as bool, doSub as bool)
		if doSub
			iw.write(obj.shallowString)
			iw.write('\n')
			iw.indent()
			try
				__curFields = List<of Field>()
				try
					.addSubFields()
					for field in __curFields
						value = field.value
						if value inherits Node
							iw.write('sub:[field.name]=')
							value._writeDeepString(iw, value, doMin, doRef, doSub)
							#iw.write('\n')
						else if value inherits System.Collections.IList
							# CC: should not need the 'v' local below
							v as System.Collections.IList = value to System.Collections.IList
							iw.write('sub:[field.name]=' + r'[')  # CC: should be able to say: 'sub:[name]=\[\n'
							iw.writeLine('')
							iw.indent()
							try
								for i = 0 .. v.count
									iw.write('[i]=')
									# CC: should not need the typecasts below
									(v[i] to Node)._writeDeepString(iw, v[i] to Node, doMin, doRef, doSub)
							finally
								iw.dedent()
							iw.write(']\n')
						else
							iw.write('sub:[field.name]=[value]\n')
				finally
					__curFields = nil
			finally
				iw.dedent()
			return
		if doRef
			iw.write(obj.shallowString)
			return
		if doMin
			iw.write(obj.minimalString)

class SyntaxNode
	inherits Node
	"""
	An abstract tree syntax node (AST).
	Also: a node with a token.
	Also: a node that came from parsing.

	Descendants include NamedNode, Box (indirectly), Stmt and Expr.
	"""

	var _token as IToken

	def construct(token as IToken)
		_token = token

	get token from var

	def addMinFields is override
		base.addMinFields()
		.addField('token', .token.toTechString())


interface INamedNode
	inherits INode

	get name as String


class NamedNode
	inherits SyntaxNode
	implements INamedNode
	"""
	A NamedNode is just a syntax node plus a name.
	"""

#	invariant
#		.name

	var _name as String

	def construct(token as IToken, name as String)
		require name
		base.construct(token)
		_name = name

	get name from var

	def addMinFields is override
		base.addMinFields()
		.addField('name', .name)


class Field

	var _name as String
	var _value as Object?

	def construct(name as String, value as Object?)
		_name = name
		_value = value

	get name from var

	get value from var
