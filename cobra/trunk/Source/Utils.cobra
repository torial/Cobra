class Utils

	shared

		def combinePaths(a as String, b as String) as String
			"""
			Same as Path.combine() but leaves no '\.\' or '/./' in the result.
			"""
			p = Path.combine(a, b)
			good as String = Path.directorySeparatorChar.toString  # CC: should not need "as String" here
			bad = '[good].[good]'
			p = p.replace(bad, good)
			return p

		def normalizePath(path as String) as String
			# TODO: this needs cleanup
			while path.startsWith('.\\')
				path = path.substring(2)
			while path.startsWith('./')
				path = path.substring(2)
			return path

		def capped(s as String) as String
			"""
			Returns the string with the first character capitalized.
			Returns a blank string for a blank string.
			"""
			ensure
				result.length==s.length
				result.length implies result[0]==result[0].toString.toUpper()
			test
				assert Utils.capped('chuck')=='Chuck'
				assert Utils.capped('Chuck')=='Chuck'
				assert Utils.capped('')==''
				assert Utils.capped(' foo')==' foo'
				assert Utils.capped('f')=='F'
				assert Utils.capped('1aoeu')=='1aoeu'
			body
				if s.length==0
					return s
				return s.substring(0, 1).toUpper() + s.substring(1, s.length-1)

		def uncapped(s as String) as String
			"""
			Returns the string with the first character NOT-capitalized.
			Returns a blank string for a blank string.
			"""
			ensure
				result.length==s.length
				result.length implies result[0]==result[0].toString.toLower()
			test
				assert Utils.uncapped('Chuck')=='chuck'
				assert Utils.uncapped('chuck')=='chuck'
				assert Utils.uncapped('')==''
				assert Utils.uncapped(' foo')==' foo'
				assert Utils.uncapped('F')=='f'
				assert Utils.uncapped('1aoeu')=='1aoeu'
			body
				if s.length==0
					return s
				return s[0].toString.toLower() to String + s.substring(1) to String # CC: should not need casts!

		def isCapped(s as String) as bool
			test
				assert Utils.isCapped('Aoeu')
				assert Utils.isCapped('Zaoeu')
				assert not Utils.isCapped('aoeu')
				assert not Utils.isCapped('')
				assert not Utils.isCapped('1234')
			body
				return s.length and s[0]>=c'A' and s[0]<=c'Z'

		def startsWithLowerLetter(s as String) as bool
			require
				s.length
			test
				assert Utils.startsWithLowerLetter('a')
				assert Utils.startsWithLowerLetter('z')
				assert not Utils.startsWithLowerLetter('A')
				assert not Utils.startsWithLowerLetter('1')
				assert not Utils.startsWithLowerLetter('_')
			body
				return $sharp(r'char.IsLower(s[0])')

		def startsNonLower(s as String) as bool
			require
				s.length
			test
				assert not Utils.startsNonLower('a')
				assert not Utils.startsNonLower('z')
				assert not Utils.startsNonLower('1')
				assert Utils.startsNonLower('A')
			body
				return not s[0].toString==s[0].toString.toLower()  # CC: should be char.isLower(s[0]), but cannot see members of char at this time

		def countChars(s as String, c as char) as int
			test
				assert Utils.countChars('', c'x')==0
				assert Utils.countChars('x', c'x')==1
				assert Utils.countChars('X', c'x')==0  # case sensitive
				assert Utils.countChars(' ! ! ', c'!')==2
			body
				count = 0
				for ch in s
					if c==ch
						count += 1
				return count

		# CC: the getXX() methods should be generic methods

		def getSI(d as Dictionary<of String, int>, key as String, defaultValue as int) as int
			if d.containsKey(key)
				return d[key]
			else
				return defaultValue

		def getSS(d as Dictionary<of String, String?>, key as String, defaultValue as String?) as String?
			if d.containsKey(key)
				return d[key]
			else
				return defaultValue

		def getSO(d as Dictionary<of String, Object>, key as String, defaultValue as Object?) as Object?
			if d.containsKey(key)
				return d[key]
			else
				return defaultValue

		def join(sep as String, parts as System.Collections.IEnumerable) as String  # TODO: given that this seems necessary, should Cobra add "use System.Collections" to all programs?
			test
				assert Utils.join('.', ['a', 'b'])=='a.b'
			body
				sb = StringBuilder()
				s = ''
				for part in parts
					sb.append(s)
					sb.append(part.toString)
					s = sep
				return sb.toString

		def join(sep as String, parts as vari String) as String  # CC: shouldn't need this because vari should implement IEnumerable
			return .join(sep, parts to System.Collections.IEnumerable)

		## Code gen

		def csStringLitFor(s as String) as String
			#print '<> csStringLitFor'
			#print '   ([s])'
			sb = StringBuilder()
			sb.append('"')
			for c in s
				branch c
					on c'\n': sb.append('\\n')
					on c'\r': sb.append('\\r')
					on c'\t': sb.append('\\t')
					on c'\0': sb.append('\\0')
					on c'\\': sb.append('\\\\')
					on c'"': sb.append('\\"')
					else: sb.append(c)
			sb.append('"')
			r = sb.toString
			#print '   ([r])'
			return r


class OverrideException
	inherits Exception

	# TODO: is there already an exception for this in .NET?

	var _type as Type?

	def init
		base.init()

	def init(t as Type)
		base.init('Type is [t]')
		_type = t
