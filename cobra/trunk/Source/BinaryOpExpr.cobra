class BinaryOpExpr
	inherits Expr

	shared
		def make(opToken as IToken, op as String, left as Expr, right as Expr) as BinaryOpExpr
			"""
			Instantiates the correct class for the given operator and returns it.
			"""
			branch opToken.which
				on 'TO'
					return ToExpr(opToken, op, left, right)
				on 'ASSIGN'
					return AssignExpr(opToken, op, left, right)
				on 'EQ', 'NE', 'LT', 'GT', 'LE', 'GE'
					return CompareExpr(opToken, op, left, right)
				else
					return BinaryOpExpr(opToken, op, left, right)
			# CC: axe the if true pass below which is there to shore up a parsing bug for branch. or maybe it's the multiline else above because it was single line originally and I had to change it
			if true
				pass

	var _op as String
	var _left as Expr
	var _right as Expr
	var _definition as IMember?

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken)
		_op = op
		_left = left
		_left.superNode = this
		_right = right
		_right.superNode = this

	get op from var

	get left from var

	get right from var

	pro definition from var

	def setReceiverType(t as IType?)
		# this method is for MemberExpr
		# TODO: this will probably go away when a DotExpr subclass is made
		_receiverType = t

	def bindImp as INode is override
		base.bindImp()
		assert .didBindImp
		# TODO: maybe check() should only be invoked if left and right were bound without error
		.check()
		return this

	def _bindImp is override
		base._bindImp()
		assert _left is not this, this
		assert _right is not this, this
		_left.bindImp()
		_right.bindImp()
		assert _left.didBindImp
		assert _right.didBindImp

	def check
		"""
		Invoked after bindImp() in order to do more error checking.
		So this is a hook for subclasses to do error checking after
		left and right have been successfully bound.
		"""
		pass

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	def addSubFields is override
		base.addSubFields()
		.addField('op', _op)
		.addField('left', _left)
		.addField('right', _right)


class AssignExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

# TODO:
#	def _bindImp is override
#		base._bindImp()
#		left = _left
#		right = _right
#		if left inherits IdentifierExpr and left.definition is nil:
#			assert right.type
#			if right.type is tpassthrough
#				_error('Cannot infer type for "[left.text]" because the type of the right hand expression is unknown.')
#			# type inference
#			if left.text.startswith('_'):
#				self.error('No class variable named "%s" exists and local variable declarations cannot start with an underscore (_).' % left.text)
#			definition = LocalVar(left.token, right.type)
#			definition.bindAll(compiler)
#			compiler.nameStack.peek().pushName(definition)
#			left.definition = definition
#			left.type = definition.type
#		if left.definition is nil
#			compiler.errorUnknownId(left, left.text)

	def check is override
		base.check()
		if _left inherits IdentifierExpr
			assert _left.definition
			if _left.definition inherits Param
				if _right inherits IdentifierExpr
					if _right.definition inherits ClassVar
						.compiler.warning(this, 'Setting a parameter to a class variable is often a mistake. You may want to reverse the assignment.')


class CompareExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType


class ToExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _right.isKindOf(.compiler.typeType)
			_error('The "to" operator does not apply to "[_right.toCobraSource()]". Use a type.')
		if _right inherits TypeExpr
			_type = _right.receiverType
		else if _right inherits IdentifierExpr
			_type = _right.type
		else
			assert false, _right
