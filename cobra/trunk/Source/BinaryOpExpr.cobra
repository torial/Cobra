class BinaryOpExpr
	inherits Expr

	shared
		def make(opToken as IToken, op as String, left as Expr, right as Expr) as BinaryOpExpr
			"""
			Instantiates the correct class for the given operator and returns it.
			"""
			branch op
				on 'TO'
					return ToExpr(opToken, op, left, right)
				on 'TOQ'
					return ToQExpr(opToken, op, left, right)
				on 'ASSIGN'
					return AssignExpr(opToken, op, left, right)
				on 'DOT'
					return DotExpr(opToken, op, left, right)
				on 'INHERITS'
					return InheritsExpr(opToken, op, left, right)
				on 'IN', 'NOTIN'
					return InExpr(opToken, op, left, right)
				on 'IS', 'ISNOT', 'EQ', 'NE', 'LT', 'GT', 'LE', 'GE'
					return CompareExpr(opToken, op, left, right)
				on 'AND', 'OR'
					return BinaryBoolExpr(opToken, op, left, right)
				on 'PLUS', 'MINUS', 'STAR', 'SLASH', 'SLASHSLASH', 'PERCENT'
					return BinaryMathExpr(opToken, op, left, right)
				on 'PLUS_EQUALS', 'MINUS_EQUALS', 'STAR_EQUALS', 'SLASH_EQUALS', 'SLASHSLASH_EQUALS', 'PERCENT_EQUALS'
					return AugAssignMathExpr(opToken, op, left, right)
				else
					return BinaryOpExpr(opToken, op, left, right)
			# CC: axe the if true pass below which is there to shore up a parsing bug for branch. or maybe it's the multiline else above because it was single line originally and I had to change it
			if true
				pass

	var _op as String
	var _left as Expr
	var _right as Expr
	var _definition as IMember?

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken)
		_op = op
		_left = left
		_left.superNode = this
		_right = right
		_right.superNode = this

	get op from var

	get left from var

	get right from var

	pro definition from var

	def setReceiverType(t as IType?)
		# this method is for MemberExpr
		# TODO: this will probably go away when a DotExpr subclass is made
		_receiverType = t

	def bindImp as INode is override
		base.bindImp()
		assert .didBindImp
		# TODO: maybe check() should only be invoked if left and right were bound without error
		.check()
		return this

	def _bindImp is override
		base._bindImp()
		assert _left is not this, this
		assert _right is not this, this
		_left.bindImp()
		_right.bindImp()
		assert _left.didBindImp
		assert _right.didBindImp

	def check
		"""
		Invoked after bindImp() in order to do more error checking.
		So this is a hook for subclasses to do error checking after
		left and right have been successfully bound.
		"""
		pass

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	def addSubFields is override
		base.addSubFields()
		.addField('op', _op)
		.addField('left', _left)
		.addField('right', _right)


class AssignExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		left = _left
		right = _right
		assert right.type
		_type = left.type
# TODO:
#		if left inherits IdentifierExpr and left.definition is nil:
#			assert right.type
#			if right.type is tpassthrough
#				_error('Cannot infer type for "[left.text]" because the type of the right hand expression is unknown.')
#			# type inference
#			if left.text.startswith('_'):
#				_error('No class variable named "%s" exists and local variable declarations cannot start with an underscore (_).' % left.text)
#			definition = LocalVar(left.token, right.type)
#			definition.bindAll(compiler)
#			compiler.nameStack.peek().pushName(definition)
#			left.definition = definition
#			left.type = definition.type
#		if left.definition is nil
#			compiler.errorUnknownId(left, left.text)
		if not right.canBeAssignedTo(left.type to IType)
			_error('Incompatible types. Cannot assign value of type [right.type.name] on the right to [left.type.name] on the left.')

	def check is override
		base.check()
		if _left inherits IdentifierExpr
			assert _left.definition
			if _left.definition inherits Param
				if _right inherits IdentifierExpr
					if _right.definition inherits ClassVar
						.compiler.warning(this, 'Setting a parameter to a class variable is often a mistake. You may want to reverse the assignment.')


class NumericPromoExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		tint = .compiler.intType
		tdecimal = .compiler.decimalType
		tfloat = .compiler.floatType
		tpassthrough = .compiler.floatType
		tstring = .compiler.libraryType('System', 'String')
		cannotMix = false
		if _left.isKindOf(tint)
			if _right.isKindOf(tint)
				# special case: true division
				# if both sides are ints, the type becomes decimal
				if _op=='SLASH'
					_type = tdecimal
				else
					_type = tint
			else if _right.isKindOf(tdecimal)
				_type = tdecimal
			else if _right.isKindOf(tfloat)
				_type = tfloat
		else if _left.isKindOf(tdecimal)
			if _right.isKindOf(tdecimal)
				_type = tdecimal
			else if _right.isKindOf(tint)
				_type = tdecimal
			else if _right.isKindOf(tfloat)
				cannotMix = true
			else
				cannotMix = true
		else if _left.isKindOf(tfloat)
			if _right.isKindOf(tfloat)
				_type = tfloat
			else if _right.isKindOf(tint)
				_type = tfloat
			else if _right.isKindOf(tdecimal)
				cannotMix = true
			else
				cannotMix = true
		else if _left.isKindOf(tstring)
			if _right.isKindOf(tstring)
				_type = tstring
			else
				cannotMix = true
		if cannotMix
			if _left.isKindOf(tpassthrough) or _right.isKindOf(tpassthrough)
				_type = tpassthrough
			else
				_error('Cannot mix types [_left.type.name] and [_right.type.name] for arithmetic.')
		assert _type


class AugAssignMathExpr
	inherits NumericPromoExpr
	"""
	How should:
		someInt /= someInt
	be handled given that
		someInt / someInt
	gives a decimal?
	"""

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()


class BinaryBoolExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType


class BinaryMathExpr
	inherits NumericPromoExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)
		assert op in ['PLUS', 'MINUS', 'STAR', 'SLASH', 'SLASHSLASH', 'PERCENT']


class CompareExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType


class DotExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _type
			assert _right.type
			_type = _right.type

	get namedType as IType? is override
		# overridden to return the type this dotted expr represents in those cases when it does represent a type
		assert .didBindImp
		if _definition inherits IType
			return _definition to IType  # CC: shouldn't need this cast
		else
			return nil


class InExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType


class InheritsExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType


class AbstractToExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _right.isKindOf(.compiler.typeType)
			_error('The "to" operator does not apply to "[_right.toCobraSource()]". Use a type.')
		if _right inherits TypeExpr
			_type = _right.receiverType
		else if _right inherits IdentifierExpr
			_type = _right.definition to IType
		else
			assert false, _right
		assert _type


class ToExpr
	inherits AbstractToExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if _left inherits NilLiteral and not (_type inherits NilableType or _type inherits PassThroughType)
			_error('Cannot cast nil to a non-nil type.')


class ToQExpr
	inherits AbstractToExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _type inherits NilableType
			_type = NilableType(_type).bindAll() to NilableType  # CC: axe cast when 'as this' is supported
