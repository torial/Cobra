class BinaryOpExpr
	inherits Expr

	shared
		def make(opToken as IToken, op as String, left as Expr, right as Expr) as BinaryOpExpr
			"""
			Instantiates the correct class for the given operator and returns it.
			"""
			branch op
				on 'TO'
					return ToExpr(opToken, op, left, right)
				on 'TOQ'
					return ToQExpr(opToken, op, left, right)
				on 'QUESTION'
					return CoalesceExpr(opToken, op, left, right)
				on 'QUESTION_EQUALS'
					return CoalesceAssignExpr(opToken, op, left, right)
				on 'BANG'
					return InverseCoalesceExpr(opToken, op, left, right)
				on 'BANG_EQUALS'
					return InverseCoalesceAssignExpr(opToken, op, left, right)
				on 'ASSIGN'
					return AssignExpr(opToken, op, left, right)
				on 'DOT'
					return DotExpr(opToken, op, left, right)
				on 'INHERITS', 'IMPLEMENTS'
					return InheritsExpr(opToken, op, left, right)
				on 'IN', 'NOTIN'
					return InExpr(opToken, op, left, right)
				on 'IS', 'ISNOT', 'EQ', 'NE', 'LT', 'GT', 'LE', 'GE'
					return CompareExpr(opToken, op, left, right)
				on 'AND', 'OR', 'IMPLIES'
					return BinaryBoolExpr(opToken, op, left, right)
				on 'PLUS', 'MINUS', 'STAR', 'STARSTAR', 'SLASH', 'SLASHSLASH', 'PERCENT'
					return BinaryMathExpr(opToken, op, left, right)
				on 'PLUS_EQUALS', 'MINUS_EQUALS', 'STAR_EQUALS', 'STARSTAR_EQUALS', 'SLASH_EQUALS', 'SLASHSLASH_EQUALS', 'PERCENT_EQUALS'
					return AugAssignMathExpr(opToken, op, left, right)
				else
					throw FallThroughException([opToken, op, left, right])

	var _op as String
	var _left as Expr
	var _right as Expr
	var _definition as IMember?

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken)
		_op = op
		_left = left
		_left.superNode = this
		_right = right
		_right.superNode = this

	get op from var

	get left from var

	get right from var

	pro definition from var

	get hasError as bool is override
		if base.hasError
			return true
		if _left.hasError
			return true
		if _right.hasError
			return true
		return false

	def setReceiverType(t as IType?)
		# this method is for MemberExpr
		# TODO: this will probably go away when a DotExpr subclass is made
		_receiverType = t

	def bindImp as INode is override
		base.bindImp()
		assert .didBindImp
		# TODO: maybe check() should only be invoked if left and right were bound without error
		.checkAfterBindImp()
		.checkForVoids()
		return this

	def _bindImp is override
		base._bindImp()
		assert _left is not this, this
		assert _right is not this, this
		# The try..catch below enables errors to be detected on both sides of the operator
		try
			_left.bindImp()
		catch ne1 as NodeException
			gotError = true
			if _left.type is nil
				_left.type = .compiler.passThroughType
		try
			_right.bindImp()
		catch ne2 as NodeException
			gotError = true
			if _right.type is nil
				_right.type = .compiler.passThroughType
		if gotError
			_type = .compiler.passThroughType
			throw NodeMultiException(ne1, ne2)
		assert _left.didBindImp
		assert _right.didBindImp

	def checkAfterBindImp
		"""
		Invoked after bindImp() in order to do more error checking.
		So this is a hook for subclasses to do error checking after
		left and right have been successfully bound.
		"""
		require .didBindImp
		pass

	def checkForVoids
		left = _left
		right = _right
		voidType = .compiler.voidType
		# check for void on either side of the expression
		sugg = 'Use a different method or change that method to return something.'
		if left.type is voidType
			if left inherits BinaryOpExpr and (left to BinaryOpExpr).op=='DOT' and (left to BinaryOpExpr).right inherits CallExpr  # CC: axe casts
				append = ' because "[((left to BinaryOpExpr).right to CallExpr).name]" does not return anything.'  # CC: axe BinaryOp cast
			else
				append = '.'
			.throwError('There is no type for the left hand side of "[.token.text]"[append] [sugg]')
		if right.type is voidType and not right.isCalling
			if right inherits BinaryOpExpr and (right to BinaryOpExpr).op=='DOT' and (right to BinaryOpExpr).right inherits CallExpr  # CC: axe cast
				append = ' because "[((right to BinaryOpExpr).right to CallExpr).name]" does not return anything.'  # CC: axe BinaryOp cast
			else
				append = '.'
			.throwError('There is no type for the right hand side of "[.token.text]"[append] [sugg]')

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	def addSubFields is override
		base.addSubFields()
		.addField('op', _op)
		.addField('left', _left)
		.addField('right', _right)

	def toCobraSource as String is override
		return '([_left.toCobraSource()] [.token.text] [_right.toCobraSource()])'

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		_writeSharpDef(sw)
		if parens
			sw.write(')')

	def _writeSharpDef(sw as SharpWriter)
		pass

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		_writeSharpBreakdownItemsLeft(sw)
		_writeSharpBreakdownItemsRight(sw)

	def _writeSharpBreakdownItemsLeft(sw as SharpWriter)
		_left.writeSharpBreakdownItems(sw)

	def _writeSharpBreakdownItemsRight(sw as SharpWriter)
		_right.writeSharpBreakdownItems(sw)


class AbstractAssignExpr
	inherits BinaryOpExpr
	"""
	The abstract base class for AssignExpr and AugAssignExpr.
	"""

	var _trackLocal as bool  # for the super stack trace
	var _trackName as String?

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		# CC: axe when constructors are inherited

	def checkAfterBindImp is override
		base.checkAfterBindImp()
		# can't do the following in a _bindImp() override since type inference is implemented in
		# a subclass (_left may not have its _definition until after that executes)
		if .compiler.hasSuperStackTraceOption
			if _left inherits NameExpr
				if .compiler.curCodeMember.box.name <> 'CobraFrame'
					_trackLocal = _left.definition inherits AbstractLocalVar
					if _trackLocal
						_trackName  = _left.definition.name

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _trackLocal
			sw.write('CobraImp.SetLocal("[_trackName]", ')
		else if parens
			sw.write('(')
		_writeSharpDef(sw)
		if _trackLocal or parens
			sw.write(')')


class AssignExpr
	inherits AbstractAssignExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		left = _left
		right = _right
		try
			base._bindImp()
		catch NodeMultiException
			# for a type inference situation, create a var of type passthrough for the left hand side
			# to prevent superfluous errors in subsequent statements
			if left inherits IdentifierExpr
				if left.definition is nil
					definition = LocalVar(left.token, .compiler.passThroughType).bindAll() to LocalVar  # CC: axe cast when supporting 'this'
					.compiler.codeMemberStack.peek().addLocal(definition)
					left.setDefinition(definition)
					left.type = definition.type
			if _type is nil
				_type = .compiler.passThroughType
			throw
		assert right.type
		if left inherits IdentifierExpr
			if left.definition is nil
				# type inference
				assert right.type
				if right.type is .compiler.passThroughType  # TODO: ? change to unspecifiedType
					if right.hasError
						# for a type inference situation, create a var of type passthrough for the left hand side
						# to prevent superfluous errors in subsequent statements
						definition = LocalVar(left.token, .compiler.passThroughType).bindAll() to LocalVar  # CC: axe cast when supporting 'this'
						.compiler.codeMemberStack.peek().addLocal(definition)
						left.setDefinition(definition)
						left.type = definition.type
						_type = left.type
						return
					else
						.throwError('Cannot infer type for "[left.name]" because the type of the right hand expression is unknown.')
				if left.name.startsWith('_')
					.throwError('No class variable named "[left.name]" exists and local variable declarations cannot start with an underscore (_).')
				definition = LocalVar(left.token, right.type).bindAll() to LocalVar  # CC: axe cast when supporting 'this'
				.compiler.codeMemberStack.peek().addLocal(definition)
				left.setDefinition(definition)
				left.type = definition.type
			if left.definition is nil
				left.errorUnknownId(left.name)
		if not right.canBeAssignedTo(left.type to IType)
			.throwError('Incompatible types. Cannot assign value of type [right.type.name] on the right to [left.type.name] on the left.')
		_type = left.type
		right.contextType = _type

	def checkAfterBindImp is override
		base.checkAfterBindImp()
		if _left inherits IdentifierExpr
			assert _left.definition
			if _left.definition inherits Param
				if _right inherits IdentifierExpr
					if _right.definition inherits ClassVar
						# TODO: this warning should not apply if this AssignExpr is in an if statement whose cond references the _left.definition
						# example: if foo is nil; foo = _foo # where foo is an argument
						# note: this will need a test case that generates no warnings. and the cobra test cases should probably barf on unexpected warnings
						.compiler.warning(this, 'Setting a parameter to a class variable is often a mistake. You may want to reverse the assignment.')

	def _writeSharpDef(sw as SharpWriter) is override
		# TODO:
		# if trackLocal:
		#	out.write('CobraImp.SetLocal("%s", ' % self.left.name)
		if _left inherits IndexExpr
			if _left.target.type.isDynamic
				# assigning to an indexer of a dynamically typed target requires special code gen
				sw.write('CobraImp.SetIndexerValue(')
				_left.target.writeSharpDef(sw, false)
				sw.write(', ')
				_right.writeSharpDef(sw, false)
				for expr in _left.args
					sw.write(', ')
					expr.writeSharpDef(sw, false)
				sw.write(')')
				return
		handled = false
		if _left inherits IdentifierExpr
			sharpNames = _left.sharpAssignmentNames
			if sharpNames
				sw.write(_left.name)
				for i = 0 .. sharpNames.count
					sw.write('=')
					sw.write(sharpNames[i])
				handled = true
		if not handled
			# `obj.foo = bar` where `obj` is dynamic, requires special handling
			if _left inherits DotExpr
				if _left.left.type.isDynamic
					assert _left.right inherits MemberExpr
					sw.write('CobraImp.SetPropertyValue(')
					_left.left.writeSharpDef(sw, false)
					sw.write(', ')
					sw.write(Utils.csStringLitFor(Utils.capped((_left.right to MemberExpr).name)))
					sw.write(', ')
					_right.writeSharpDef(sw)
					sw.write(')')
					return
		if not handled
			# for something like "p.total = 0", cannot generate "(p.Total)=0" because then C# sees
			# the left hand side as an r-value instead an l-value/target. hence the false below.
			_left.writeSharpDef(sw, false)
		sw.write('=')
		_right.writeSharpDefInContext(sw)


class NumericPromoExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if _left.type.isDynamic or _right.type.isDynamic
			_type = .compiler.dynamicType
			return
		tint = .compiler.intType
		tdecimal = .compiler.decimalType
		tfloat = .compiler.floatType
		tpassthrough = .compiler.passThroughType
		tstring = .compiler.libraryType('System', 'String')
		cannotMix = false
		leftType = _left.type
		if leftType inherits NilableType
			$sharp('leftType = ((NilableType)leftType).TheWrappedType;')
		rightType = _right.type
		if rightType inherits NilableType
			$sharp('rightType = ((NilableType)rightType).TheWrappedType;')
		if leftType.isDescendantOf(tint)
			if rightType.isDescendantOf(tint)
				# special case: true division
				# if both sides are ints, the type becomes decimal
				if _op=='SLASH'
					_type = tdecimal
				else
					_type = tint
			else if rightType.isDescendantOf(tdecimal)
				_type = tdecimal
			else if rightType.isDescendantOf(tfloat)
				_type = tfloat
		else if leftType.isDescendantOf(tdecimal)
			if rightType.isDescendantOf(tdecimal)
				_type = tdecimal
			else if rightType.isDescendantOf(tint)
				_type = tdecimal
			else if rightType.isDescendantOf(tfloat)
				cannotMix = true
			else
				cannotMix = true
		else if leftType.isDescendantOf(tfloat)
			if rightType.isDescendantOf(tfloat)
				_type = tfloat
			else if rightType.isDescendantOf(tint)
				_type = tfloat
			else if rightType.isDescendantOf(tdecimal)
				cannotMix = true
			else
				cannotMix = true
		else if leftType.isDescendantOf(tstring)
			if rightType.isDescendantOf(tstring)
				_type = tstring
			else
				cannotMix = true
		if _left.isKindOf(tpassthrough) and not _right.isKindOf(tpassthrough)
			_type = rightType
		else if _right.isKindOf(tpassthrough) and not _left.isKindOf(tpassthrough)
			_type = leftType
		else if _left.isKindOf(tpassthrough) or _right.isKindOf(tpassthrough)
			_type = tpassthrough
		else if cannotMix
			.throwError('Cannot mix types [_left.type.name] and [_right.type.name] for arithmetic.')
		assert _type


class AugAssignMathExpr
	inherits NumericPromoExpr
	"""
	How should:
		someInt /= someInt
	be handled given that
		someInt / someInt
	gives a decimal?
	"""

	# TODO: does not inherit AbstractAssignExpr. Does not participate in super stack trace

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['PLUS_EQUALS', 'MINUS_EQUALS', 'STAR_EQUALS', 'STARSTAR_EQUALS', 'SLASH_EQUALS', 'SLASHSLASH_EQUALS', 'PERCENT_EQUALS']

	def _bindImp is override
		base._bindImp()
		# TODO: does NumericPromoExpr cover everything we need?

	def _writeSharpDef(sw as SharpWriter) is override
		if _left.type.isDynamic
			_left.writeSharpDef(sw)
			sw.write(' = ')
			specs = OperatorSpecs.binaryOpSpecsByCobraText
			assert specs.containsKey(.token.text)
			spec = specs[.token.text]
			opText = Utils.csStringLitFor(spec.opMethodName)
			sw.write('CobraImp.DynamicOp([opText], ')
			_left.writeSharpDef(sw)  # TODO: add , false
			sw.write(', ')
			_right.writeSharpDef(sw)  # TODO: add , false
			sw.write(')')
			return
		op = ''
		sep = ','  # for the method call case
		branch _op
			on 'PLUS_EQUALS'
				op = '+='
			on 'MINUS_EQUALS'
				op = '-='
			on 'STAR_EQUALS'
				op = '*='
			on 'STARSTAR_EQUALS'
				op = 'CobraImp.PowerToEquals('
			on 'SLASH_EQUALS'
				op = '/='  # TODO: finish this
			on 'SLASHSLASH_EQUALS'
				op = '/='  # TODO: finish this
			on 'PERCENT_EQUALS'
				op = '%='
			else
				throw FallThroughException(_op)
		assert op
		if op.length==2
			_left.writeSharpDef(sw)
			sw.write(op)
			_right.writeSharpDef(sw)
		else
			sw.write(op)  # ex: 'CobraImp.Foo('
			_left.writeSharpDef(sw)
			sw.write(sep)
			_right.writeSharpDef(sw)
			sw.write(')')


class BinaryBoolExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['AND', 'OR', 'IMPLIES']

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType
		if _left.type is not .compiler.boolType
			_left = TruthExpr(_left).bindImp() to TruthExpr # CC: axe cast after "as this"
		if _right.type is not .compiler.boolType
			_right = TruthExpr(_right).bindImp() to TruthExpr # CC: axe cast after "as this"

	def _writeSharpDef(sw as SharpWriter) is override
		if _op=='IMPLIES'
			sw.write('!')
		_left.writeSharpDef(sw)
		branch _op
			on 'AND'
				sw.write('&&')
			on 'OR', 'IMPLIES'
				sw.write('||')
		_right.writeSharpDef(sw)

	def _writeSharpBreakdownItemsRight(sw as SharpWriter) is override
		# have to respect the short circuit otherwise something like "s and s.length" will give
		# NullReference exception for "s.length"
		# solution is: given L and R,
		# write:   "R", (!(L) ? "short-circuted" : (R).ToString())
		# that's for 'AND'. for, 'OR', remove the !, for 'IMPLIES' it's like AND

		# so rather than:
		# _right.writeSharpBreakdownItems(sw)
		# do this:
		src = Utils.csStringLitFor(_right.toCobraSource)
		sharpNot = if(_op=='OR', '', '!')
		sw.write(', [src], new CobraDirectString([sharpNot]')
		_left.writeSharpDefForBreakdown(sw)
		sw.write(' ? "(short-circuited)" : CobraCore.ToTechString(')
		_right.writeSharpDefForBreakdown(sw)
		sw.write('))')


class BinaryMathExpr
	inherits NumericPromoExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['PLUS', 'MINUS', 'STAR', 'SLASH', 'SLASHSLASH', 'PERCENT']

	def _bindImp # TODO: this is all messed up. does this get called? TODO: this is missing, so its not being run. resolve with base class: is override
		base._bindImp()
		lt = _left.type
		if lt inherits NilableType
			$sharp('lt = ((NilableType)lt).TheWrappedType;')
		rt = _right.type
		if rt inherits NilableType
			$sharp('rt = ((NilableType)rt).TheWrappedType;')
		if lt is rt
			assert _type == lt or (_type is .compiler.decimalType and _op=='SLASH')
		else if lt.isDynamic or rt.isDynamic
			_type = .compiler.dynamicType
		else
			# TODO: this will need to be more sophisticated in the future with different sized ints and floats
			if lt.isDescendantOf(.compiler.intType)
				_type = rt
			else if rt.isDescendantOf(.compiler.intType)
				_type = lt
			else if lt.isDescendantOf(.compiler.decimalType)
				if rt.isDescendantOf(.compiler.floatType)
					.throwError('Cannot promote between decimal and float for operator "[_op]". Decimal is more accurate and float has more range.')
				else
					# int case already taken care of, so...
					.throwError('Cannot promote between decimal and "[rt.name]".')
			else if lt.isDescendantOf(.compiler.floatType)
				if rt.isDescendantOf(.compiler.decimalType)
					.throwError('Cannot promote between float and decimal for operator "[_op]". Decimal is more accurate and float has more range.')
				else
					# int case already taken care of, so...
					.throwError('Cannot promote between decimal and "[rt.name]".')
			else
				throw FallThroughException({'this': this, '_left': _left, 'op': _op, 'lt': lt, 'rt': rt})

	def _writeSharpDef(sw as SharpWriter) is override
		if _type.isDynamic
			specs = OperatorSpecs.binaryOpSpecsByCobraText
			assert specs.containsKey(.token.text)
			spec = specs[.token.text]
			opText = Utils.csStringLitFor(spec.opMethodName)
			sw.write('CobraImp.DynamicOp([opText], ')
			_left.writeSharpDef(sw)
			sw.write(', ')
			_right.writeSharpDef(sw)
			sw.write(')')
			return
		intType = .compiler.intType
		left = _left
		right = _right
		op = ''
		pre = ''
		sep = ','  # for the method call case
		branch _op
			on 'PLUS'
				op = '+'
			on 'MINUS'
				op = '-'
			on 'STAR'
				op = '*'
			on 'STARSTAR'
				op = 'CobraImp.PowerTo('
			on 'SLASH'
				op = '/'
				if _left.isKindOf(intType) and _right.isKindOf(intType)
					pre = '(decimal)'
			on 'SLASHSLASH'
				if left.isKindOf(.compiler.intType) and right.isKindOf(.compiler.intType)
					op = '/'
				else if left.isKindOf(.compiler.decimalType) or right.isKindOf(.compiler.decimalType)
					op = 'Decimal.Floor('
					sep = '/'
				else if left.isKindOf(.compiler.floatType) or right.isKindOf(.compiler.floatType)
					op = 'Math.Floor('
					sep = '/'
				else
					throw FallThroughException([left.type, right.type])
			on 'PERCENT'
				op = '%'
			else
				throw FallThroughException(_op)
		assert op
		sw.write(pre)
		if op.length==1
			_left.writeSharpDef(sw)
			sw.write(op)
			_right.writeSharpDef(sw)
		else
			sw.write(op)  # ex: 'CobraImp.Foo('
			_left.writeSharpDef(sw)
			sw.write(sep)
			_right.writeSharpDef(sw)
			sw.write(')')


class CompareExpr
	inherits BinaryOpExpr

	# TODO: handle the real equals and does not equal

	var _cobraToSharp = {
		'EQ': '==',
		'NE': '!=',
		'GT': '>',
		'LT': '<',
		'GE': '>=',
		'LE': '<=',
		'IS': '==',
		'ISNOT': '!=',
	}

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		if op == 'ISNOT' and .token.text == 'is'
			.token.text = 'is not'
			
	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType
		# cannot invoke `isAssignableTo` directory on the types because if one is nilable and the other is not, you can get false, even though that doesn't apply for "is". So:
		leftType = _left.type
		rightType = _right.type
		assert leftType
		assert rightType
		if not leftType.isComparableTo(rightType to IType)  # CC: to !
			if .op == 'IS'
				innerMsg = 'can never be identical'
			else
				innerMsg = 'cannot be compared'
			typeNames = if(_left.type.name==_right.type.name, 'type ("[_left.type.name]")', 'types ("[_left.type.name]" and "[_right.type.name]")')
			msg = 'The left and right sides of the "[.token.text]" expression [innerMsg] because of their [typeNames].'
			if .op == 'IS' and _right.type.isDescendantOf(.compiler.libraryType('System', 'Type'))
				msg += ' Maybe you should try "inherits" instead of "is".'
			.throwError(msg)

	def _writeSharpDef(sw as SharpWriter) is override
		left = _left
		right = _right
		op = _op
		# Compute the C# operation which will be an operator or method call
		if op=='EQ' or op=='NE'
			if not left.type.isReference and not right.type.isReference
				op = _cobraToSharp[_op]
			else
				stringType = .compiler.libraryType('System', 'String')
				if left.isKindOf(stringType) and right.isKindOf(stringType)
					op = _cobraToSharp[_op]
				else
					op = if(op=='EQ', 'CobraImp.Equals(', 'CobraImp.NotEquals(')
		else if op=='IS' or op=='ISNOT'
			if left.type inherits PrimitiveType and right.type inherits PrimitiveType
				op = _cobraToSharp[_op]
			else
				op = if(op=='IS', 'CobraImp.Is(', 'CobraImp.IsNot(')
		else
			if left.type.isDynamic or right.type.isDynamic
				sw.write('CobraImp.DynamicCompare(')
				left.writeSharpDef(sw, false)
				sw.write(', ')
				right.writeSharpDef(sw, false)
				sw.write(')[_cobraToSharp[_op]]0')
				return
			else
				done = false
				if left.type inherits Box
					leftBox = left.type to Box
					compareTo = leftBox.memberForName('compareTo')
					if compareTo.isMethod and compareTo.resultType is .compiler.intType
						op = '.CompareTo('
						done = true
				if not done
					op = _cobraToSharp[_op]
		# Write the C# code
		if op.length<=2
			left.writeSharpDef(sw)
			sw.write(op)
			right.writeSharpDef(sw)
		else if op == '.CompareTo('
			left.writeSharpDef(sw)
			sw.write(op)
			right.writeSharpDef(sw, false)
			sw.write(') [_cobraToSharp[_op]] 0')
		else if op.endsWith('(')
			sw.write(op)
			left.writeSharpDef(sw)
			sw.write(',')
			right.writeSharpDef(sw)
			sw.write(')')
		else
			throw FallThroughException(op)


class DotExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _type
			assert _right.type
			_type = _right.type
		if _left.type.isDynamic
			_type = .compiler.dynamicType
		# convert generic params to specific types when applicable.
		# Example: s.peek() --> String for a Stack<of String> (not Stack<of T>)
		# Example: t.getRange(n,m) --> List<of Color> for a List<of Color> (not List<of T>)
		if _type inherits GenericParam
			if _left.type inherits Box
				t = (_left.type to Box).typeForGenericParam(_type to GenericParam)  # CC: should not need cast to GenericParam
				$sharp('_type = t;')
		else if _type.isGeneric
			box = _type to Box
			if box.containsGenericParameters
				if _left.type inherits Box
					specificType = _left.type to Box
					t = _type.constructedTypeFor(specificType.params)
					$sharp('_type = t;')
		# use of base implies override if the containing member is not already marked new
		if _left inherits BaseLit
			.compiler.curCodeMember.usesBase

	get namedType as IType? is override
		# overridden to return the type this dotted expr represents in those cases when it does represent a type
		assert .didBindImp
		if _definition inherits IType
			return _definition to IType  # CC: shouldn't need this cast
		else
			return nil

	def toCobraSource as String is override
		if _left inherits ThisLit
			return '.[_right.toCobraSource]'
		else
			return '[_left.toCobraSource].[_right.toCobraSource]'

	def _writeSharpDef(sw as SharpWriter) is override
		if _left.receiverType.isDynamic
			# handle dynamic typing
			if _right inherits MemberExpr
				sw.write('CobraImp.GetPropertyValue(')
				_left.writeSharpDef(sw, not _left inherits DotExpr)
				sw.write(', ')
				sw.write(Utils.csStringLitFor(Utils.capped(_right.name)))
				sw.write(')')
			else if _right inherits CallExpr
				# TODO: CallExpr
				sw.write('CobraImp.InvokeMethod(')
				_left.writeSharpDef(sw, not _left inherits DotExpr)
				sw.write(', ')
				sw.write(Utils.csStringLitFor(Utils.capped(_right.name)))
				for arg in _right.args
					sw.write(', ')
					arg.writeSharpDef(sw, false)
				sw.write(')')
			else
				throw FallThroughException(_right)
		else
			# handle static typing
			# don't write 'this' for shared members
			writeThis = true
			if _left inherits ThisLit
				if _right inherits CallExpr
					defi = _right.definition
					if defi inherits IMember
						writeThis = not defi.isShared
					else
						# TODO: compiler bug stimulated by following line:
						# throw FallThroughException({'right': _right, 'defi': defi})
						throw FallThroughException(defi)
				else if _right inherits MemberExpr
					writeThis = not _right.definition.isShared
			if writeThis
				_left.writeSharpDef(sw, not _left inherits DotExpr)
				sw.write('.')
			_right.writeSharpDef(sw, false)

	def _writeSharpBreakdownItemsLeft(sw as SharpWriter) is override
		if not _left.type inherits TypeType  # feels like a cheap escape...
			_left.writeSharpBreakdownItems(sw)


class InExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['IN', 'NOTIN']

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		branch _op
			on 'NOTIN': sw.write('!')
			on 'IN': pass
			else: throw FallThroughException(_op)
		sw.write('CobraImp.In(')
		_left.writeSharpDef(sw, false)
		sw.write(',')
		_right.writeSharpDef(sw, false)
		sw.write(')')


class InheritsExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['INHERITS', 'IMPLEMENTS']
		
	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType

	def _writeSharpDef(sw as SharpWriter) is override
		_left.writeSharpDef(sw, false)  # TODO: is false okay here?
		sw.write(' is ')
		_right.writeSharpDef(sw, false)


class AbstractToExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _right.isKindOf(.compiler.typeType) and not _right.type inherits Box
			assert _right.toCobraSource(), _right
			.throwError('The "to" operator does not apply to "[_right.toCobraSource()]". Use a type.')
		if _right inherits TypeExpr
			_type = _right.receiverType
		else if _right inherits IdentifierExpr
			_type = _right.definition to IType
		else if _right inherits DotExpr  # TODO: This happens for System.Collections.IEnumerable, for example. I don't know if I like that.
			_type = _right.receiverType
		assert _type


class ToExpr
	inherits AbstractToExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if _left inherits NilLiteral and not (_type inherits NilableType or _type inherits PassThroughType)
			.throwError('Cannot cast nil to a non-nil type.')

	def _writeSharpDef(sw as SharpWriter) is override
		if _right inherits TypeExpr
			if _right.containedType is .compiler.passThroughType
				_left.writeSharpDef(sw)
				return
		sw.write('(')
		_right.writeSharpDef(sw, false)  # double parens would be pointless and also causes a C# error
		sw.write(')')
		_left.writeSharpDef(sw)


class ToQExpr
	inherits AbstractToExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _type inherits NilableType
			_type = NilableType(_type).bindAll() to NilableType  # CC: axe cast when 'as this' is supported

	def _writeSharpDef(sw as SharpWriter) is override
		# x to? int     --> ((x is int || x is int?) ? (int?)x : (int?)null)
		# x to? int?    --> ((x is int || x is int?) ? (int?)x : (int?)null)
		# ^ but this would cause multiple evaluation of x, so...
		# x to? int?	--> (int?)CobraImp.ToOrNil(x)

		# x to? string  --> (x as String)
		# x to? string? --> (x as String)
		right = .right
		if right inherits TypeExpr
			t = right.containedType to IType
		else if right inherits IdentifierExpr
			t = right.definition to IType
		# TODO?: t = t.namedType
		assert t inherits IType
		if t inherits NilableType
			# t = t.theWrappedType to IType  # TODO: revisit if theWrappedType should return nil or not
			$sharp('t = ((NilableType)t).TheWrappedType;')
		typeSharpRef = t.sharpRef
		if t.isReference
			sw.write('(')
			.left.writeSharpDef(sw)
			sw.write(') as [typeSharpRef]')
		else
			sw.write('[typeSharpRef]?)CobraImp.ToOrNil<[typeSharpRef]>(')
			.left.writeSharpDef(sw)


class CoalesceExpr
	inherits BinaryOpExpr
	"""
	x ? y ==> if(x is nil, y, x)
	but without the potential double evaluation of x, which could be a complex expression.
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		ptt = .compiler.passThroughType
		if _left.type is ptt or _right.type is ptt
			# x ? y   ...where either is typed as passthrough
			_type = ptt
		else if _left.type inherits NilableType and not _right.type inherits NilableType
			# x ? y   ...where x can be nil, but y cannot
			_type = (_left.type to NilableType).theWrappedType  # TODO: should be greatest common denominator between the two
		else
			# the catch all case
			_type = _left.type  # TODO: should be greatest common denominator between the two

	def _writeSharpDef(sw as SharpWriter) is override
		_left.writeSharpDef(sw)
		sw.write(' ?? ')
		_right.writeSharpDef(sw)


class InverseCoalesceExpr
	inherits BinaryOpExpr
	"""
	x ! y ==> if(x is not nil, y, x)
	but without the potential double evaluation of x, which could be a complex expression.
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		ptt = .compiler.passThroughType
		if _left.type is ptt or _right.type is ptt
			# x ! y   ...where either is typed as passthrough
			_type = ptt
# TODO?
#		else if _right.type inherits NilableType and not _right.type inherits NilableType
#			# x ? y   ...where x can be nil, but y cannot
#			_type = _left.type.theWrappedType  # TODO: should be greatest common denominator between the two
		else
			# the catch all case
			_type = _left.type  # TODO: should be greatest common denominator between the two

	def _writeSharpDef(sw as SharpWriter) is override
		_left.writeSharpDef(sw)
		sw.write('==null ? null : ')
		if not _right.type inherits NilableType and not _right.type inherits NilType
			sw.write('([_right.type.sharpRef]?)')
		_right.writeSharpDef(sw)


class CoalesceAssignExpr
	inherits BinaryOpExpr
	"""
	x ?= y
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		# TODO: error check that the left hand type is nilable?
		# TODO: error check that the right hand type is not nilable?
		_type = _right.type

	def _writeSharpDef(sw as SharpWriter) is override
		# L = L * R
		_left.writeSharpDef(sw)
		sw.write(' = ')
		_left.writeSharpDef(sw)
		sw.write(' ?? ')
		_right.writeSharpDef(sw)


class InverseCoalesceAssignExpr
	inherits BinaryOpExpr
	"""
	x != y
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		# TODO: any error checks here?
		_type = _left.type

	def _writeSharpDef(sw as SharpWriter) is override
		_left.writeSharpDef(sw)
		sw.write(' = ')
		_left.writeSharpDef(sw)
		sw.write('==null ? null : ')
		if not _right.type inherits NilableType and not _right.type inherits NilType
			sw.write('([_right.type.sharpRef]?)')
		_right.writeSharpDef(sw)
