class BinaryOpExpr
	inherits Expr

	shared
		def make(opToken as IToken, op as String, left as Expr, right as Expr) as BinaryOpExpr
			"""
			Instantiates the correct class for the given operator and returns it.
			"""
			branch op
				on 'TO'
					return ToExpr(opToken, op, left, right)
				on 'TOQ'
					return ToQExpr(opToken, op, left, right)
				on 'QUESTION'
					return CoalesceExpr(opToken, op, left, right)
				on 'QUESTION_EQUALS'
					return CoalesceAssignExpr(opToken, op, left, right)
				on 'BANG'
					return InverseCoalesceExpr(opToken, op, left, right)
				on 'BANG_EQUALS'
					return InverseCoalesceAssignExpr(opToken, op, left, right)
				on 'ASSIGN'
					return AssignExpr(opToken, op, left, right)
				on 'DOT'
					return DotExpr(opToken, op, left, right)
				on 'IMPLIES'
					return ImpliesExpr(opToken, op, left, right)
				on 'INHERITS'
					return InheritsExpr(opToken, op, left, right)
				on 'IN', 'NOTIN'
					return InExpr(opToken, op, left, right)
				on 'IS', 'ISNOT', 'EQ', 'NE', 'LT', 'GT', 'LE', 'GE'
					return CompareExpr(opToken, op, left, right)
				on 'AND', 'OR'
					return BinaryBoolExpr(opToken, op, left, right)
				on 'PLUS', 'MINUS', 'STAR', 'SLASH', 'SLASHSLASH', 'PERCENT'
					return BinaryMathExpr(opToken, op, left, right)
				on 'PLUS_EQUALS', 'MINUS_EQUALS', 'STAR_EQUALS', 'SLASH_EQUALS', 'SLASHSLASH_EQUALS', 'PERCENT_EQUALS'
					return AugAssignMathExpr(opToken, op, left, right)
				else
					return BinaryOpExpr(opToken, op, left, right)
			# CC: axe the if true pass below which is there to shore up a parsing bug for branch. or maybe it's the multiline else above because it was single line originally and I had to change it
			if true
				pass

	var _op as String
	var _left as Expr
	var _right as Expr
	var _definition as IMember?

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken)
		_op = op
		_left = left
		_left.superNode = this
		_right = right
		_right.superNode = this

	get op from var

	get left from var

	get right from var

	pro definition from var

	def setReceiverType(t as IType?)
		# this method is for MemberExpr
		# TODO: this will probably go away when a DotExpr subclass is made
		_receiverType = t

	def bindImp as INode is override
		base.bindImp()
		assert .didBindImp
		# TODO: maybe check() should only be invoked if left and right were bound without error
		.check()  # TODO: rename this to checkFoo()
		.checkForVoids()
		return this

	def _bindImp is override
		base._bindImp()
		assert _left is not this, this
		assert _right is not this, this
		_left.bindImp()
		_right.bindImp()
		assert _left.didBindImp
		assert _right.didBindImp

	def check
		"""
		Invoked after bindImp() in order to do more error checking.
		So this is a hook for subclasses to do error checking after
		left and right have been successfully bound.
		"""
		pass

	def checkForVoids
		left = _left
		right = _right
		voidType = .compiler.voidType
		# check for void on either side of the expression
		sugg = 'Use a different method or change that method to return something.'
		if left.type is voidType
			if left inherits BinaryOpExpr and (left to BinaryOpExpr).op=='DOT' and (left to BinaryOpExpr).right inherits CallExpr  # CC: axe casts
				append = ' because "[((left to BinaryOpExpr).right to CallExpr).name]" does not return anything.'  # CC: axe BinaryOp cast
			else
				append = '.'
			_error('There is no type for the left hand side of "[.token.text]"[append] [sugg]')
		if right.type is voidType and not right inherits CallExpr
			if right inherits BinaryOpExpr and (right to BinaryOpExpr).op=='DOT' and (right to BinaryOpExpr).right inherits CallExpr  # CC: axe cast
				append = ' because "[((right to BinaryOpExpr).right to CallExpr).name]" does not return anything.'  # CC: axe BinaryOp cast
			else
				append = '.'
			_error('There is no type for the right hand side of "[.token.text]"[append] [sugg]')

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	def addSubFields is override
		base.addSubFields()
		.addField('op', _op)
		.addField('left', _left)
		.addField('right', _right)


class AssignExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		left = _left
		right = _right
		assert right.type
		if left inherits IdentifierExpr
			if left.definition is nil
				# type inference
				assert right.type
				if right.type is .compiler.passThroughType  # TODO: ? change to unspecifiedType
					_error('Cannot infer type for "[left.text]" because the type of the right hand expression is unknown.')
				if left.text.startsWith('_')
					_error('No class variable named "[left.text]" exists and local variable declarations cannot start with an underscore (_).')
				definition = LocalVar(left.token, right.type).bindAll() to LocalVar  # CC: axe cast when supporting 'this'
				.compiler.codeMemberStack.peek().addLocal(definition)
				left.definition = definition
				left.type = definition.type
			if left.definition is nil
				left.errorUnknownId(left.text)
		if not right.canBeAssignedTo(left.type to IType)
			_error('Incompatible types. Cannot assign value of type [right.type.name] on the right to [left.type.name] on the left.')
		_type = left.type

	def check is override
		base.check()
		if _left inherits IdentifierExpr
			assert _left.definition
			if _left.definition inherits Param
				if _right inherits IdentifierExpr
					if _right.definition inherits ClassVar
						.compiler.warning(this, 'Setting a parameter to a class variable is often a mistake. You may want to reverse the assignment.')

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		_left.writeSharpDef(sw)
		sw.write('=')
		_right.writeSharpDef(sw)
		if parens
			sw.write(')')


class NumericPromoExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		tint = .compiler.intType
		tdecimal = .compiler.decimalType
		tfloat = .compiler.floatType
		tpassthrough = .compiler.floatType
		tstring = .compiler.libraryType('System', 'String')
		cannotMix = false
		if _left.isKindOf(tint)
			if _right.isKindOf(tint)
				# special case: true division
				# if both sides are ints, the type becomes decimal
				if _op=='SLASH'
					_type = tdecimal
				else
					_type = tint
			else if _right.isKindOf(tdecimal)
				_type = tdecimal
			else if _right.isKindOf(tfloat)
				_type = tfloat
		else if _left.isKindOf(tdecimal)
			if _right.isKindOf(tdecimal)
				_type = tdecimal
			else if _right.isKindOf(tint)
				_type = tdecimal
			else if _right.isKindOf(tfloat)
				cannotMix = true
			else
				cannotMix = true
		else if _left.isKindOf(tfloat)
			if _right.isKindOf(tfloat)
				_type = tfloat
			else if _right.isKindOf(tint)
				_type = tfloat
			else if _right.isKindOf(tdecimal)
				cannotMix = true
			else
				cannotMix = true
		else if _left.isKindOf(tstring)
			if _right.isKindOf(tstring)
				_type = tstring
			else
				cannotMix = true
		if cannotMix
			if _left.isKindOf(tpassthrough) or _right.isKindOf(tpassthrough)
				_type = tpassthrough
			else
				_error('Cannot mix types [_left.type.name] and [_right.type.name] for arithmetic.')
		assert _type


class AugAssignMathExpr
	inherits NumericPromoExpr
	"""
	How should:
		someInt /= someInt
	be handled given that
		someInt / someInt
	gives a decimal?
	"""

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()


class BinaryBoolExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType


class BinaryMathExpr
	inherits NumericPromoExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)
		assert op in ['PLUS', 'MINUS', 'STAR', 'SLASH', 'SLASHSLASH', 'PERCENT']


class CompareExpr
	inherits BinaryOpExpr

	# TODO: handle the real equals and does not equal

	var _cobraToSharp = {
		'EQ': '==',
		'NE': '!=',
		'GT': '>',
		'LT': '<',
		'GE': '>=',
		'LE': '<=',
	}

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		_left.writeSharpDef(sw)
		sw.write(_cobraToSharp[_op])
		_right.writeSharpDef(sw)
		if parens
			sw.write(')')

class DotExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _type
			assert _right.type
			_type = _right.type

	get namedType as IType? is override
		# overridden to return the type this dotted expr represents in those cases when it does represent a type
		assert .didBindImp
		if _definition inherits IType
			return _definition to IType  # CC: shouldn't need this cast
		else
			return nil

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		_left.writeSharpDef(sw, false)  # TODO: is false okay here?
		sw.write('.')
		_right.writeSharpDef(sw, false)


class InExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType


class InheritsExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType


class ImpliesExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType


class AbstractToExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _right.isKindOf(.compiler.typeType) and not _right.type inherits Box
			assert _right.toCobraSource(), _right
			_error('The "to" operator does not apply to "[_right.toCobraSource()]". Use a type.')
		if _right inherits TypeExpr
			_type = _right.receiverType
		else if _right inherits IdentifierExpr
			_type = _right.definition to IType
		else
			assert false, _right
		assert _type


class ToExpr
	inherits AbstractToExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if _left inherits NilLiteral and not (_type inherits NilableType or _type inherits PassThroughType)
			_error('Cannot cast nil to a non-nil type.')


class ToQExpr
	inherits AbstractToExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _type inherits NilableType
			_type = NilableType(_type).bindAll() to NilableType  # CC: axe cast when 'as this' is supported


class CoalesceExpr
	inherits BinaryOpExpr
	"""
	x ? y ==> if(x is nil, y, x)
	but without the potential double evaluation of x, which could be a complex expression.
	"""

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		ptt = .compiler.passThroughType
		if _left.type is ptt or _right.type is ptt
			# x ? y   ...where either is typed as passthrough
			_type = ptt
		else if _left.type inherits NilableType and not _right.type inherits NilableType
			# x ? y   ...where x can be nil, but y cannot
			_type = (_left.type to NilableType).theWrappedType  # TODO: should be greatest common denominator between the two
		else
			# the catch all case
			_type = _left.type  # TODO: should be greatest common denominator between the two


class InverseCoalesceExpr
	inherits BinaryOpExpr
	"""
	x ! y ==> if(x is not nil, y, x)
	but without the potential double evaluation of x, which could be a complex expression.
	"""

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		ptt = .compiler.passThroughType
		if _left.type is ptt or _right.type is ptt
			# x ! y   ...where either is typed as passthrough
			_type = ptt
#		else if _right.type inherits NilableType and not _right.type inherits NilableType
#			# x ? y   ...where x can be nil, but y cannot
#			_type = _left.type.theWrappedType  # TODO: should be greatest common denominator between the two
		else
			# the catch all case
			_type = _left.type  # TODO: should be greatest common denominator between the two


class CoalesceAssignExpr
	inherits BinaryOpExpr
	"""
	x ?= y
	"""

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		# TODO: error check that the left hand type is nilable?
		# TODO: error check that the right hand type is not nilable?
		_type = _right.type


class InverseCoalesceAssignExpr
	inherits BinaryOpExpr
	"""
	x != y
	"""

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		# TODO: any error checks here?
		_type = _left.type
