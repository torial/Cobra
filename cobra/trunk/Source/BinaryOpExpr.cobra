class BinaryOpExpr
	inherits Expr

	shared
		def make(opToken as IToken, op as String, left as Expr, right as Expr) as BinaryOpExpr
			"""
			Instantiates the correct class for the given operator and returns it.
			"""
			branch opToken.which
				on 'TO'
					return ToExpr(opToken, op, left, right)
				else
					return BinaryOpExpr(opToken, op, left, right)
			# CC: axe the if true pass below which is there to shore up a parsing bug for branch. or maybe it's the multiline else above because it was single line originally and I had to change it
			if true
				pass

	var _op as String
	var _left as Expr
	var _right as Expr
	var _definition as IMember?

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken)
		_op = op
		_left = left
		_left.superNode = this
		_right = right
		_right.superNode = this

	get op from var

	get left from var

	get right from var

	pro definition from var

	def _bindImp is override
		base._bindImp()
		_left.bindImp()
		_right.bindImp()

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	def addSubFields is override
		base.addSubFields()
		.addField('op', _op)
		.addField('left', _left)
		.addField('right', _right)


class ToExpr
	inherits BinaryOpExpr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _right.isKindOf(.compiler.typeType)
			_error('Cannot apply the "to" operator to "[_right]". Use a type.')
		if _right inherits TypeExpr
			_type = _right.receiverType
		else if _right inherits IdentifierExpr
			_type = _right.type
		else
			assert false, _right
