class BinaryOpExpr
	inherits Expr

	shared
		def make(opToken as IToken, op as String, left as Expr, right as Expr) as BinaryOpExpr
			"""
			Instantiates the correct class for the given operator and returns it.
			"""
			branch op
				on 'TO'
					return ToExpr(opToken, op, left, right)
				on 'TOQ'
					return ToQExpr(opToken, op, left, right)
				on 'QUESTION'
					return CoalesceExpr(opToken, op, left, right)
				on 'QUESTION_EQUALS'
					return CoalesceAssignExpr(opToken, op, left, right)
				on 'BANG'
					return InverseCoalesceExpr(opToken, op, left, right)
				on 'BANG_EQUALS'
					return InverseCoalesceAssignExpr(opToken, op, left, right)
				on 'ASSIGN'
					return AssignExpr(opToken, op, left, right)
				on 'DOT'
					return DotExpr(opToken, op, left, right)
				on 'INHERITS'
					return InheritsExpr(opToken, op, left, right)
				on 'IN', 'NOTIN'
					return InExpr(opToken, op, left, right)
				on 'IS', 'ISNOT', 'EQ', 'NE', 'LT', 'GT', 'LE', 'GE'
					return CompareExpr(opToken, op, left, right)
				on 'AND', 'OR', 'IMPLIES'
					return BinaryBoolExpr(opToken, op, left, right)
				on 'PLUS', 'MINUS', 'STAR', 'STARSTAR', 'SLASH', 'SLASHSLASH', 'PERCENT'
					return BinaryMathExpr(opToken, op, left, right)
				on 'PLUS_EQUALS', 'MINUS_EQUALS', 'STAR_EQUALS', 'STARSTAR_EQUALS', 'SLASH_EQUALS', 'SLASHSLASH_EQUALS', 'PERCENT_EQUALS'
					return AugAssignMathExpr(opToken, op, left, right)
				else
					return BinaryOpExpr(opToken, op, left, right)
			# CC: axe the if true pass below which is there to shore up a parsing bug for branch. or maybe it's the multiline else above because it was single line originally and I had to change it
			if true
				pass

	var _op as String
	var _left as Expr
	var _right as Expr
	var _definition as IMember?

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken)
		_op = op
		_left = left
		_left.superNode = this
		_right = right
		_right.superNode = this

	get op from var

	get left from var

	get right from var

	pro definition from var

	def setReceiverType(t as IType?)
		# this method is for MemberExpr
		# TODO: this will probably go away when a DotExpr subclass is made
		_receiverType = t

	def bindImp as INode is override
		base.bindImp()
		assert .didBindImp
		# TODO: maybe check() should only be invoked if left and right were bound without error
		.check()  # TODO: rename this to checkFoo()
		.checkForVoids()
		return this

	def _bindImp is override
		base._bindImp()
		assert _left is not this, this
		assert _right is not this, this
		_left.bindImp()
		_right.bindImp()
		assert _left.didBindImp
		assert _right.didBindImp

	def check
		"""
		Invoked after bindImp() in order to do more error checking.
		So this is a hook for subclasses to do error checking after
		left and right have been successfully bound.
		"""
		pass

	def checkForVoids
		left = _left
		right = _right
		voidType = .compiler.voidType
		# check for void on either side of the expression
		sugg = 'Use a different method or change that method to return something.'
		if left.type is voidType
			if left inherits BinaryOpExpr and (left to BinaryOpExpr).op=='DOT' and (left to BinaryOpExpr).right inherits CallExpr  # CC: axe casts
				append = ' because "[((left to BinaryOpExpr).right to CallExpr).name]" does not return anything.'  # CC: axe BinaryOp cast
			else
				append = '.'
			_error('There is no type for the left hand side of "[.token.text]"[append] [sugg]')
		if right.type is voidType and not right inherits CallExpr
			if right inherits BinaryOpExpr and (right to BinaryOpExpr).op=='DOT' and (right to BinaryOpExpr).right inherits CallExpr  # CC: axe cast
				append = ' because "[((right to BinaryOpExpr).right to CallExpr).name]" does not return anything.'  # CC: axe BinaryOp cast
			else
				append = '.'
			_error('There is no type for the right hand side of "[.token.text]"[append] [sugg]')

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	def addSubFields is override
		base.addSubFields()
		.addField('op', _op)
		.addField('left', _left)
		.addField('right', _right)

	def toCobraSource as String is override
		return '[_left.toCobraSource()] [_op] [_right.toCobraSource()]'

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		_writeSharpDef(sw)
		if parens
			sw.write(')')

	def _writeSharpDef(sw as SharpWriter)
		pass

class AssignExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		left = _left
		right = _right
		assert right.type
		if left inherits IdentifierExpr
			if left.definition is nil
				# type inference
				assert right.type
				if right.type is .compiler.passThroughType  # TODO: ? change to unspecifiedType
					_error('Cannot infer type for "[left.text]" because the type of the right hand expression is unknown.')
				if left.text.startsWith('_')
					_error('No class variable named "[left.text]" exists and local variable declarations cannot start with an underscore (_).')
				definition = LocalVar(left.token, right.type).bindAll() to LocalVar  # CC: axe cast when supporting 'this'
				.compiler.codeMemberStack.peek().addLocal(definition)
				left.definition = definition
				left.type = definition.type
			if left.definition is nil
				left.errorUnknownId(left.text)
		if not right.canBeAssignedTo(left.type to IType)
			_error('Incompatible types. Cannot assign value of type [right.type.name] on the right to [left.type.name] on the left.')
		_type = left.type

	def check is override
		base.check()
		if _left inherits IdentifierExpr
			assert _left.definition
			if _left.definition inherits Param
				if _right inherits IdentifierExpr
					if _right.definition inherits ClassVar
						.compiler.warning(this, 'Setting a parameter to a class variable is often a mistake. You may want to reverse the assignment.')

	def _writeSharpDef(sw as SharpWriter) is override
		# TODO:
		# if trackLocal:
		#	out.write('CobraImp.SetLocal("%s", ' % self.left.name)
		handled = false
		if _left inherits IdentifierExpr
			sharpNames = _left.sharpAssignmentNames
			if sharpNames
				sw.write(_left.text)
				for i = 0 .. sharpNames.count
					sw.write('=')
					sw.write(sharpNames[i])
				handled = true
		if not handled
			# for something like "p.total = 0", cannot generate "(p.Total)=0" because then C# sees
			# the left hand side as an r-value instead an l-value/target. hence the false below.
			_left.writeSharpDef(sw, false)
		sw.write('=')
		_right.writeSharpDef(sw)


class NumericPromoExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		tint = .compiler.intType
		tdecimal = .compiler.decimalType
		tfloat = .compiler.floatType
		tpassthrough = .compiler.passThroughType
		tstring = .compiler.libraryType('System', 'String')
		cannotMix = false
		leftType = _left.type
		if leftType inherits NilableType
			$sharp('leftType = ((NilableType)leftType).TheWrappedType;')
		if leftType.isDescendantOf(tint)
			if _right.isKindOf(tint)
				# special case: true division
				# if both sides are ints, the type becomes decimal
				if _op=='SLASH'
					_type = tdecimal
				else
					_type = tint
			else if _right.isKindOf(tdecimal)
				_type = tdecimal
			else if _right.isKindOf(tfloat)
				_type = tfloat
		else if leftType.isDescendantOf(tdecimal)
			if _right.isKindOf(tdecimal)
				_type = tdecimal
			else if _right.isKindOf(tint)
				_type = tdecimal
			else if _right.isKindOf(tfloat)
				cannotMix = true
			else
				cannotMix = true
		else if leftType.isDescendantOf(tfloat)
			if _right.isKindOf(tfloat)
				_type = tfloat
			else if _right.isKindOf(tint)
				_type = tfloat
			else if _right.isKindOf(tdecimal)
				cannotMix = true
			else
				cannotMix = true
		else if leftType.isDescendantOf(tstring)
			if _right.isKindOf(tstring)
				_type = tstring
			else
				cannotMix = true
		if cannotMix
			if _left.isKindOf(tpassthrough) or _right.isKindOf(tpassthrough)
				_type = tpassthrough
			else
				_error('Cannot mix types [_left.type.name] and [_right.type.name] for arithmetic.')

		# enable for superstacktrace
		#left = _left
		#leftType = _left.type
		#right = _right
		#rightType = _right.type

		assert _type


class AugAssignMathExpr
	inherits NumericPromoExpr
	"""
	How should:
		someInt /= someInt
	be handled given that
		someInt / someInt
	gives a decimal?
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['PLUS_EQUALS', 'MINUS_EQUALS', 'STAR_EQUALS', 'STARSTAR_EQUALS', 'SLASH_EQUALS', 'SLASHSLASH_EQUALS', 'PERCENT_EQUALS']

	def _bindImp is override
		base._bindImp()
		# TODO: does NumericPromoExpr cover everything we need?

	def _writeSharpDef(sw as SharpWriter) is override
		left = _left
		right = _right
		op = ''
		sep = ','  # for the method call case
		branch _op
			on 'PLUS_EQUALS'
				op = '+='
			on 'MINUS_EQUALS'
				op = '-='
			on 'STAR_EQUALS'
				op = '*='
			on 'STARSTAR_EQUALS'
				op = 'CobraImp.PowerToEquals('
			on 'SLASH'
				op = '/='  # TODO: finish this
			on 'SLASHSLASH_EQUALS'
				op = '/='  # TODO: finish this
			on 'PERCENT_EQUALS'
				op = '%='
			else
				throw FallThroughException(_op)
		assert op
		if op.length==2
			_left.writeSharpDef(sw)
			sw.write(op)
			_right.writeSharpDef(sw)
		else
			sw.write(op)  # ex: 'CobraImp.Foo('
			_left.writeSharpDef(sw)
			sw.write(sep)
			_right.writeSharpDef(sw)
			sw.write(')')


class BinaryBoolExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['AND', 'OR', 'IMPLIES']

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType
		if _left.type is not .compiler.boolType
			_left = TruthExpr(_left).bindImp() to TruthExpr # CC: axe cast after "as this"
		if _right.type is not .compiler.boolType
			_right = TruthExpr(_right).bindImp() to TruthExpr # CC: axe cast after "as this"

	def _writeSharpDef(sw as SharpWriter) is override
		if _op=='IMPLIES'
			sw.write('!')
		_left.writeSharpDef(sw)
		branch _op
			on 'AND'
				sw.write('&&')
			on 'OR', 'IMPLIES'
				sw.write('||')
		_right.writeSharpDef(sw)


class BinaryMathExpr
	inherits NumericPromoExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['PLUS', 'MINUS', 'STAR', 'SLASH', 'SLASHSLASH', 'PERCENT']

	def _bindImp # TODO: this is missing, so its not being run. resolve with base class: is override
		base._bindImp()
		lt = _left.type
		rt = _right.type
		if lt is rt
			_type = lt
		else
			# TODO: this will need to be more sophisticated in the future with different sized ints and floats
			if lt.isDescendantOf(.compiler.intType)
				_type = rt
			else if rt.isDescendantOf(.compiler.intType)
				_type = lt
			else if lt.isDescendantOf(.compiler.decimalType)
				if rt.isDescendantOf(.compiler.floatType)
					_error('Cannot promote between decimal and float for operator "[_op]". Decimal is more accurate and float has more range.')
				else
					# int case already taken care of, so...
					_error('Cannot promote between decimal and "[rt.name]".')
			else if lt.isDescendantOf(.compiler.floatType)
				if rt.isDescendantOf(.compiler.decimalType)
					_error('Cannot promote between float and decimal for operator "[_op]". Decimal is more accurate and float has more range.')
				else
					# int case already taken care of, so...
					_error('Cannot promote between decimal and "[rt.name]".')
			else
				throw FallThroughException({'lt': lt, 'rt': rt})

	def _writeSharpDef(sw as SharpWriter) is override
		intType = .compiler.intType
		left = _left
		right = _right
		op = ''
		pre = ''
		sep = ','  # for the method call case
		branch _op
			on 'PLUS'
				op = '+'
			on 'MINUS'
				op = '-'
			on 'STAR'
				op = '*'
			on 'STARSTAR'
				op = 'CobraImp.PowerTo('
			on 'SLASH'
				op = '/'
				if _left.isKindOf(intType) and _right.isKindOf(intType)
					pre = '(decimal)'
			on 'SLASHSLASH'
				if left.isKindOf(.compiler.intType) and right.isKindOf(.compiler.intType)
					op = '/'
				else if left.isKindOf(.compiler.decimalType) or right.isKindOf(.compiler.decimalType)
					op = 'Decimal.Floor('
					sep = '/'
				else if left.isKindOf(.compiler.floatType) or right.isKindOf(.compiler.floatType)
					op = 'Math.Floor('
					sep = '/'
				else
					throw FallThroughException([left.type, right.type])
			on 'PERCENT'
				op = '%'
			else
				throw FallThroughException(_op)
		assert op
		sw.write(pre)
		if op.length==1
			_left.writeSharpDef(sw)
			sw.write(op)
			_right.writeSharpDef(sw)
		else
			sw.write(op)  # ex: 'CobraImp.Foo('
			_left.writeSharpDef(sw)
			sw.write(sep)
			_right.writeSharpDef(sw)
			sw.write(')')


class CompareExpr
	inherits BinaryOpExpr

	# TODO: handle the real equals and does not equal

	var _cobraToSharp = {
		'EQ': '==',
		'NE': '!=',
		'GT': '>',
		'LT': '<',
		'GE': '>=',
		'LE': '<=',
		'IS': '==',
		'ISNOT': '!=',
	}

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType

	def _writeSharpDef(sw as SharpWriter) is override
		left = _left
		right = _right
		op = _op
		# Compute the C# operation which will be an operator or method call
		if op=='EQ' or op=='NE'
			if not left.type.isReference and not right.type.isReference
				op = _cobraToSharp[_op]
			else
				stringType = .compiler.libraryType('System', 'String')
				if left.isKindOf(stringType) and right.isKindOf(stringType)
					op = _cobraToSharp[_op]
				else
					op = if(op=='EQ', 'CobraImp.Equals(', 'CobraImp.NotEquals(')
		else if op=='IS' or op=='ISNOT'
			if left.type inherits PrimitiveType and right.type inherits PrimitiveType
				op = _cobraToSharp[_op]
			else
				op = if(op=='IS', 'CobraImp.Is(', 'CobraImp.IsNot(')
		else
			op = _cobraToSharp[_op]
		# Write the C# code
		if op.length<=2
			left.writeSharpDef(sw)
			sw.write(op)
			right.writeSharpDef(sw)
		else
			assert op.endsWith('('), op
			sw.write(op)
			left.writeSharpDef(sw)
			sw.write(',')
			right.writeSharpDef(sw)
			sw.write(')')


class DotExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _type
			assert _right.type
			_type = _right.type
		# convert generic params to specific types when applicable.
		# Example: s.peek() --> String for a Stack<of String> (not Stack<of T>)
		# Example: t.getRange(n,m) --> List<of Color> for a List<of Color> (not List<of T>)
		if _type inherits GenericParam
			if _left.type inherits Box
				t = (_left.type to Box).typeForGenericParam(_type to GenericParam)  # CC: should not need cast to GenericParam
				$sharp('_type = t;')
		else if _type.isGeneric
			box = _type to Box
			if box.containsGenericParameters
				if _left.type inherits Box
					specificType = _left.type to Box
					t = _type.constructedTypeFor(specificType.params)
					$sharp('_type = t;')

	get namedType as IType? is override
		# overridden to return the type this dotted expr represents in those cases when it does represent a type
		assert .didBindImp
		if _definition inherits IType
			return _definition to IType  # CC: shouldn't need this cast
		else
			return nil

	def _writeSharpDef(sw as SharpWriter) is override
		# don't write 'this' for shared members
		writeThis = true
		if _left inherits ThisLit
			if _right inherits CallExpr
				defi = _right.definition
				if defi inherits IMember
					writeThis = not defi.isShared
				else
					# TODO: compiler bug stimulated by following line:
					# throw FallThroughException({'right': _right, 'defi': defi})
					throw FallThroughException(defi)
			else if _right inherits MemberExpr
				writeThis = not _right.definition.isShared
		if writeThis
			_left.writeSharpDef(sw, not _left inherits DotExpr)
			sw.write('.')
		_right.writeSharpDef(sw, false)


class InExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['IN', 'NOTIN']

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		branch _op
			on 'NOTIN': sw.write('!')
			on 'IN': pass
			else: throw FallThroughException(_op)
		sw.write('CobraImp.In(')
		_left.writeSharpDef(sw, false)
		sw.write(',')
		_right.writeSharpDef(sw, false)
		sw.write(')')


class InheritsExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType

	def _writeSharpDef(sw as SharpWriter) is override
		_left.writeSharpDef(sw, false)  # TODO: is false okay here?
		sw.write(' is ')
		_right.writeSharpDef(sw, false)


class AbstractToExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _right.isKindOf(.compiler.typeType) and not _right.type inherits Box
			assert _right.toCobraSource(), _right
			_error('The "to" operator does not apply to "[_right.toCobraSource()]". Use a type.')
		if _right inherits TypeExpr
			_type = _right.receiverType
		else if _right inherits IdentifierExpr
			_type = _right.definition to IType
		else if _right inherits DotExpr  # TODO: This happens for System.Collections.IEnumerable, for example. I don't know if I like that.
			_type = _right.receiverType
		assert _type


class ToExpr
	inherits AbstractToExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if _left inherits NilLiteral and not (_type inherits NilableType or _type inherits PassThroughType)
			_error('Cannot cast nil to a non-nil type.')

	def _writeSharpDef(sw as SharpWriter) is override
		if _right inherits TypeExpr
			if _right.containedType is .compiler.passThroughType
				_left.writeSharpDef(sw)
				return
		parens = true
		sw.write('(')
		_right.writeSharpDef(sw, false)  # double parens would be pointless and also causes a C# error
		sw.write(')')
		_left.writeSharpDef(sw)


class ToQExpr
	inherits AbstractToExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		if not _type inherits NilableType
			_type = NilableType(_type).bindAll() to NilableType  # CC: axe cast when 'as this' is supported

	def _writeSharpDef(sw as SharpWriter) is override
		# x to? int     --> ((x is int || x is int?) ? (int?)x : (int?)null)
		# x to? int?    --> ((x is int || x is int?) ? (int?)x : (int?)null)
		# ^ but this would cause multiple evaluation of x, so...
		# x to? int?	--> (int?)CobraImp.ToOrNil(x)

		# x to? string  --> (x as String)
		# x to? string? --> (x as String)
		right = .right
		if right inherits TypeExpr
			t = right.containedType to IType
		else if right inherits IdentifierExpr
			t = right.definition to IType
		# TODO?: t = t.namedType
		assert t inherits IType
		if t inherits NilableType
			# t = t.theWrappedType to IType  # TODO: revisit if theWrappedType should return nil or not
			$sharp('t = ((NilableType)t).TheWrappedType;')
		if t.isReference
			sw.write('(')
			.left.writeSharpDef(sw)
			sw.write(') as ')
			t.writeSharpRef(sw)
		else
			t.writeSharpRef(sw)
			sw.write('?)CobraImp.ToOrNil<')
			t.writeSharpRef(sw)
			sw.write('>(')
			.left.writeSharpDef(sw)


class CoalesceExpr
	inherits BinaryOpExpr
	"""
	x ? y ==> if(x is nil, y, x)
	but without the potential double evaluation of x, which could be a complex expression.
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		ptt = .compiler.passThroughType
		if _left.type is ptt or _right.type is ptt
			# x ? y   ...where either is typed as passthrough
			_type = ptt
		else if _left.type inherits NilableType and not _right.type inherits NilableType
			# x ? y   ...where x can be nil, but y cannot
			_type = (_left.type to NilableType).theWrappedType  # TODO: should be greatest common denominator between the two
		else
			# the catch all case
			_type = _left.type  # TODO: should be greatest common denominator between the two

	def _writeSharpDef(sw as SharpWriter) is override
		_left.writeSharpDef(sw)
		sw.write(' ?? ')
		_right.writeSharpDef(sw)


class InverseCoalesceExpr
	inherits BinaryOpExpr
	"""
	x ! y ==> if(x is not nil, y, x)
	but without the potential double evaluation of x, which could be a complex expression.
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		ptt = .compiler.passThroughType
		if _left.type is ptt or _right.type is ptt
			# x ! y   ...where either is typed as passthrough
			_type = ptt
# TODO?
#		else if _right.type inherits NilableType and not _right.type inherits NilableType
#			# x ? y   ...where x can be nil, but y cannot
#			_type = _left.type.theWrappedType  # TODO: should be greatest common denominator between the two
		else
			# the catch all case
			_type = _left.type  # TODO: should be greatest common denominator between the two

	def _writeSharpDef(sw as SharpWriter) is override
		_left.writeSharpDef(sw)
		sw.write('==null ? null : ')
		if not _right.type inherits NilableType and not _right.type inherits NilType
			sw.write('(')
			_right.type.writeSharpRef(sw)
			sw.write('?)')
		_right.writeSharpDef(sw)


class CoalesceAssignExpr
	inherits BinaryOpExpr
	"""
	x ?= y
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		# TODO: error check that the left hand type is nilable?
		# TODO: error check that the right hand type is not nilable?
		_type = _right.type

	def _writeSharpDef(sw as SharpWriter) is override
		# L = L * R
		_left.writeSharpDef(sw)
		sw.write(' = ')
		_left.writeSharpDef(sw)
		sw.write(' ?? ')
		_right.writeSharpDef(sw)


class InverseCoalesceAssignExpr
	inherits BinaryOpExpr
	"""
	x != y
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp is override
		base._bindImp()
		# TODO: any error checks here?
		_type = _left.type

	def _writeSharpDef(sw as SharpWriter) is override
		assert false
		# C# doesn't understand ! either
#		sw.write(left.asCS())
#		sw.write('=(')
#		left.genCS(out)
#		sw.write('==null ? null : ')
#		if not inherits(right.type, NilableType) and not inherits(right.type, NilType):
#			sw.write('(')
#			right.type.genCS(out)
#			sw.write('?)')
#		right.genCS(out)
#		sw.write(')')
