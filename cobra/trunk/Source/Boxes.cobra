class Box
	inherits Container
	"""
	The abstract base class for:
		* Class
		* Interface
		* Struct
	These are collectively known as "boxes".
	"""

	# TODO: need to override greatestCommonDenominatorWith() to handle base interfaces

	var _params as List<of IType>  # as in generic parameters
	var _genericTypeDef as Box?
	var _constructedTypes as Dictionary<of String, IType>?

	var _baseInterfaceNodes as List<of INode>
	var _baseInterfaces as List<of Interface>
	var _baseInterfaceTypes as List<of IType>  # can include interfaces and qualified types (containing interfaces) TODO: another example of why QualifiedType should be replaced by TypeIdentifier

	var _overloads as List<of MemberOverload>
	var _nextPrivateSerialNumber = 1001

	var _testMethod as TestMethod?


	def init
		base.init(TokenFix.empty, 'x', List<of String>(), '')
		assert false, 'CC: remove this constructor when unnecessary return statements can be removed'

	def init(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, baseInterfaceNodes as List<of INode>, docString as String?)
		base.init(token, name, isNames, docString)
		_params = paramList
		for i = 0 .. _params.count
			p = _params[i]
			if p inherits GenericParam
				p.index = i
		_baseInterfaceNodes = baseInterfaceNodes
		_baseInterfaces = List<of Interface>()
		_baseInterfaceTypes = List<of IType>()
		_overloads = List<of MemberOverload>()

	def addMinFields is override
		base.addMinFields()
		.addField('isGeneric', .isGeneric)
		.addField('isGenericDef', .isGenericDef)

	def addRefFields is override
		base.addRefFields()
		.addField('genericTypeDef', _genericTypeDef)

	def addSubFields is override
		base.addSubFields()
		.addField('params', _params)
		if _baseInterfaces.count
			.addField('baseInterfaces', _baseInterfaces)
		else
			.addField('baseInterfaceNodes', _baseInterfaceNodes)

	get overloads from var

	get rootName as String
		ensure
			'<' not in result
			.name.startsWith(result)
		body
			name = .name
			i = name.indexOf('<')
			if i <> -1  # List<of>, Dictionary<of,>
				name = name[0:i]
			return name

	get qualifiedRootName as String
		require
			.nameSpace
		ensure
			not result.startsWith('.')
			not result.endsWith('.')
			not .nameSpace.isGlobal implies '.' in result
		body
			nameSpaces = List<of NameSpace>()
			ns = _nameSpace
			while ns and not ns.isGlobal
				nameSpaces.add(ns to passthrough)  # CC: axe cast
				assert ns is not ns.superNameSpace
				ns = ns.superNameSpace
			nameSpaces.reverse
			name = Utils.join('.', for ns in nameSpaces get ns.name)
			if name.length
				name += '.'
			name += .rootName
			return name

	get defaultAccessLevel as String is override
		return 'public'

	pro testMethod from var

	get isFake as bool
		return 'fake' in _isNames

	get params from var

	def isDescendantOfInterface(inter as Interface) as bool
		if this is inter
			return true
		if this.serialNum is inter.serialNum
			# TODO: how in the hell do we get here instead of of the above "this is inter" kicking in? Looks like a bug to me.
			return true
		assert .didBindInt
		for bit in _baseInterfaces
			if bit.isDescendantOfInterface(inter)
				return true
		return false

	def interfaceMemberForName(name as String) as IMember?
		m = .declForName(name)
		if m
			return m
		for inter in _baseInterfaces
			m = inter.interfaceMemberForName(name)
			if m
				break
		return m

	def makeNextPrivateSerialNumber as int
		n = _nextPrivateSerialNumber
		_nextPrivateSerialNumber += 1
		return n

	def registerOverload(ol as MemberOverload)
		require
			ol.name
			ol not in _overloads
		body
			_overloads.add(ol)
			_declsByName[ol.name] = ol
			_declsByName[ol.name.toLower()] = ol

	def addDeclFromOverload(decl as IMember, ol as MemberOverload)
		require
			ol in .overloads
			decl.name == ol.name
		body
			_declsInOrder.add(decl)

	def paramForName(name as String) as IType?
		# TODO: make faster
		for param in _params
			if name==param.name
				return param
		return nil

	def symbolForName(name as String, canBeMember as bool, haveThis as bool) as IMember?
		"""
		Unlike the inherited declForName(), this method follows the
		inheritance change and provides options for canBeMember and
		haveThis.
		"""
		# TODO: is canBeMember ever false?
		if not canBeMember
			return nil
		if name==_name
			return this
		p = .paramForName(name)
		if p
			if haveThis
				.throwError('Cannot refer to a generic parameter ("[name]") through `this`.')
			else
				return p
		x = .declForName(name)
		if x is nil
			x = .interfaceMemberForName(name)
		if x and not haveThis
			if x.requiresThis
				return nil
		return x

	## INamedNode

	get typeForIdentifier as IType is override
		assert .compiler
		# return .compiler.typeType
		t = .compiler.libraryType('System', 'Type')
		assert t
		return t

	get typeForReceiver as IType is override
		return this

	## IType

	get sharpNameComponent as String is override
		name = .name
		i = name.indexOf('/*')  # example: /*dynamic*/object
		if i <> -1
			j = name.indexOf('*/', i)
			name = name[:i] + name[j+2:]
		# qualified types and generics need cleanup
		for ch in '.<>, '
			name = name.replace(ch, c'_')
		return name

	def indexType(argTypes as List<of IType>) as IType? is override
		"""
		Used by the IndexExpr to determine its type.
		"""
		indexer = .memberForName(r'[]')

		# TODO: check argTypes
		if indexer
			t = indexer.resultType
			if t inherits GenericParam
				return .typeForGenericParam(t)
			else
				return t
		if .isGeneric
			return .innerType
		return nil

	get innerType as IType? is override
		getEnum = .symbolForName('getEnumerator', true, true)
		if getEnum
			assert getEnum.didBindInt
			rt = getEnum.resultType
			if rt is .compiler.passThroughType
				return rt
			if rt.isDynamic
				return rt
			if rt.isGeneric
				# TODO: this is a hack. should check for IEnumerator and 'current' like we do for non-generics further below
				# assert not rt.isGenericDef
				if rt inherits Box
					it = rt.params[0]
					if it inherits GenericParam
						#it = .typeForGenericParam(it) # CC: this fails because IType on the right is more general than GenericParam on the left. But I'm thinking Cobra should allow you to back up to the original type if you like
						return .typeForGenericParam(it)
					else
						return it
				else
					assert false, 'finish me'  # TODO
			else
				if rt.isDescendantOf(.compiler.libraryType('System', 'Collections', 'IEnumerator'))
					return rt.memberForName('current').resultType
				else
					throw FallThroughException(rt)
		# TODO: hacky
		if .name=='String'
			return .compiler.charType
		return nil

	def isComparableTo(t as IType) as bool
		r = base.isComparableTo(t)
		if not r and t inherits CharType and .name == 'String'  # TODO: hacky
			r = true
		if not r and ('dynamic' in .name or 'dynamic' in t.name)  # TODO: hacky
			r = true
		return r

	## Binding

	def _bindInt is override
		base._bindInt()
		.compiler.boxStack.push(this)
		try
			_bindInterfaces()
			for param in _params
				param.bindInt()
			for decl in _declsInOrder
				assert not decl is this, this
				try
					decl.bindInt()
				catch ne as NodeException
					.compiler.recordError(ne)
			_finishOverloads
			if _testMethod
				_testMethod.bindInt()
		finally
			.compiler.boxStack.pop()

	def _bindInterfaces
		# structs, classes and interfaces can all have 0 or more interfaces they inherit/implement
		assert _baseInterfaceNodes, this
		for node in _baseInterfaceNodes
			try
				baseWhat = node.bindInt().namedType
				# TODO: strongly consider getting rid of QualifiedType and using TypeIdentifier in its place
				if baseWhat inherits QualifiedType
					baseWhat.bindInt()
				if baseWhat is nil
					assert false, 'When does this happen?'
					.throwError('Cannot locate [node].')
				else if baseWhat inherits Interface
					_baseInterfaces.add(baseWhat)
					_baseInterfaceTypes.add(baseWhat)
				else if baseWhat inherits QualifiedType
					if baseWhat.theWrappedType inherits Interface
						_baseInterfaces.add(baseWhat.theWrappedType to Interface)
						_baseInterfaceTypes.add(baseWhat)
					else
						assert baseWhat.theWrappedType, baseWhat.toTechString()
						.throwError('Cannot inherit "[baseWhat.theWrappedType.name]" which is a [baseWhat.theWrappedType.englishName].')
				else
					_badInterfaceError(baseWhat to IType)  # CC: axe type cast
			catch ne as NodeException
				.compiler.recordError(ne)

	def _badInterfaceError(type as IType)
		.throwError('Cannot inherit "[type.name]" which is a [type.englishName].')

	def _finishOverloads
		# this method is broken out so Class can override and deal with inheritance and overloads
		for ol in _overloads
			try
				ol.bindInt()
			catch ne as NodeException
				.compiler.recordError(ne)

	def _bindImp is override
		base._bindImp()
		assert .didBindInt
		.compiler.boxStack.push(this)
		try
			for decl in _declsInOrder
				assert not decl is this, this
				try
					decl.bindImp()
				catch ne as NodeException
					.compiler.recordError(ne)
			for ol in _overloads
				try
					ol.bindImp()
				catch ne as NodeException
					.compiler.recordError(ne)
			if _testMethod
				_testMethod.bindImp()
		finally
			.compiler.boxStack.pop()

	## Generics

	get isGenericDef as bool is override
		# TODO: make this more efficient, maybe be computing in the constructor
		if _params.count
			for param in _params
				if not param inherits GenericParam
					return false
			return true
		else
			return false

	get isGeneric as bool is override
		return _params.count>0

	get genericParams as List<of IType> is override
		or require .isGeneric
		return _params

	get genericTypeDef as IType? is override
		return _genericTypeDef

	def constructedTypeFor(typeArgs as List<of IType>) as IType is override
		or require  # TODO: make this stronger by pushing up to base. # TODO: inherit this from the interface instead
			.containsGenericParameters
			typeArgs.count==.params.count
		body
			if _constructedTypes is nil
				_constructedTypes = Dictionary<of String, IType>()

			# CC: rewrite code below as:
			# key = Utils.join(',', for type in typeArgs get type.name)
			# key = for type in typeArgs get type.name stringed with ','
			names = List<of String>()
			for type in typeArgs
				names.add(type.name)
			key = Utils.join(',', names)

			c = _constructedTypes to Dictionary<of String, IType>  # CC: axe this. it works around a bug

			if _constructedTypes.containsKey(key)
				# CC: return _contructedTypes[key]
				return c[key]

			t = .memberwiseClone() to Box
			t._completeConstruction(this, typeArgs, key)
			# CC: _contructedTypes[key] = t
			c[key] = t
			return t

	def _completeConstruction(genericDef as Box, typeArgs as List<of IType>, key as String)
		require
			genericDef.isGeneric
		body
			.setSerialNum(_nextNodeSerialNum)
			_nextNodeSerialNum += 1
			_name = '[.rootName]<of [key]>'
			_genericTypeDef = genericDef
			.cloneCollections()
			for i = 0 .. typeArgs.count
				_params[i] = typeArgs[i]
			for i = 0 .. _baseInterfaces.count
				if _baseInterfaces[i].isGenericDef
					_baseInterfaces[i] = _baseInterfaces[i].constructedTypeFor(typeArgs) to Interface

			# TODO: ? should be cloning the declarations to also incorporate the typeArgs where they happen to refer to generic params
			# ^ or this already covered by DotExpr._bindExpr()?

			#newDecls = List<of IMember>()
			#for decl in _declsInOrder
			#	decl = decl.constructedTypeFor(

	def cloneCollections is override
		base.cloneCollections()
		_params = List<of IType>(_params)  # TODO: Can I just say _params.clone? Do I need the cast?
		if _constructedTypes
			_constructedTypes = Dictionary<of String, IType>(_constructedTypes)
		_baseInterfaceNodes = List<of INode>(_baseInterfaceNodes)
		_baseInterfaces = List<of Interface>(_baseInterfaces)
		_baseInterfaceTypes = List<of IType>(_baseInterfaceTypes)
		_overloads = List<of MemberOverload>(_overloads)

	def typeForGenericParam(gp as GenericParam) as IType # TODO: is this needed for NilableType?
		"""
		Returns the specific type arg that corresponds to the given generic
		parameter. Used to match the gp's in method, properties, etc. against
		the actual types in a constructed type.
		"""
		require
			.isGeneric
			.params
		body
			return .params[gp.index]

	get containsGenericParameters as bool
		for param in _params
			if param inherits GenericParam
				return true
			if param inherits Box  # CC: and <next if condition>
				if param.containsGenericParameters
					return true
		return false


	## Code gen

	get sharpKeyWord as String
		throw OverrideException(.getType)

	get sharpName as String is override
		return _name.replace('of', '')

	get sharpRef as String is override
		if _params.count
			sb = StringBuilder()
			# generic
			name = .rootName
			sb.append(name)
			sb.append('<')
			sep = ''
			for param in _params
				sb.append(sep)
				sb.append(param.sharpRef)
				sep = ', '
			sb.append('>')
			return sb.toString
		else
			return .name

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		if .isFake
			return
		.writeSharpIsNames(sw)
		sw.write('[.sharpKeyWord] [.rootName]')
		if _params.count
			sw.write('<')
			sep = ''
			for param in _params
				sw.write(sep)
				param.writeSharpDef(sw)
				sep = ', '
			sw.write('>')

		.writeSharpInheritance(sw)

		sep = ''
		for inter in _baseInterfaces
			sw.write(sep)
			sw.write(inter.sharpRef)
			sep = ', '

		if _params.count
			sw.indent()
			for param in _params
				if param inherits GenericParam
					param.writeSharpConstraint(sw)
			sw.dedent()

		sw.writeAndIndent('{\n')
		if _testMethod
			_testMethod.writeSharpDef(sw)
		for decl in _declsInOrder
			decl.writeSharpDef(sw)
		.writeSharpTest(sw)
		sw.dedentAndWrite('} // [.sharpKeyWord] [.name]\n')
		sw.write('\n')

	def writeSharpInheritance(sw as SharpWriter)
		"""
		Class uses this to write its base class declaration.
		No box uses this to write interface implementation--that's handled in the Box class.
		"""
		pass

	def writeSharpTest(sw as SharpWriter)
		sw.write('\nstatic [.rootName]() { RunTestsIfNeeded(); }\n')
		sw.write('\nprivate static bool __didStartTests = false;\n')
		newWord = .newForSharpTest
		sw.write('\npublic static[newWord] void RunTestsIfNeeded() { if (!__didStartTests) RunTests(); }\n')
		sw.write('\npublic static[newWord] void RunTests()')
		sw.writeAndIndent(' {\n')
		sw.write('__didStartTests = true;\n')
		sw.write('CobraImp.TestBegan("[.name]");\n')
		if _testMethod
			sw.write('[_testMethod.sharpName]();\n')
		for decl in _declsInOrder
			decl.writeSharpTestInvocation(sw)
		sw.write('CobraImp.TestEnded("[.name]");\n')
		sw.dedentAndWrite('}\n')

	var _didWriteSharpTestInvocation = false

	def writeSharpTestInvocation(sw as SharpWriter) is override
		# used by the test option
		if _didWriteSharpTestInvocation
			return
		if .isFake
			return
		assert _nameSpace
		sw.write('\t\t[.qualifiedRootName].RunTestsIfNeeded();\n')
		_didWriteSharpTestInvocation = true

	get newForSharpTest as String
		return ''


class Class
	inherits Box

	var _baseClass as Class?
	var _baseNode as INode?

	def init(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, baseNode as INode?, implementsNodes as List<of INode>, docString as String?)
		base.init(token, name, paramList, isNames, implementsNodes, docString)
		_baseNode = baseNode

	def addRefFields is override
		base.addRefFields()
		.addField('baseClass', _baseClass)

	def addSubFields is override
		base.addSubFields()
		.addField('baseNode', _baseNode)

	get baseClass from var

	def isDescendantOf(type as IType) as bool is override
		if not type.didBindInt
			type.bindInt()
		if this is type
			return true
		if type inherits Interface
			if .isDescendantOfInterface(type)
				return true
		assert .baseClass is not this, this  # check for direct cycles
		if .baseClass
			return .baseClass.isDescendantOf(type)
		else
			return false

	get isReference as bool is override
		return true

	def memberForName(name as String) as IMember? is override
		# the next assertion fails for Tests\600-misc\404-implement-IEnumerable
		# could not fix. I'm confused. Something to do with generics. So bail on generics:
		# asserting .didBindInt is difficult because memberForName() gets invoked during bindInt
		# if not .isGeneric
		# 	assert .didBindInt  # TODO: is this legit? if so, push up to Container
		m = base.memberForName(name)
		if m is nil and _baseClass
			m = _baseClass.memberForName(name)
		if m is nil
			m = .interfaceMemberForName(name)
		# handle get/set parts like "someProp.get" or "[].set"
		# `computeMatchingBaseMember` in Members.cobra is at least one that returns this
		if m is nil and '.' in name
			if name.endsWith('.get')
				part = 'g'
			else if name.endsWith('.set')
				part = 's'
			else
				throw FallThroughException(name)
			pd = .memberForName(name[:-4])
			if pd inherits ProperDexer
				branch part
					on 'g'
						m = pd.getPart
					on 's'
						m = pd.setPart
				# TODO: cache the above back into the _decls
		return m

	def symbolForName(name as String, canBeMember as bool, haveThis as bool) as IMember? is override
		"""
		Unlike the inherited declForName(), this method follows the
		inheritance change and provides options for canBeMember and
		haveThis.
		"""
		m = base.symbolForName(name, canBeMember, haveThis)
		if m is nil and _baseClass
			m = _baseClass.memberForName(name)
		return m

	def _bindInt is override
		if _baseNode
			_baseNode.bindInt()
			possible = _baseNode.namedType
			baseName = (_baseNode to AbstractTypeIdentifier).name
			if possible is nil
				.throwError('Cannot locate base class named "[baseName]" for class "[_name]".')
			if possible inherits QualifiedType
				possible.bindInt()  # TODO: another monkey wrench showing how QualifiedType should be retired
				$sharp('loc_possible = ((QualifiedType)loc_possible).TheWrappedType')
			if possible inherits Class
				_baseClass = possible
			else if possible inherits Interface
				.throwError('The base "[baseName]" is an interface. Try "implements" instead of "inherits".')
			else if possible inherits Struct
				.throwError('The base "[baseName]" is a struct. Classes cannot inherit from structs.')
			else
				.throwError('The base class "[baseName]" is not actually a class, it is a "[possible.englishName]".')
		else
			t = .compiler.libraryType('System', 'Object')
			if t inherits Class
				if this is not t  # don't want Object to inherit Object
					_baseClass = t
			else
				throw FallThroughException(t)
		for decl in .declsInOrder
			if decl inherits Constructor
				foundConstructor = true
		if not foundConstructor
			# TODO: at some point this should be changed to provide cover constructors for each of the public, inherited constructors
			.addDecl(Constructor(.token, this, List<of Param>(), ['public'], ''))
		if _baseClass
			_baseClass.bindInt
		base._bindInt()

	def _badInterfaceError(type as IType) is override
		msg = 'Cannot implement "[type.name]" which is a [type.englishName].'
		if type inherits Class
			msg += ' Use "inherits" instead.'
		.throwError(msg)

	def _finishOverloads
		# deal with inheritance and overloads
		assert _baseClass or _name=='Object'
		if _baseClass
			#assert _baseClass.didBindInt
			if not _baseClass.didBindInt
				_baseClass.bindInt
			for decl in List<of IMember>(_declsInOrder)
				if decl inherits Method and not decl inherits Constructor
					other = _baseClass.memberForName(decl.name)
					if other
						if decl inherits MemberOverload
							overload = decl
						else if decl inherits BoxMember
							overload = MemberOverload(decl)
							.registerOverload(overload)
						else
							throw FallThroughException(decl)
						if other inherits MemberOverload
							for member in other.members
								assert not member inherits MemberOverload
								overload.addInheritedMember(member)
						else if other inherits BoxMember
							overload.addInheritedMember(other)
						else
							throw FallThroughException(other)
		base._finishOverloads

	get englishName as String is override
		return 'class'

	get superType as IType? is override
		assert .didBindInt
		return _baseClass

	## Code gen

	get csInit as String is override
		return 'null'

	get sharpKeyWord as String is override
		return 'class'

	def writeSharpInheritance(sw as SharpWriter) is override
		sw.write(' : ')
		if _baseNode inherits TypeIdentifier
			# needed QualifiedTypes such "inherits System.Collection.ArrayList". See Tests\300-misc\700-use-on-generice-IList
			sw.write(_baseNode.actualType.sharpRef)
			didWrite = true
		else if _baseClass
			sw.write(_baseClass.sharpRef)
			didWrite = true
		if didWrite
			if _baseInterfaces.count
				sw.write(', ')
			else
				sw.write(' ')

	get newForSharpTest as String is override
		return if(not _baseClass.isFake, ' new', '')


class Interface
	inherits Box

	def init(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, baseNodes as List<of INode>, docString as String?)
		base.init(token, name, paramList, isNames, baseNodes, docString)

	get englishName as String is override
		return 'interface'

	get isReference as bool is override
		return true

	def isDescendantOf(type as IType) as bool is override
		if not type.didBindInt
			type.bindInt()
		if this is type
			return true
		if type inherits Interface
			if .isDescendantOfInterface(type)
				return true
		return false

	def memberForName(name as String) as IMember? is override
		assert .didBindInt  # TODO: is this legit? if so, push up to Container
		m = base.memberForName(name)
		if m is nil
			m = .interfaceMemberForName(name)
			if m is nil
				m = .compiler.libraryType('System', 'Object').memberForName(name)
		return m

	## Code gen

	get csInit as String is override
		return 'null'

	get sharpKeyWord as String is override
		return 'interface'

	def writeSharpInheritance(sw as SharpWriter) is override
		if _baseInterfaces.count
			sw.write(' : ')

	def writeSharpTest(sw as SharpWriter) is override
		# Static methods can't be put in interfaces. However, at some point Cobra should support
		# tests for interfaces which could then be run against the classes that implement them.
		# Just requires more code gen smarts.
		pass

	def writeSharpTestInvocation(sw as SharpWriter) is override
		pass


class Struct
	inherits Box

	def init(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, baseName as String?, interfaceNodes as List<of INode>, docString as String?)
		base.init(token, name, paramList, isNames, interfaceNodes, docString)

	def _bindInt is override
		base._bindInt()

	get isReference as bool is override
		return false

	## Code gen

	get sharpKeyWord as String is override
		return 'class'

	get csInit as String is override
		return ''  # blank to indicate there is no valid init


class GenericParam
	inherits CobraType
	"""
	A generic parameter *is* a type.
	"""

	var _name as String
	var _constraints as List<of GenericConstraint>
	var _index as int

	def init(name as String)
		require name
		base.init()
		_name = name
		_constraints = List<of GenericConstraint>()

	get name as String is override
		return _name

	get constraints from var

	pro index from var

	get isReference as bool is override
		# Well, it's hard to say if a GenericParam is a reference or value type, but CompareExpr() influences us to say "true".
		# TODO: if there are constraints examine them
		return true

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addSubFields is override
		base.addSubFields()
		.addField('constraints', _constraints)

	def declForName(name as String) as IMember? is override
		for constraint in _constraints
			decl = constraint.declForName(name)
			if decl
				return decl
		return nil

	def memberForName(name as String) as IMember? is override
		for constraint in _constraints
			member = constraint.memberForName(name)
			if member
				return member
		return nil

	def isDescendantOf(type as IType) as bool is override
		if type is .compiler.libraryType('System', 'Object')
			return true
		if type.superType is nil  # the root type
			return true
		for constraint in _constraints
			if constraint.isDescendantOf(type)
				return true
		return false

	def _bindInt is override
		base._bindInt()
		for constraint in _constraints
			constraint.bindInt()

	get csInit as String is override
		return 'default([_name])'

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write(.name)

	def writeSharpConstraint(sw as SharpWriter)
		if _constraints.count
			sw.write('where [_name] :  ')
			sep = ''
			for constraint in _constraints
				sw.write(sep)
				constraint.writeSharpDef(sw)
				sep = ', '
			sw.write('\n')


class GenericConstraint
	inherits SyntaxNode

	def init(token as IToken)
		base.init(token)

	def isDescendantOf(type as IType) as bool
		return false

	def declForName(name as String) as IMember?
		"""
		Returns nil by default.
		"""
		return nil

	def memberForName(name as String) as IMember?
		"""
		Returns nil by default.
		"""
		return nil

	def _bindInt is override
		base._bindInt()


class GenericClassConstraint
	inherits GenericConstraint
	"""
	Represents the generic constraint class
	"""

	def init(token as IToken)
		base.init(token)

	def writeSharpDef(sw as SharpWriter) is override
		sw.write('class')


class GenericStructConstraint
	inherits GenericConstraint
	"""
	Represents the generic constraint class
	"""

	def init(token as IToken)
		base.init(token)

	def writeSharpDef(sw as SharpWriter) is override
		sw.write('struct')


class GenericCallableConstraint
	inherits GenericConstraint
	"""
	Represents the generic constraint callable
	"""

	def init(token as IToken)
		base.init(token)

	def writeSharpDef(sw as SharpWriter) is override
		sw.write('new')


class GenericTypeConstraint
	inherits GenericConstraint
	"""
	Represents the generic constraint callable
	"""

	var _representedType as IType?
	var _typeNode as ISyntaxNode

	def init(typeNode as ISyntaxNode)
		base.init(typeNode.token)
		_typeNode = typeNode

	def isDescendantOf(type as IType) as bool is override
		assert _representedType
		return _representedType.isDescendantOf(type)

# TODO?
#	def declForName(name as String) as IMember? is override
#		assert _representedType
#		return _representedType.declForName(name)

	def memberForName(name as String) as IMember? is override
		assert _representedType
		return _representedType.memberForName(name)

	def _bindInt is override
		base._bindInt()
		if _representedType is nil
			_typeNode.bindInt()
			_representedType = _typeNode.namedType
			assert _representedType
		if not _representedType inherits Class and not _representedType inherits Interface
			.throwError('A generic type constraint must be a class or an interface. "[_representedType.name]" is not.')

	def writeSharpDef(sw as SharpWriter) is override
		sw.write(_representedType.sharpRef)
