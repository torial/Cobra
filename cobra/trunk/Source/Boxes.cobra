use System.Reflection


class Box
	inherits Container
	"""
	The abstract base class for:
		* Class
		* Interface
		* Struct
	These are collectively known as "boxes".
	"""

	# TODO: need to override greatestCommonDenominatorWith() to handle base interfaces

	var _params as List<of IType>  # as in generic parameters
	var _genericTypeDef as Box?
	var _constructedTypes as Dictionary<of String, IType>?

	var _baseClass as Class?
	var _baseInterfaceProxies as List<of ITypeProxy>
	var _baseInterfaces as List<of Interface>

	var _overloads as List<of MemberOverload>
	var _nextPrivateSerialNumber = 1001

	var _testMethod as TestMethod?

	var _clrType as Type?
	var _needScanClrType as bool

	def init(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, baseInterfaceNodes as List<of ITypeProxy>, docString as String?)
		base.init(token, name, isNames, docString)
		_params = paramList
		for i = 0 .. _params.count
			p = _params[i]
			if p inherits GenericParam
				p.index = i
		_baseInterfaceProxies = baseInterfaceNodes
		_baseInterfaces = List<of Interface>()
		_overloads = List<of MemberOverload>()

	def _scanClrType
		"""
		Subclasses should invoke base.
		"""
		_needScanClrType = false
		# print '[.name] in [_parentNameSpace.fullName]'

	def addMinFields
		base.addMinFields
		.addField('isGeneric', .isGeneric)
		.addField('isGenericDef', .isGenericDef)

	def addRefFields
		base.addRefFields
		.addField('genericTypeDef', _genericTypeDef)
		.addField('baseClass', _baseClass)

	def addSubFields
		base.addSubFields
		.addField('params', _params)
		if _baseInterfaces.count
			.addField('baseInterfaces', _baseInterfaces)
		else
			.addField('baseInterfaceNodes', _baseInterfaceProxies)
		.addField('clrType', _clrType)

	get baseClass from var

	get baseInterfaces from var
	
	pro parentNameSpace as NameSpace?
		get
			return base.parentNameSpace
		set
			# a box needs to be tied to its local namespace, not the unified one
			assert (value and .token.text <> '(empty)') implies not value.isUnified
			base.parentNameSpace = value

	get overloads from var

	get rootName as String
		ensure
			'<' not in result
			.name.startsWith(result)
		body
			name = .name
			i = name.indexOf('<')
			if i <> -1  # List<of>, Dictionary<of,>
				name = name[0:i]
			return name

	get qualifiedRootName as String
		require
			.parentNameSpace
		ensure
			not result.startsWith('.')
			not result.endsWith('.')
			not .parentNameSpace.isRoot implies '.' in result
		body
			nameSpaces = List<of NameSpace>()
			ns = .parentNameSpace
			while ns and not ns.isRoot
				nameSpaces.add(ns to !)
				assert ns is not ns.superNameSpace
				ns = ns.superNameSpace
			nameSpaces.reverse
			name = Utils.join('.', for ns in nameSpaces get ns.name)
			if name.length
				name += '.'
			name += .rootName
			return name

	get defaultAccessLevel as String is override
		return 'public'

	pro testMethod from var

	get isFake as bool
		return 'fake' in _isNames

	get params from var

	def isDescendantOfInterface(inter as Interface) as bool
		if _baseInterfaces.count == 0 and _baseInterfaceProxies.count
			.bindInt
		if .compiler
			inter.bindInt
		if this is inter
			return true
		assert .serialNum <> inter.serialNum
		assert _baseInterfaceProxies.count == 0 or _baseInterfaces.count == _baseInterfaceProxies.count
		for bit in _baseInterfaces
			if bit.isDescendantOfInterface(inter)
				return true
		return false

	def interfaceMemberForName(name as String) as IMember?
		m = .declForName(name)
		if m
			return m
		for inter in _baseInterfaces
			m = inter.interfaceMemberForName(name)
			if m
				break
		return m

	def makeNextPrivateSerialNumber as int
		n = _nextPrivateSerialNumber
		_nextPrivateSerialNumber += 1
		return n

	def memberForName(name as String) as IMember?
		if .compiler and .compiler.isBindingImp
			.bindInt  # this is for DLL types which get bindInt only on demand. (otherwise reading system DLLs slows things down)
		else if _needScanClrType
			_scanClrType  # also needed for DLL types. execution gets here due to Compiler.fixNonNilableMemberSigs
		return base.memberForName(name)

	def registerOverload(ol as MemberOverload)
		require
			ol.name
			ol not in _overloads
		body
			_overloads.add(ol)
			_declsByName[ol.name] = ol
			_declsByName[ol.name.toLower] = ol

	def addDeclFromOverload(decl as IMember, ol as MemberOverload)
		require
			ol in .overloads
			decl.name == ol.name
		body
			_declsInOrder.add(decl)

	def paramForName(name as String) as IType?
		# TODO: make faster
		for param in _params
			if name==param.name
				return param
		return nil

	def symbolForName(name as String, haveThis as bool) as IMember?
		return .symbolForName(name, haveThis, true)

	def symbolForName(name as String, haveThis as bool, checkNameSpace as bool) as IMember?
		"""
		Unlike the inherited .declForName, this method follows the
		inheritance change and provides options for haveThis.
		"""
		if name == _name
			return this
		p = .paramForName(name)
		if p
			if haveThis
				.throwError('Cannot refer to a generic parameter ("[name]") through `this`.')
			else
				return p
		x = .declForName(name)
		if x is nil and _baseClass
			x = _baseClass.symbolForName(name, haveThis, false)
		if x is nil
			x = .interfaceMemberForName(name)
		if x and not haveThis
			if x.requiresThis
				x = nil
		if x is nil and checkNameSpace
			nameSpace = .parentNameSpace
			if not .name.startsWith('ArrayType_')  # TODO: axe this guard when ArrayType.memberForName's TODO to read System.Array is done
				if .didBindInt
					assert nameSpace
			if nameSpace
				assert not nameSpace.isUnified
				x = nameSpace.symbolForName(name)
		return x

	## INamedNode

	get typeForIdentifier as IType is override
		assert .compiler
		# return .compiler.typeType
		t = .compiler.libraryType('System', 'Type')
		assert t
		return t

	get typeForReceiver as IType is override
		return this

	## IType

	get sharpNameComponent as String is override
		name = .name
		i = name.indexOf('/*')  # example: /*dynamic*/object
		if i <> -1
			j = name.indexOf('*/', i)
			name = name[:i] + name[j+2:]
		# qualified types and generics need cleanup
		for ch in '.<>, '
			name = name.replace(ch, c'_')
		return name

	get innerType as IType? is override
		if this is .compiler.libraryType('System', 'String')  # TODO: hacky
			return .compiler.charType
		getEnum = .symbolForName('getEnumerator', true)
		if getEnum
			# TODO: is this really needed? if so, why?
			if not getEnum.didBindInt
				getEnum.bindInt
			assert getEnum.didBindInt
			# can have two getEnumerators -- one generic and the other not. favor the generic one
			if getEnum inherits MemberOverload
				for member in getEnum.members
					if member inherits Method
						if member.resultType <> .compiler.libraryType('System', 'Object')
							# implementing IEnumerable<of T> which requires two `getEnumerator` members
							$sharp('getEnum = member')
							break
			rt = getEnum.resultType
			if rt is .compiler.passThroughType
				return rt
			if rt.isDynamic
				return rt
			if rt inherits NilableType
				# nilable is not a concern; unwrap it:
				$sharp('rt = ((NilableType)rt).TheWrappedType')
			if rt.isGeneric
				# TODO: this is a hack. should check for IEnumerator and 'current' like we do for non-generics further below
				# assert not rt.isGenericDef
				if rt inherits Box
					it = rt.params[0]
					if it inherits GenericParam
						#it = .typeForGenericParam(it) # CC: this fails because IType on the right is more general than GenericParam on the left. But I'm thinking Cobra should allow you to back up to the original type if you like
						return .typeForGenericParam(it)
					else
						return it
				else
					assert false, 'finish me'  # TODO
			else
				if rt.isDescendantOf(.compiler.libraryType('System', 'Collections', 'IEnumerator'))
					return rt.memberForName('current').resultType
				else
					throw FallThroughException(rt)
		return nil

	def isEquatableTo(t as IType) as bool
		r = base.isEquatableTo(t)
		if not r and t inherits CharType and this is .compiler.libraryType('System', 'String')  # TODO: hacky? could this be determined by looking for a static == operator overload?
			r = true
		if not r and ('dynamic' in .name or 'dynamic' in t.name)  # TODO: hacky
			r = true
		return r

	def isComparableTo(t as IType) as bool
		r = base.isComparableTo(t)
		if not r and t inherits CharType and this is .compiler.libraryType('System', 'String')  # TODO: hacky? could this be determined by looking for a static == operator overload?
			r = true
		if not r and ('dynamic' in .name or 'dynamic' in t.name)  # TODO: hacky
			r = true
		return r

	## Binding

	def _bindInt
		base._bindInt
		.compiler.boxStack.push(this)
		try
			if _needScanClrType
				_scanClrType
			_bindBase
			if _baseClass
				_baseClass.bindInt
			_bindInterfaces
			for param in _params
				param.bindInt
			for decl in _declsInOrder
				assert not decl is this, this
				try
					decl.bindInt
				catch ne as NodeException
					.compiler.recordError(ne)
			_finishOverloads
			if _testMethod
				_testMethod.bindInt
		finally
			.compiler.boxStack.pop

	def _bindBase
		# invoked by _bindInt
		_baseClass = .compiler.classType('System', 'Object')

	def _bindInterfaces
		# structs, classes and interfaces can all have 0 or more interfaces they inherit/implement
		assert _baseInterfaceProxies, this
		for node in _baseInterfaceProxies
			try
				baseWhat = (node.bindInt to ITypeProxy).realType  # CC: axe cast
				if baseWhat is nil
					assert false, 'When does this happen?'
					.throwError('Cannot locate [node].')
				else if baseWhat inherits Interface
					baseWhat.bindInt  # just as with the base class; .bindInt on parents
					_baseInterfaces.add(baseWhat)
				else
					_badInterfaceError(baseWhat to !)
			catch ne as NodeException
				.compiler.recordError(ne)

	def _badInterfaceError(type as IType)
		.throwError('Cannot inherit "[type.name]" which is a [type.englishName].')

	def _finishOverloads
		# this method is broken out so Class can override and deal with inheritance and overloads
		for ol in _overloads
			try
				ol.bindInt
			catch ne as NodeException
				.compiler.recordError(ne)

	def _bindImp
		base._bindImp
		assert .didBindInt
		.compiler.boxStack.push(this)
		try
			for decl in _declsInOrder
				assert not decl is this, this
				try
					decl.bindImp
				catch ne as NodeException
					.compiler.recordError(ne)
			for ol in _overloads
				try
					ol.bindImp
				catch ne as NodeException
					.compiler.recordError(ne)
			if _testMethod
				_testMethod.bindImp
		finally
			.compiler.boxStack.pop

	## Generics

	def isAssignableTo(type as IType) as bool
		r = base.isAssignableTo(type)
		if not r
			if type inherits NilableType
				$sharp('type = ((NilableType)type).TheWrappedType')
			if (.isGeneric and type.isGeneric and .genericTypeDef is type.genericTypeDef) or (.isGenericDef and type.isGeneric and this is type.genericTypeDef)
				# CC?: r = all true for i, gp in .genericParams.numbered get gp.isAssignableTo(type.genericParams[i])
				i = 0
				r = true
				for gp in .genericParams  # CC: for i, gp in .genericParams.numbered
					if not gp.isAssignableTo(type.genericParams[i])
						r = false
						break
					i += 1
			else if type.isGenericDef and .isGeneric and type is .genericTypeDef
				r = type.isAssignableTo(this)
		return r
					
	get isConstructed as bool
		return _genericTypeDef is not nil

	get isGenericDef as bool is override
		# TODO: make this more efficient, maybe by computing in the constructor
		if _params.count
			for param in _params
				if not param inherits GenericParam
					return false
			return true
		else
			return false

	get isGeneric as bool is override
		return _params.count>0

	get genericParams as List<of IType> is override
		or require .isGeneric
		return _params

	get genericTypeDef as IType? is override
		return _genericTypeDef

	def constructedTypeFor(typeArgs as List<of IType>) as IType is override
		or require  # TODO: make this stronger by pushing up to base. # TODO: inherit this from the interface instead
			.containsGenericParameters
			typeArgs.count==.params.count
		body
			if typeArgs == _params
				return this
			if _constructedTypes is nil
				_constructedTypes = Dictionary<of String, IType>()
			key = Utils.join(',', for type in typeArgs get type.name)
			if _constructedTypes.containsKey(key)
				return _constructedTypes[key]
			# TODO: this next if-statement and .bindInt call can be axed if a there is a separate "bind inheritance" phase
			if not .didBindInt and not .isBindingInt
				.bindInt  # but this creates a problem with overloads not getting bindInt... see fix in _completeConstruction
			t = .memberwiseClone to Box
			_constructedTypes[key] = t
			t._completeConstruction(this, typeArgs, key)
			return t

	def _completeConstruction(genericDef as Box, typeArgs as List<of IType>, key as String)
		require
			genericDef.isGeneric  # TODO: make this stronger: isGenericDef
			.params.count == typeArgs.count
			key.length
		body
			# create a dictionary from the generic params to their effective type
			gpToType = Dictionary<of GenericParam, IType>()
			for i = 0 .. typeArgs.count
				if (p = _params[i]) inherits GenericParam
					gpToType[p] = typeArgs[i]
				else
					throw FallThroughException(p)
			_name = '[.rootName]<of [key]>'
			_genericTypeDef = genericDef
			.cloneCollections
			for i = 0 .. typeArgs.count
				_params[i] = typeArgs[i]
			_completeConstructionOfBase(gpToType)
			for i = 0 .. _baseInterfaces.count
				_baseInterfaces[i] = _baseInterfaces[i].secondaryConstructedTypeFor(this, gpToType) to Interface

			# construct the declarations
			_overloads = List<of MemberOverload>()
			newDecls = List<of IMember>()
			for decl in _declsInOrder
				if decl inherits BoxMember
					newDecls.add(nd=decl.constructedFor(this, gpToType))
					assert nd <> decl
				else
					throw FallThroughException(decl)
			_declsInOrder = List<of IMember>()
			_declsByName = Dictionary<of String, IMember>()
			_declsByNameCI = Dictionary<of String, IMember>()
			for decl in newDecls
				if _declsByName.containsKey(decl.name)
					overload = nil to MemberOverload?
					other = _declsByName[decl.name]
					if other inherits MemberOverload
						overload = other
					else if other inherits AbstractMethod
						overload = MemberOverload(other)
						.registerOverload(overload to !)
					else
						throw FallThroughException(other)
					overload.addMember(decl to BoxMember)
				else
					_declsInOrder.add(decl)
					_declsByName[decl.name] = decl
					_declsByNameCI[decl.name.toLower] = decl
			.bindInt
			# TODO: this next statement can be axed if a there is a separate "bind inheritance" phase
			_finishOverloads
			
	def _completeConstructionOfBase(gpToType as Dictionary<of GenericParam, IType>)
		# invoked by _completeConstruction for the benefit of Class
		pass

	def secondaryConstructedTypeFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as IType is override
		if _params.count == 0
			return this
		typeArgs = List<of IType>()
		params = .params
		for param in params
			if param inherits GenericParam
				# doesn't work:
				# typeArgs.add(gpToType[param])
				found as GenericParam?
				for key as dynamic in gpToType.keys
					if key.name == param.name
						found = key
				assert found
				typeArgs.add(gpToType[found to !])
			else
				typeArgs.add(param.secondaryConstructedTypeFor(box, gpToType))
		if .isGenericDef
			return .constructedTypeFor(typeArgs)
		else
			assert .genericTypeDef.isGenericDef  # if this ever fails, we may just need to follow .genericTypeDef back iteratively until we get to the real generic type def
			return .genericTypeDef.constructedTypeFor(typeArgs)

	def cloneCollections
		base.cloneCollections
		_params = List<of IType>(_params)  # TODO: Can I just say _params.clone? Do I need the cast?
		if _constructedTypes
			_constructedTypes = Dictionary<of String, IType>(_constructedTypes)  # TODO: seems unlikely that a constructed type would want a copy of it's genericTypeDef's constructed type
		_baseInterfaceProxies = List<of ITypeProxy>(_baseInterfaceProxies)
		_baseInterfaces = List<of Interface>(_baseInterfaces)
		# _overloads = List<of MemberOverload>(_overloads)  # these will be recreated

	def typeForGenericParam(gp as GenericParam) as IType # TODO: is this needed for NilableType?
		"""
		Returns the specific type arg that corresponds to the given generic
		parameter. Used to match the gp's in method, properties, etc. against
		the actual types in a constructed type.
		"""
		require
			.isGeneric
			.params
		body
			# TODO: When does this get called? Investigate this.
			return .params[gp.index]

	get containsGenericParameters as bool
		for param in _params
			if param inherits GenericParam
				return true
			if param inherits Box  # CC: and <next if condition>
				if param.containsGenericParameters
					return true
		return false


	## Reading DLLs

	def _scanIsNames
		# TODO
		assert _isNames
		_isNames.add('fake')  # to make the box like the ones that were in SystemInterfaces.cobra

	def _scanImplements
		for interf in _clrType.getInterfaces
			if _badRelatedType(interf)
				continue
			_baseInterfaceProxies.add(ClrTypeProxy(interf))

	def _scanFields
		for fieldInfo in _clrType.getFields($sharp('BindingFlags.Instance|BindingFlags.Static|BindingFlags.DeclaredOnly|BindingFlags.Public'))
			if fieldInfo.declaringType is not _clrType
				continue
			if fieldInfo.isPrivate
				continue
			if fieldInfo.isInitOnly or fieldInfo.isLiteral
				# TODO: kind of weird to use properties
				isNames = ['nonvirtual']
				if fieldInfo.isPublic
					isNames.add('public')
				else
					isNames.add('private')
				if fieldInfo.isStatic
					isNames.add('shared')
				prop = Property(TokenFix.empty, this, Utils.uncapped(fieldInfo.name), _memberTypeProxy(fieldInfo.fieldType), isNames, '')
				prop.makeGetPart(TokenFix.empty)
				.addDecl(prop)
		
	def _scanInitializers
		for conInfo in _clrType.getConstructors  # TODO: get protected constructors
			if conInfo.declaringType is not _clrType
				continue
			skip = false
			for paramInfo in conInfo.getParameters
				if _badRelatedType(paramInfo.parameterType)
					skip = true
					break
			if skip
				continue
			params = _scanParams(conInfo.getParameters)
			isNames = _isNamesForMethodInfo(conInfo)
			docString = ''  # TODO: get doc string for class?
			initer = Constructor(TokenFix.empty, this, params, isNames, docString)
			overload as MemberOverload? = nil
			other = .memberForName('init')
			if other
				if other inherits MemberOverload
					overload = other
				else if other inherits AbstractMethod
					overload = MemberOverload(other)
					.registerOverload(overload to !)
				else
					throw FallThroughException([this, initer, other])
			if overload
				overload.addMember(initer)
			else
				.addDecl(initer)

	def _scanProperties
		for propInfo in _clrType.getProperties($sharp('BindingFlags.Instance|BindingFlags.Static|BindingFlags.DeclaredOnly|BindingFlags.Public|BindingFlags.NonPublic'))
			if propInfo.declaringType is not _clrType
				continue
			if propInfo.name == 'Item'
				_scanIndexer(propInfo)
				continue
			if _badRelatedType(propInfo.propertyType)
				continue
			# TODO: get attributes
			docString = ''  # TODO: get doc string for class?
			# TODO: eventually the isNames need to be an the property part level (get or set) rather than the property level, like in C# and the CLR runtime
			if propInfo.canRead
				isNames = _isNamesForMethodInfo(propInfo.getGetMethod(true) to !)
			else if propInfo.canWrite
				isNames = _isNamesForMethodInfo(propInfo.getSetMethod(true) to !)
			else
				throw FallThroughException(propInfo)
			prop = Property(TokenFix.empty, this, Utils.uncapped(propInfo.name), _memberTypeProxy(propInfo.propertyType), isNames, docString)
			if propInfo.canRead
				prop.makeGetPart(TokenFix.empty)
			if propInfo.canWrite
				prop.makeSetPart(TokenFix.empty)
			.addDecl(prop)

	def _scanIndexer(propInfo as PropertyInfo)
		for paramInfo in propInfo.getIndexParameters
			if _badRelatedType(paramInfo.parameterType)
				return
		params = _scanParams(propInfo.getIndexParameters)
		docString = ''  # TODO: get doc string for class?
		if propInfo.canRead
			isNames = _isNamesForMethodInfo(propInfo.getGetMethod(true) to !)
		else if propInfo.canWrite
			isNames = _isNamesForMethodInfo(propInfo.getSetMethod(true) to !)
		else
			throw FallThroughException(propInfo)
		indexer = Indexer(TokenFix.empty, this, r'[]', params, _memberTypeProxy(propInfo.propertyType), isNames, docString)
		overload as MemberOverload? = nil
		other = .memberForName(r'[]')
		if other
			if other inherits MemberOverload
				overload = other
			else if other inherits Indexer
				overload = MemberOverload(other)
				.registerOverload(overload to !)
			else
				throw FallThroughException([this, indexer, other])
		if overload
			overload.addMember(indexer)
		else
			.addDecl(indexer)

	def _scanMethods
		for methInfo in _clrType.getMethods($sharp('BindingFlags.Instance|BindingFlags.Static|BindingFlags.DeclaredOnly|BindingFlags.Public|BindingFlags.NonPublic'))
			if methInfo.isSpecialName
				continue
			if methInfo.isPrivate
				continue
			if methInfo.declaringType is not _clrType
				continue
			skip = false
			if _badRelatedType(methInfo.returnType)
				skip = true
			else
				for paramInfo in methInfo.getParameters
					if _badRelatedType(paramInfo.parameterType)
						skip = true
						break
			if skip
				continue
			# TODO: handle generic methods
			if methInfo.isGenericMethod or methInfo.isGenericMethodDefinition
				continue
			if '.' in methInfo.name
				# TODO: these are mostly (maybe all) explicit implementations of interfaces
				continue
			name = Utils.uncapped(methInfo.name)
			if name == 'init'
				# there is at least one of these: System.Runtime.Remoting.Messaging.MethodCall.init
				# TODO: What to do? Change 'def init' to 'def .init' or 'def .ctor'? No quadruple underscores.
				# or allow it in DLLs and use a different underlying name in the decl dict for constructors like the CLR name .ctor
				continue
			params = _scanParams(methInfo.getParameters)
			isNames = _isNamesForMethodInfo(methInfo)
			# TODO: get attributes
			docString = ''  # TODO: get doc string for class?
			implementsTypeNode as ITypeProxy?  # TODO: explicit interface implementation?
			method = Method(TokenFix.empty, this, name, params, _memberTypeProxy(methInfo.returnType), implementsTypeNode, isNames, docString)
			overload as MemberOverload? = nil
			other = .memberForName(name)
			if other
				if other inherits MemberOverload
					overload = other
				else if other inherits AbstractMethod
					overload = MemberOverload(other)
					.registerOverload(overload to !)
				else
					throw FallThroughException([this, method, other])
			if overload
				overload.addMember(method)
			else
				.addDecl(method)
	
	def _scanParams(paramInfos as ParameterInfo[]?) as List<of Param>
		"""
		Returns a list of Cobra parameters given a list of CLR Reflection ParameterInfos.
		"""
		params = List<of Param>()
		if paramInfos and paramInfos.length
			for paramInfo in paramInfos
				# TODO: vari args
				# TODO: out, inout
				params.add(Param(paramInfo.name, _memberTypeProxy(paramInfo.parameterType)))
		return params

	def _isNamesForMethodInfo(mi as MethodBase) as List<of String>
		"""
		Returns the Cobra "is names" such as ['public', 'nonvirtual'] that correspond to the properties of the CLR MethodInfo.
		"""
		isNames = List<of String>(8)
		if mi.isAbstract
			isNames.add('abstract')
		if mi.isFamily
			isNames.add('protected')
		# TODO: isFamilyAndAssembly, isFamilyOrAssembly
		if mi.isPrivate
			isNames.add('private')
		if mi.isPublic
			isNames.add('public')
		if mi.isStatic
			isNames.add('shared')
		if not mi.isVirtual
			isNames.add('nonvirtual')
		return isNames

	def _badRelatedType(t as Type?) as bool
		"""
		Returns true if the given type, which comes from a parameter or return value, is unsupported.
		For example, it's not public or it's nested. Members with bad types are skipped when scanning DLLs.
		"""
		if t is nil
			return false
		if t.isNested
			return true
		if t.isNotPublic
			return true
		return false

	def _memberTypeProxy(clrType as Type?) as ITypeProxy
		"""
		Returns a type proxy for a member type such as a parameter type or method return type.
		In CLR, reference types are nilable by default.
		"""
		if clrType is nil
			return .compiler.voidType
		else if clrType.isValueType
			return ClrTypeProxy(clrType)
		else
			return NilableTypeProxy(ClrTypeProxy(clrType))


	## Code gen

	get sharpKeyWord as String
		throw OverrideException(.getType)

	get sharpName as String is override
		return _name.replace('of', '')

	get _computeSharpRef as String is override
		if _params.count
			sb = StringBuilder()
			# generic
			name = .rootName
			sb.append(name)
			sb.append('<')
			sep = ''
			for param in _params
				sb.append(sep)
				sb.append(param.sharpRef)
				sep = ', '
			sb.append('>')
			sharp = sb.toString
		else
			sharp = .name
		if .parentNameSpace and not .parentNameSpace.isRoot
			sharp = .parentNameSpace.fullName + '.' + sharp
		return sharp

	def writeSharpDef(sw as SharpWriter)
		base.writeSharpDef(sw)
		if .isFake
			return
		assert not .isConstructed
		.writeSharpIsNames(sw)
		sw.write('[.sharpKeyWord] [.rootName]')
		if _params.count
			sw.write('<')
			sep = ''
			for param in _params
				sw.write(sep)
				param.writeSharpDef(sw)
				sep = ', '
			sw.write('>')

		.writeSharpInheritance(sw)

		sep = ''
		for inter in _baseInterfaces
			sw.write(sep)
			sw.write(inter.sharpRef)
			sep = ', '

		if _params.count
			sw.indent
			for param in _params
				if param inherits GenericParam
					param.writeSharpConstraint(sw)
			sw.dedent

		sw.writeAndIndent('{\n')
		if _testMethod
			_testMethod.writeSharpDef(sw)
		for decl in _declsInOrder
			decl.writeSharpDef(sw)
		.writeSharpTest(sw)
		sw.dedentAndWrite('} // [.sharpKeyWord] [.name]\n')
		sw.write('\n')

	def writeSharpInheritance(sw as SharpWriter)
		"""
		Class uses this to write its base class declaration.
		No box uses this to write interface implementation--that's handled in the Box class.
		"""
		pass

	def writeSharpTest(sw as SharpWriter)
		sw.write('\nstatic [.rootName]() { RunTestsIfNeeded(); }\n')
		sw.write('\nprivate static bool __didStartTests = false;\n')
		newWord = .newForSharpTest
		sw.write('\npublic static[newWord] void RunTestsIfNeeded() { if (!__didStartTests) RunTests(); }\n')
		sw.write('\npublic static[newWord] void RunTests()')
		sw.writeAndIndent(' {\n')
		sw.write('__didStartTests = true;\n')
		sw.write('CobraImp.TestBegan("[.name]");\n')
		if _testMethod
			sw.write('[_testMethod.sharpName]();\n')
		for decl in _declsInOrder
			decl.writeSharpTestInvocation(sw)
		sw.write('CobraImp.TestEnded("[.name]");\n')
		sw.dedentAndWrite('}\n')

	var _didWriteSharpTestInvocation = false

	def writeSharpTestInvocation(sw as SharpWriter) is override
		# used by the test option
		if _didWriteSharpTestInvocation
			return
		if .isFake
			return
		assert .parentNameSpace
		sw.write('\t\t[.qualifiedRootName].RunTestsIfNeeded();\n')
		_didWriteSharpTestInvocation = true

	get newForSharpTest as String
		return ''


class Class
	inherits Box

	var _baseNode as ITypeProxy?
	var _subclasses = List<of Class>()

	def init(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, baseNode as ITypeProxy?, implementsNodes as List<of ITypeProxy>, docString as String?)
		base.init(token, name, paramList, isNames, implementsNodes, docString)
		_baseNode = baseNode

	def init(clrType as Type)
		base.init(TokenFix.empty, clrType.name, List<of IType>(), List<of String>(), List<of ITypeProxy>(), nil)
		if clrType.baseType
			_baseNode = ClrTypeProxy(clrType.baseType)
		_clrType = clrType
		_needScanClrType = true

	def _scanClrType
		base._scanClrType
		_scanIsNames
		_scanImplements
		_scanFields
		_scanInitializers
		_scanProperties
		_scanMethods
		# TODO: _scanEnums
		# TODO: scan fields/vars
		# TODO: scan all other nested types

	def addSubFields
		base.addSubFields
		.addField('baseNode', _baseNode)

	get isCallable as bool is override
		return true
		
	def isDescendantOf(type as IType) as bool is override
		if not .baseClass and _baseNode
			.bindInt
		if .compiler
			type.bindInt
		if this is type
			return true
		if type inherits Interface
			if .isDescendantOfInterface(type)
				return true
		baseClass = .baseClass
		assert baseClass is not this, this  # check for direct cycles
		if baseClass
			return baseClass.isDescendantOf(type)
		else
			return false

	get isReference as bool is override
		return true

	get subclasses from var

	def memberForName(name as String) as IMember?
		# the next assertion fails for Tests\600-misc\404-implement-IEnumerable
		# could not fix. I'm confused. Something to do with generics. So bail on generics:
		# asserting .didBindInt is difficult because .memberForName gets invoked during bindInt
		# if not .isGeneric
		# 	assert .didBindInt  # TODO: is this legit? if so, push up to Container
		m = base.memberForName(name)
		if m is nil and _baseClass
			m = _baseClass.memberForName(name)
		if m is nil
			m = .interfaceMemberForName(name)
		# handle get/set parts like "someProp.get" or "[].set"
		# `computeMatchingBaseMember` in Members.cobra is at least one that returns this
		if m is nil and '.' in name
			if name.endsWith('.get')
				part = 'g'
			else if name.endsWith('.set')
				part = 's'
			else
				throw FallThroughException(name)
			pd = .memberForName(name[:-4])
			if pd inherits ProperDexer
				branch part
					on 'g'
						m = pd.getPart
					on 's'
						m = pd.setPart
				# TODO: cache the above back into the _decls
			# TODO: ? else, throw FallThroughException(...)
		return m

	def _completeConstructionOfBase(gpToType as Dictionary<of GenericParam, IType>)
		base._completeConstructionOfBase(gpToType)
		assert _baseClass
		_baseClass = _baseClass.secondaryConstructedTypeFor(this, gpToType) to Class

	def _bindBase is override
		if _baseNode
			_baseNode.bindInt
			possible = _baseNode.realType
			baseName = if(_baseNode inherits AbstractTypeIdentifier, (_baseNode to AbstractTypeIdentifier).name, nil)  # CC: if-inherits should work for expressions too
			if possible is nil
				assert baseName
				.throwError('Cannot locate base class named "[baseName]" for class "[_name]".')
			if possible inherits Class
				_baseClass = possible
			else if possible inherits Interface
				assert baseName
				.throwError('The base "[baseName]" is an interface. Try "implements" instead of "inherits".')
			else if possible inherits Struct
				assert baseName
				.throwError('The base "[baseName]" is a struct. Classes cannot inherit from structs.')
			else
				assert baseName
				.throwError('The base class "[baseName]" is not actually a class, it is a "[possible.englishName]".')
		else
			t = .compiler.libraryType('System', 'Object')
			if t inherits Class
				if this is not t  # don't want Object to inherit Object
					_baseClass = t
			else
				throw FallThroughException(t)
		if _baseClass
			_baseClass._subclasses.add(this)

	def _bindInt
		for decl in .declsInOrder
			if decl inherits Constructor
				foundConstructor = true
		if not foundConstructor
			# TODO: this should be changed to provide cover constructors for each of the public, inherited constructors
			.addDecl(Constructor(.token, this, List<of Param>(), ['public'], ''))
		# Note that the _baseClass is not told to bindInt. That would fail for classes in other namespaces and it's unnecessary s
		base._bindInt

	def _badInterfaceError(type as IType) is override
		msg = 'Cannot implement "[type.name]" which is a [type.englishName].'
		if type inherits Class
			msg += ' Use "inherits" instead.'
		.throwError(msg)

	def _finishOverloads
		# deal with inheritance and overloads
		assert _baseClass or _name=='Object'
		if _baseClass
			#assert _baseClass.didBindInt
			for decl in List<of IMember>(_declsInOrder)
				if decl inherits Method and not decl inherits Constructor
					other = _baseClass.memberForName(decl.name)
					if other
						if decl inherits MemberOverload
							overload = decl
						else if decl inherits BoxMember
							overload = MemberOverload(decl)
							.registerOverload(overload)
						else
							throw FallThroughException(decl)
						if other inherits MemberOverload
							for member in other.members
								assert not member inherits MemberOverload
								overload.addInheritedMember(member)
						else if other inherits BoxMember
							overload.addInheritedMember(other)
						else
							throw FallThroughException(other)
		base._finishOverloads

	get englishName as String is override
		return 'class'

	get superType as IType? is override
		assert .didBindInt
		return _baseClass

	## Code gen

	get csInit as String is override
		return 'null'

	get sharpKeyWord as String is override
		return 'class'

	def writeSharpInheritance(sw as SharpWriter) is override
		sw.write(' : ')
# axeqt
#		if _baseNode inherits TypeIdentifier
#			# needed QualifiedTypes such "inherits System.Collection.ArrayList". See Tests\300-misc\700-use-on-generice-IList
#			sw.write(_baseNode.actualType.sharpRef)
#			didWrite = true
#		else
		if _baseClass
			sw.write(_baseClass.sharpRef)
			didWrite = true
		if didWrite
			if _baseInterfaces.count
				sw.write(', ')
			else
				sw.write(' ')

	get newForSharpTest as String is override
		return if(not _baseClass.isFake, ' new', '')


class Interface
	inherits Box

	def init(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, baseNodes as List<of ITypeProxy>, docString as String?)
		base.init(token, name, paramList, isNames, baseNodes, docString)

	def init(clrType as Type)
		base.init(TokenFix.empty, clrType.name, List<of IType>(), List<of String>(), List<of ITypeProxy>(), nil)
		_clrType = clrType
		_needScanClrType = true

	def _scanClrType
		base._scanClrType
		_scanIsNames
		_scanImplements
		_scanFields
		_scanProperties
		_scanMethods

	get englishName as String is override
		return 'interface'

	get isReference as bool is override
		return true

	def isDescendantOf(type as IType) as bool is override
		if this is type
			return true
		if type inherits Interface
			if .isDescendantOfInterface(type)
				return true
		return false

	def memberForName(name as String) as IMember?
		m = base.memberForName(name)
		if m is nil
			m = .interfaceMemberForName(name)
			if m is nil and _baseClass
				m = _baseClass.memberForName(name)
		return m

	## Code gen

	get csInit as String is override
		return 'null'

	get sharpKeyWord as String is override
		return 'interface'

	def writeSharpInheritance(sw as SharpWriter) is override
		if _baseInterfaces.count
			sw.write(' : ')

	def writeSharpTest(sw as SharpWriter) is override
		# Static methods can't be put in interfaces. However, at some point Cobra should support
		# tests for interfaces which could then be run against the classes that implement them.
		# Just requires more code gen smarts.
		pass

	def writeSharpTestInvocation(sw as SharpWriter) is override
		pass


class Struct
	inherits Box

	def init(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, baseName as String?, interfaceNodes as List<of ITypeProxy>, docString as String?)
		base.init(token, name, paramList, isNames, interfaceNodes, docString)

	def init(clrType as Type)
		base.init(TokenFix.empty, clrType.name, List<of IType>(), List<of String>(), List<of ITypeProxy>(), nil)
		_clrType = clrType
		_needScanClrType = true

	def _scanClrType
		base._scanClrType
		_scanIsNames
		_scanImplements
		_scanFields
		_scanInitializers
		_scanProperties
		_scanMethods
		
	get isCallable as bool is override
		return true

	get isReference as bool is override
		return false

	def memberForName(name as String) as IMember?
		m = base.memberForName(name)
		if m is nil and _baseClass
			m = _baseClass.memberForName(name)
		return m

	## Code gen

	get sharpKeyWord as String is override
		return 'struct'

	get csInit as String is override
		return ''  # blank to indicate there is no valid init


class GenericParam
	inherits CobraType
	"""
	A generic parameter *is* a type.
	"""

	var _name as String
	var _constraints as List<of GenericConstraint>
	var _index as int
	var _objectClass as Class?

	def init(name as String)
		require name
		base.init
		_name = name
		_constraints = List<of GenericConstraint>()

	get name as String is override
		return _name

	get constraints from var

	pro index from var

	get isReference as bool is override
		# Well, it's hard to say if a GenericParam is a reference or value type, but CompareExpr() influences us to say "true".
		# TODO: if there are constraints on the generic param, examine them to determine answer
		return true

	def addMinFields
		base.addMinFields
		.addField('name', _name)

	def addSubFields
		base.addSubFields
		.addField('constraints', _constraints)
		.addField('index', _index)

	def declForName(name as String) as IMember? is override
		for constraint in _constraints
			decl = constraint.declForName(name)
			if decl
				return decl
		return _objectClass.declForName(name)

	def memberForName(name as String) as IMember? is override
		for constraint in _constraints
			member = constraint.memberForName(name)
			if member
				return member
		return _objectClass.memberForName(name)

	def isDescendantOf(type as IType) as bool is override
		if type is .compiler.libraryType('System', 'Object')
			return true
		if type.superType is nil  # the root type
			return true
		for constraint in _constraints
			if constraint.isDescendantOf(type)
				return true
		return false

	def secondaryConstructedTypeFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as IType is override
		assert gpToType.containsKey(this)
		return gpToType[this]

	def _bindInt
		base._bindInt
		_objectClass = .compiler.classType('System', 'Object')
		for constraint in _constraints
			constraint.bindInt

	get csInit as String is override
		return 'default([_name])'

	def writeSharpDef(sw as SharpWriter)
		base.writeSharpDef(sw)
		sw.write(.name)

	def writeSharpConstraint(sw as SharpWriter)
		if _constraints.count
			sw.write('where [_name] :  ')
			sep = ''
			for constraint in _constraints
				sw.write(sep)
				constraint.writeSharpDef(sw)
				sep = ', '
			sw.write('\n')


class GenericConstraint
	inherits SyntaxNode

	def init(token as IToken)
		base.init(token)

	def isDescendantOf(type as IType) as bool
		return false

	def declForName(name as String) as IMember?
		"""
		Returns nil by default.
		"""
		return nil

	def memberForName(name as String) as IMember?
		"""
		Returns nil by default.
		"""
		return nil

	def _bindInt
		base._bindInt


class GenericClassConstraint
	inherits GenericConstraint
	"""
	Represents the generic constraint class
	"""

	def init(token as IToken)
		base.init(token)

	def writeSharpDef(sw as SharpWriter) is override
		sw.write('class')


class GenericStructConstraint
	inherits GenericConstraint
	"""
	Represents the generic constraint class
	"""

	def init(token as IToken)
		base.init(token)

	def writeSharpDef(sw as SharpWriter) is override
		sw.write('struct')


class GenericCallableConstraint
	inherits GenericConstraint
	"""
	Represents the generic constraint callable
	"""

	def init(token as IToken)
		base.init(token)

	def writeSharpDef(sw as SharpWriter) is override
		sw.write('new()')


class GenericTypeConstraint
	inherits GenericConstraint
	"""
	Represents the generic constraint of a particular type.
	"""

	var _representedType as IType?
	var _typeNode as ITypeProxy

	def init(typeNode as ITypeProxy)
		base.init((typeNode to ISyntaxNode).token)  # CC: could be potential for making arg a compound interface ISyntaxNode+ITypeProxy from the 'Speculative' list
		_typeNode = typeNode

	def isDescendantOf(type as IType) as bool is override
		assert _representedType
		return _representedType.isDescendantOf(type)

# TODO?
#	def declForName(name as String) as IMember? is override
#		assert _representedType
#		return _representedType.declForName(name)

	def memberForName(name as String) as IMember? is override
		assert _representedType
		return _representedType.memberForName(name)

	def _bindInt
		base._bindInt
		if _representedType is nil
			_typeNode.bindInt
			_representedType = _typeNode.realType
			assert _representedType
		if not _representedType inherits Class and not _representedType inherits Interface
			.throwError('A generic type constraint must be a class or an interface. "[_representedType.name]" is not.')

	def writeSharpDef(sw as SharpWriter) is override
		sw.write(_representedType.sharpRef)
