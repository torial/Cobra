class Stmt
	inherits SyntaxNode

	def construct(token as IToken)
		base.construct(token)

	def afterParserRecognizesStatement
		pass

	def afterStatementBindImp
		"""
		Invoked to let expressions know when they are used as statements. This default
		implementation does nothing. Invoked by OneBlockCodeMember and BlockStmt.
		"""
		pass

	def noAssignmentAllowed(expr as Expr)
		"""
		Utility method for IfStmt and WhileStmt which do not allow assignment in
		their expressions.
		"""
		if expr inherits BinaryOpExpr
			if expr.op=='ASSIGN'
				_error('Cannot make an assignment in a flow control expression. Change to == or make the assignment just above.')
			else if expr.op=='BANG_EQUALS'
				_error('Cannot use an augmented assignment in a flow control expression. "a != b" means "a = a ! b" where "!" is an operator concerning nil. If you meant "does not equal" then use "<>".')
			else if expr.op.endsWith('_EQUALS')
				_error('Cannot use an augmented assignment in a flow control expression. Change to == or make the assignment just above.')

	def writeSharpStmt(sw as SharpWriter)
		.writeSharpDef(sw)


class AssertStmt
	inherits Stmt

	var _expr as Expr
	var _info as Expr?

	def construct(token as IToken, expr as Expr, info as Expr?)
		base.construct(token)
		_expr = TruthExpr(expr)
		_info = info

	def addSubFields is override
		base.addSubFields()
		.addField('expr', _expr)
		.addField('info', _info)

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		if _info
			_info.bindImp()

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write('if (!')
		_expr.writeSharpDef(sw)
		sw.write(') ')
		sw.indent()
		src = Utils.csStringLitFor(_expr.toCobraSource())
		fileName = Utils.csStringLitFor(.fileName)
		sw.write('throw new AssertException([fileName], [.lineNum], [src], ')
		if _info
			_info.writeSharpDef(sw)
		else
			sw.write('null')
		sw.write(');\n')
		sw.dedent()


class BranchStmt
	inherits Stmt

	var _expr as Expr
	var _onParts as List<of BranchOnPart>
	var _elsePart as BlockStmt?

	def construct(token as IToken, expr as Expr, onParts as List<of BranchOnPart>, elsePart as BlockStmt?)
		base.construct(token)
		_expr = expr
		_onParts = onParts
		_elsePart = elsePart

	def addSubFields is override
		base.addSubFields()
		.addField('expr', _expr)
		.addField('onParts', _onParts)
		.addField('elsePart', _elsePart)

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		for bop in _onParts
			bop.bindImp()
		if _elsePart
			_elsePart.bindImp()

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write('switch(')
		_expr.writeSharpDef(sw)
		sw.write(') {\n')
		sw.indent()
		for onPart in _onParts
			sep = ''
			for e in onPart.exprs
				sw.write(sep)
				sw.write('case ')
				e.writeSharpDef(sw)
				sw.write(': ')
				sep = '\n'
			onPart.block.writeSharpDef(sw)
			sw.write('break;\n')
		if _elsePart
			sw.write('default: ')
			_elsePart.writeSharpDef(sw)
			sw.write('break;\n')
		sw.dedent()
		sw.write('}\n')


class BranchOnPart
	inherits Node

	var _exprs as List<of Expr>
	var _block as BlockStmt

	def construct(exprs as List<of Expr>, block as BlockStmt)
		base.construct()
		_exprs = exprs
		_block = block

	def addSubFields is override
		base.addSubFields()
		.addField('exprs', _exprs)
		.addField('block', _block)

	get block from var

	get exprs from var

	def _bindImp is override
		base._bindImp()
		for expr in _exprs
			expr.bindImp()
		_block.bindImp()


class BlockStmt
	inherits Stmt
	"""
	A BlockStmt holds a series of statements which are the target of complex statement such
	if, while, etc. BlockStmts are *not* the target of a method or property.
	"""

	var _stmts as List<of Stmt>
	var _ifInheritsVar as IVar
	var _ifInheritsType as IType

	def construct(token as IToken, stmts as List<of Stmt>)
		base.construct(token)
		_stmts = stmts

	def addSubFields is override
		base.addSubFields()
		.addField('stmts', _stmts)

	def setIfInherits(varr as IVar, type as IType)
		_ifInheritsVar = varr
		_ifInheritsType = type

	def _bindImp is override
		base._bindImp()
		for stmt in _stmts
			stmt.bindImp()
			stmt.afterStatementBindImp()  # to let expressions know when they are used as statements
			# TODO: error recovery

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		.writeSharpDef(sw, true, nil)

	def writeSharpDef(sw as SharpWriter, close as bool)
		.writeSharpDef(sw, close, nil)

	def writeSharpDef(sw as SharpWriter, top as String?)
		.writeSharpDef(sw, true, top)

	def writeSharpDef(sw as SharpWriter, close as bool, top as String?)
		sw.node(this)
		sw.write(' {\n')
		sw.indent()
		if top
			sw.write(top)
		if _ifInheritsVar
			name = _ifInheritsVar.name
			strw = StringWriter()
			_ifInheritsType.writeSharpRef(SharpWriter(strw))
			typeName = strw.toString()
			newName = '_lh_' + name + '_' + typeName.replace('.', '_').replace('<', '_').replace('>', '_')  # replace() is needed for qualified types and generics
			sw.write('[typeName] [newName] = ([typeName])[name];\n')
			_ifInheritsVar.useCSNameStack.push(newName)
		for stmt in _stmts
			stmt.writeSharpStmt(sw)
		if _ifInheritsVar
			_ifInheritsVar.useCSNameStack.pop()
		if close
			sw.dedent()
			sw.write('}\n')


class BreakStmt
	inherits Stmt

	def construct(tok as IToken)
		base.construct(tok)

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write('break;\n')


class ContinueStmt
	inherits Stmt

	def construct(tok as IToken)
		base.construct(tok)

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write('continue;\n')


interface IVar
	inherits INamedNode
	# TODO: move to INode.cobra or somewhere else?

	pro type as IType?

	pro ifInheritsStack as Stack<of IType>

	get sharpName as String

	get useCSNameStack as Stack<of String>


class ExpectStmt
	inherits Stmt

	var _exceptionTypeNode as INode
	var _exceptionType as IType?
	var _block as BlockStmt
	var _varNumber as int

	def construct(token as IToken, exceptionTypeNode as INode, block as BlockStmt)
		base.construct(token)
		_exceptionTypeNode = exceptionTypeNode
		_block = block

	def addSubFields is override
		base.addSubFields()
		.addField('exceptionTypeNode', _exceptionTypeNode)
		.addField('exceptionType', _exceptionType)
		.addField('block', _block)

	def _bindImp is override
		base._bindImp()
		if _exceptionType is nil and _exceptionTypeNode
			_exceptionType = _exceptionTypeNode.bindAll().namedType
		assert _exceptionType, this
		excClass = .compiler.libraryType('System', 'Exception')
		assert excClass
		if not _exceptionType.isDescendantOf(excClass)
			_error('Can only use Exception and its descendants for "expect". "[_exceptionType.name]" does not inherit the Exception class.')
		# TODO: take out the following stmt. looks like duplicate of statement afterwards
		.compiler.curBox.makeNextPrivateSerialNumber()
		_varNumber = .compiler.curBox.makeNextPrivateSerialNumber()
		_block.bindImp()

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		gotWriteExceptionVarName = '_lh_expect_[_varNumber-1]'  # lh => "local helper"
		sw.write('bool [gotWriteExceptionVarName] = false;\n')
		sw.write('try ')
		_block.writeSharpDef(sw)
		sw.writeAndIndent('catch (')
		_exceptionType.writeSharpRef(sw)
		sw.write(') {\n')
		sw.write('// exactly what is expected\n')
		sw.write('[gotWriteExceptionVarName] = true;\n')
		sw.dedentAndWrite('}\n')
		wrongExceptionVarName = '_lh_expect_[_varNumber]'
		assert gotWriteExceptionVarName<>wrongExceptionVarName
		sw.writeAndIndent('catch (Exception [wrongExceptionVarName]) {\n')
		sw.write('throw new ExpectException(typeof(')
		_exceptionType.writeSharpRef(sw)
		sw.write('), [wrongExceptionVarName]);\n')
		sw.dedentAndWrite('}\n')
		sw.write('if (![gotWriteExceptionVarName]) throw new ExpectException(typeof(')
		_exceptionType.writeSharpRef(sw)
		sw.write('), null);\n')


class ForStmt
	inherits Stmt
	"""
	Abstract base class for ForNumericStmt and ForEnumerablebase.
	"""

	var _var as IVar
	var _block as BlockStmt

	def construct(token as IToken, varr as IVar, block as BlockStmt)
		base.construct(token)
		_var = varr
		_block = block

	def addSubFields is override
		base.addSubFields()
		.addField('var', _var)

	def _bindImp is override
		base._bindImp()
		varr = _var
		#if not var.isTracked  TODO disabled this to get tests\200-classes\804-test.cobra working.
# TODO: check for existing  variables
#		if 1
#			ns = .compiler.nameSpaceStack.peek()
#			existingVar = ns.findLocal(varr.name)
#			if existingVar
#				# that's fine as long as the types are the name
#				if varr.type is .compiler.passThroughType
#					varr.type = existingVar.type
#				else if existingVar.type is not varr.type
#					.error('Cannot redeclare "[varr.name]" as "[varr.type]" because it was declared as "[existingVar.type]" earlier.')
#			else
#				.compiler.nameStack.peek().pushName(varr)   # TODO should be pushSymbol() or pushVar()
		varr.bindAll()  # CallExpr() wants its definition to have bound int, so here we call bindAll() instead of bindImp()
		_block.bindImp()
		# TODO axe this
		#if not varr.isTracked
		#	.compiler.nameStack.peek().pop()   # TODO should be popSymbol() or popVar()


class ForNumericStmt
	inherits ForStmt

	var _start as Expr
	var _stop as Expr
	var _dir as int
	var _step as Expr?

	def construct(token as IToken, varr as IVar, start as Expr, stopp as Expr, dir as int, stepp as Expr?, block as BlockStmt)
		require
			true # dir==-1 or dir==+1
		code
			base.construct(token, varr, block)
			_start = start
			_stop = stopp
			_dir = dir
			_step = stepp

	def addSubFields is override
		base.addSubFields()
		.addField('start', _start)
		.addField('stop', _stop)
		.addField('dir', _dir)
		.addField('step', _step)
		.addField('block', _block)

	def _bindImp is override
		varr  = _var
		start = _start
		stopp = _stop
		stepp = _step
		start.bindImp()
		stopp.bindImp()
		if stepp
			stepp.bindImp()
		passThrough = .compiler.passThroughType
		if varr.type is .compiler.unspecifiedType
			# type inference
			if start.type is stopp.type
				varr.type = start.type
			else if stopp.type is passThrough  and  start.type is not passThrough
				varr.type = start.type
			else if start.type is passThrough  and  stopp.type is not passThrough
				varr.type = stopp.type
			else
				# TODO find the greatest common denominator between two types
				_error('Cannot determine type of for loop variable "[varr.name]".')
		base._bindImp()
		_block.bindImp()

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		csVar = _var.sharpName
		sw.write('for ([csVar]=')
		_start.writeSharpDef(sw)
		sw.write('; [csVar]')
		if _dir==1
			sw.write('<')
		else
			sw.write('>')
		_stop.writeSharpDef(sw)
		sw.write('; ')
		if _step
			if _dir==1
				sw.write('[csVar]+=')
			else
				sw.write('[csVar]-=')
			_step.writeSharpDef(sw)
		else
			if _dir==1
				sw.write('[csVar]++')
			else
				sw.write('[csVar]--')
		sw.write(')')
		_block.writeSharpDef(sw)


class ForEnumerableStmt
	inherits ForStmt

	var _what as Expr
	var _varNumber as int

	def construct(token as IToken, varr as IVar, what as Expr, block as BlockStmt)
		base.construct(token, varr, block)
		_what = what

	def addSubFields is override
		base.addSubFields()
		.addField('_what', _what)
		.addField('_block', _block)

	def _bindImp is override
		_what.bindImp()
		varr = _var
		if varr.type is .compiler.unspecifiedType
			# type inference
			t = _what.type.innerType
			if t is nil
				_error('Cannot enumerate a [_what.type.name].')
			varr.type = t
		base._bindImp()
		_varNumber = .compiler.curBox.makeNextPrivateSerialNumber()
		_block.bindImp()

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		# in a C# foreach, (1) you must declare a new variable, (2) you cannot reassign it and (3) you cannot access it after the loop
		# these constraints don't exist in Cobra
		helperName = '_lh_for_[_var.name]_[_varNumber]'
		sw.write('foreach (')
		_var.type.writeSharpRef(sw)
		sw.write(' [helperName] in ')
		_what.writeSharpDef(sw, false)
		sw.write(')')  ###
		_block.writeSharpDef(sw, top='[_var.sharpName] = [helperName];\n')


class IfStmt
	inherits Stmt

	var _cond as Expr
	var _trueStmts as BlockStmt
	var _falseStmts as BlockStmt?

	def construct(token as IToken, cond as Expr, trueStmts as BlockStmt, falseStmts as BlockStmt?)
		base.construct(token)
		_cond = cond
		_trueStmts  = trueStmts
		_falseStmts = falseStmts

	def addSubFields is override
		base.addSubFields()
		.addField('cond', _cond)
		.addField('trueStmts', _trueStmts)
		.addField('falseStmts', _falseStmts)

	def _bindImp is override
		base._bindImp()
		_cond.bindImp()
		.noAssignmentAllowed(_cond)
		if _cond.type is not .compiler.boolType
			_cond = TruthExpr(_cond).bindImp() to TruthExpr  # CC: axe cast when supporting 'as this'
		cond = _cond
		ifInherits = false
		# TODO: handle the "x inherits Y" being part of a string of "and"ed exprs
		# CC: combine some of the if statements below when "if inherits" can handle complex expressions
		if cond inherits InheritsExpr
			left = cond.left
			if left inherits IdentifierExpr
				leftVar = left.definition
				if leftVar inherits IVar  # if-inherits smarts only work on variables
					# if x inherits y ...
					assert cond.right.namedType, cond.right
					leftVar.ifInheritsStack.push(cond.right.namedType)
					ifInherits = true
					_trueStmts.setIfInherits(leftVar, leftVar.ifInheritsStack.peek())
		if not ifInherits
			if cond inherits TruthExpr
				if cond.expr inherits IdentifierExpr
					leftVar = (cond.expr to IdentifierExpr).definition
					if leftVar.typeForIdentifier inherits NilableType
						# if x ...
						notNil = true
		if not ifInherits and not notNil
			if cond inherits CompareExpr
				if cond.op in ['ISNOT', 'NE'] and cond.left inherits IdentifierExpr and cond.right inherits NilLiteral
					# if x is not nil ...
					# if x <> nil ...
					# TODO: also handle "if nil is not x"
					# TODO? "if not x is nil"  "if nil is not x"
					notNil = true
					leftVar = (cond.left to IdentifierExpr).definition
		if notNil
			if leftVar inherits IVar
				leftVar.ifInheritsStack.push((leftVar.type to WrappedType).theWrappedType)
			else
				throw FallThroughException(leftVar)
			ifInherits = true
		if ifInherits
			if leftVar inherits IVar
				_trueStmts.setIfInherits(leftVar, leftVar.ifInheritsStack.peek())
			else
				throw FallThroughException(leftVar)
		_trueStmts.bindImp()
		if ifInherits
			if leftVar inherits IVar  # CC: put with above "if" via "and" once "if inherits" is smart enough
				leftVar.ifInheritsStack.pop()
		if _falseStmts is not nil
			_falseStmts.bindImp()

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write('if (')
		_cond.writeSharpDef(sw, false)
		sw.write(')')
		_trueStmts.writeSharpDef(sw, false)
		sw.dedent()
		if _falseStmts
			sw.write('} else')
			_falseStmts.writeSharpDef(sw, false)
			sw.dedent()
		sw.write('}\n')


class PrintStmt
	inherits Stmt

	var _destination as Expr?
	var _args as List<of Expr>
	var _stop as bool

	def construct(token as IToken, destination as Expr?, args as List<of Expr>, stopp as bool)
		base.construct(token)
		_destination = destination
		_args = args
		_stop = stopp

	def _bindImp is override
		base._bindImp()
		if _destination!
			_destination.bindImp()
		for arg in _args
			arg.bindImp()

	def addSubFields is override
		base.addSubFields()
		.addField('stop', _stop)
		.addField('destination', _destination)
		.addField('args', _args)

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		if _destination
			sw.write('(')
			_destination.writeSharpDef(sw)
			methodName = if(_stop, 'Write', 'WriteLine')
			sw.write(').[methodName](')
		else
			methodName = if(_stop, 'PrintStop', 'PrintLine')
			sw.write('CobraImp.[methodName](')
		sep = ''
		for arg in _args
			sw.write(sep)
			if arg.isKindOf(.compiler.libraryType('System', 'String'))
				sw.write('(')
			else
				sw.write('CobraImp.ToString(')
			arg.writeSharpDef(sw)
			sw.write(')')
			sep = '+'
		sw.write(');\n')


class PrintRedirectStmt
	inherits Stmt

	var _destination as Expr
	var _block as BlockStmt

	def construct(token as IToken, destination as Expr, block as BlockStmt)
		base.construct(token)
		_destination = destination
		_block = block

	def _bindImp is override
		base._bindImp()
		_destination.bindImp()
		_block.bindImp()

	def addSubFields is override
		base.addSubFields()
		.addField('destination', _destination)
		.addField('block', _block)

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write('CobraImp.PushPrintTo(')
		_destination.writeSharpDef(sw, false)
		sw.write(');\n')
		sw.write('try')
		_block.writeSharpDef(sw)
		sw.write('finally {\n')
		sw.indent()
		sw.write('CobraImp.PopPrintTo();\n')
		sw.dedent()
		sw.write('}\n')


class ReturnStmt
	inherits Stmt

	var _expr as Expr?
	var _csResultVarName as String?

	def construct(token as IToken, expr as Expr?)
		base.construct(token)
		_expr = expr

	def addSubFields is override
		base.addSubFields()
		.addField('expr', _expr)

	pro csResultVarName from var

	def _bindImp is override
		base._bindImp()
		expr = _expr
		curCodeMember = .compiler.codeMemberStack.peek()
		if expr
			_expr.bindImp()
			if not expr.canBeAssignedTo(curCodeMember.resultType)
				_error('Cannot return [expr.type.name] because "[curCodeMember.name]" is declared to return a [curCodeMember.resultType.name].')
		else
			if curCodeMember.resultType is not .compiler.voidType
				_error('Return statement must return a [curCodeMember.resultType.name], or [curCodeMember.name] must have its return type removed.')
		curCodeMember.hasReturnStmt = true
		# TODO _csResultVarName = curCodeMember.csResultVarName

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		if _expr
			if _csResultVarName
				sw.write('return [_csResultVarName]=')
				_expr.writeSharpDef(sw, false)
				sw.write(';\n')
			else
				sw.write('return ')
				_expr.writeSharpDef(sw, false)
				sw.write(';\n')
		else
			sw.write('return;\n')

class TryStmt
	inherits Stmt

	var _tryBlock as BlockStmt
	var _catchBlocks as List<of CatchBlock>
	var _successBlock as BlockStmt?
	var _finallyBlock as BlockStmt?
	var _varNumber as int

	def construct(token as IToken, tryBlock as BlockStmt, catchBlocks as List<of CatchBlock>, successBlock as BlockStmt?, finallyBlock as BlockStmt?)
		base.construct(token)
		_tryBlock = tryBlock
		_catchBlocks = catchBlocks
		_successBlock = successBlock
		_finallyBlock = finallyBlock

	def addSubFields is override
		base.addSubFields()
		.addField('tryBlock', _tryBlock)
		.addField('catchBlock', _catchBlocks)
		.addField('succesBlock', _successBlock)
		.addField('finallyBlock', _finallyBlock)

	def _bindImp is override
		base._bindImp()
		_varNumber = .compiler.curBox.makeNextPrivateSerialNumber()
		_tryBlock.bindImp()
		for eb in _catchBlocks
			eb.bindImp()
		if _successBlock
			_successBlock.bindImp()
		if _finallyBlock
			_finallyBlock.bindImp()

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		if _successBlock
			# C# has no "success" (or in Python, "else") block for the "try" statement
			# so it has to be simulated
			helperName = '_lh_success_[_varNumber]'
			sw.write('bool [helperName] = false;\n')
			if _finallyBlock
				sw.write('try {\n')
				sw.indent()
			sw.write('try')
			_tryBlock.writeSharpDef(sw, false)
			sw.write('[helperName] = true;\n')
			sw.dedent()
			sw.write('}\n')
			if _catchBlocks
				.writeCatchBlocks(sw)
			else
				sw.write('finally { }\n')  # syntactically necessary
			sw.write('if ([helperName])')
			_successBlock.writeSharpDef(sw)
			if _finallyBlock
				sw.dedent()
				sw.write('}\n')
				sw.write('finally')
				_finallyBlock.writeSharpDef(sw)
		else
			sw.write('try')
			_tryBlock.writeSharpDef(sw)
			.writeCatchBlocks(sw)
			if _finallyBlock
				sw.write('finally')
				_finallyBlock.writeSharpDef(sw)

	def writeCatchBlocks(sw as SharpWriter)
		for eb in _catchBlocks
			sw.write('catch')
			if eb.type
				sw.write(' (')
				eb.type.writeSharpRef(sw)
				if eb.varName
					helperName = eb.csHelperName
					sw.write(' [helperName]')
				sw.write(')')
			top = if(eb.varName, '[eb.varName] = [helperName];\n', '')
			eb.block.writeSharpDef(sw, top)


class CatchBlock
	inherits SyntaxNode

	var _var as AbstractLocalVar?
	var _type as IType?
	var _block as BlockStmt
	var _varName as String?
	var _csHelperName as String

	def construct(token as IToken, block as BlockStmt)
		"""
		This is for `success`, `finally` and typeless `catch` blocks.
		"""
		base.construct(token)
		_block = block

	def construct(token as IToken, varr as AbstractLocalVar, block as BlockStmt)
		"""
		This is for `catch` blocks that specify a type and variable.
		"""
		base.construct(token)
		_var = varr
		_varName = if(varr, varr.name, nil)
		_block = block

	get block from var

	get type from var

	get varName from var

	def _bindImp is override
		base._bindImp()
		if _var
			_var.bindImp()
			if not _var.isTracked
				varr = _var to LocalVar  # CC: axe typecast
				codePart = .compiler.codeMemberStack.peek()
				existingVar = codePart.findLocal(varr.name)
				if existingVar
					if existingVar.type is not varr.type
						_error('Cannot redeclare "[varr.name]" as "[varr.type]" because it was declared as "[existingVar.type]" earlier.')
				else
					codePart.addLocal(varr)
			if _type is nil
				_type = _var.type
				assert _type
		_csHelperName = '_lh_catch_[.compiler.curBox.makeNextPrivateSerialNumber()]'
		_block.bindImp()

	## Code gen

	get csHelperName from var


class ThrowStmt
	inherits Stmt

	var _expr as Expr?

	def construct(token as IToken, expr as Expr?)
		base.construct(token)
		_expr = expr

	def addSubFields is override
		base.addSubFields()
		.addField('expr', '_expr')

	def _bindImp is override
		base._bindImp()
		if _expr
			_expr.bindImp()

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write('throw ')
		if _expr
			_expr.writeSharpDef(sw, false)
		sw.write(';\n')


class UsingStmt
	inherits Stmt

	var _var as AbstractLocalVar
	var _initExpr as Expr
	var _block as BlockStmt

	def construct(token as IToken, varr as AbstractLocalVar, initExpr as Expr, block as BlockStmt)
		base.construct(token)
		_var = varr
		_initExpr = initExpr
		_block = block

	def _bindImp is override
		base._bindImp()
		_initExpr.bindImp()
		varr = _var
		if varr.type is .compiler.unspecifiedType
			t = _initExpr.type
			if t
				varr.type = t
			else
				assert false, 'no type for initExpr [_initExpr]'
		# TODO: add an error check that the var type and expr type are compatible
		varr.bindImp()
		if .compiler.findLocal(varr.name) is not varr
			if varr inherits LocalVar
				.compiler.codeMemberStack.peek().addLocal(varr)
			else
				assert false, 'expecting varr to be a LocalVar. varr=[varr]'
		_block.bindImp()

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		name = _var.sharpName
		sw.write('// using\n')
		sw.write('[name] = ')
		_initExpr.writeSharpDef(sw)
		sw.write(';\ntry')
		_block.writeSharpDef(sw)
		sw.write('finally {\n')
		sw.indent()
		if _var.type.isReference
			sw.write('if ([name]!=null) { ((IDisposable)[name]).Dispose(); [name] = null; }\n')
		else
			sw.write('((IDisposable)[name]).Dispose();\n')
		sw.dedentAndWrite('}\n')


class WhileStmt
	inherits Stmt

	var _expr as Expr
	var _block as BlockStmt

	def construct(token as IToken, expr as Expr, block as BlockStmt)
		base.construct(token)
		_expr = expr
		_block = block

	def addSubFields is override
		base.addSubFields()
		.addField('expr', _expr)
		.addField('block', _block)

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		.noAssignmentAllowed(_expr)
		if _expr.type is not .compiler.boolType
			_expr = TruthExpr(_expr).bindImp() to TruthExpr  # CC: axe when I have "as this"
		_block.bindImp()

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write('while (')
		_expr.writeSharpDef(sw, false)
		sw.write(')')
		_block.writeSharpDef(sw)


class PostWhileStmt
	inherits WhileStmt

	def construct(token as IToken, expr as Expr, block as BlockStmt)
		base.construct(token, expr, block)

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.write('do')
		_block.writeSharpDef(sw, false)
		sw.dedent()
		sw.write('} while (')
		_expr.writeSharpDef(sw, false)
		sw.write(');\n')
