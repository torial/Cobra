class Stmt
	inherits SyntaxNode

	def construct(token as IToken)
		base.construct(token)

	def afterParserRecognizesStatement
		pass


class AssertStmt
	inherits Stmt

	var _expr as Expr
	var _info as Expr?

	def construct(token as IToken, expr as Expr, info as Expr?)
		base.construct(token)
		_expr = TruthExpr(expr)
		_info = info

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		if _info
			_info.bindImp()

#	def genCS(out):
#		Stmt.genCS(out)
#		out.write('if (!')
#		.expr.genCS(out)
#		out.write(') ')
#		out.indent()
#		s = .expr.toCobraSource()
#		s = .csStringLitFor(s)
#		out.write('throw new AssertException(%s, %s, %s, ' % (.csStringLitFor(.fileName), .lineNumber, s))
#		if .info:
#			.info.genCS(out)
#		else:
#			out.write('null')
#		out.write(');\n')
#		out.dedent()


class BranchStmt
	inherits Stmt

	var _expr as Expr
	var _onParts as List<of BranchOnPart>
	var _elsePart as BlockStmt?

	def construct(token as IToken, expr as Expr, onParts as List<of BranchOnPart>, elsePart as BlockStmt?)
		base.construct(token)
		_expr = expr
		_onParts = onParts
		_elsePart = elsePart

	def addSubFields is override
		base.addSubFields()
		.addField('expr', _expr)
		.addField('onParts', _onParts)
		.addField('elsePart', _elsePart)

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		for bop in _onParts
			bop.bindImp()
		if _elsePart
			_elsePart.bindImp()

#	def genCS(out)
#		base.genCS(out)
#		out.write('switch(')
#		_expr.genCS(out)
#		out.write(') {\n')
#		out.indent()
#		for onPart in _onParts
#			sep = ''
#			for e in onPart.exprs
#				out.write(sep)
#				out.write('case ')
#				e.genCS(out)
#				out.write(' ')
#				sep = '\n'
#			onPart.block.genCS(out)
#			out.write('break;\n')
#		if _elsePart
#			out.write('default ')
#			_elsePart.genCS(out)
#			out.write('break;\n')
#		out.dedent()
#		out.write('}\n')


class BranchOnPart
	inherits Node

	var _exprs as List<of Expr>
	var _block as BlockStmt

	def construct(exprs as List<of Expr>, block as BlockStmt)
		base.construct()
		_exprs = exprs
		_block = block

	def addSubFields is override
		base.addSubFields()
		.addField('exprs', _exprs)
		.addField('block', _block)

	def _bindImp is override
		base._bindImp()
		for expr in _exprs
			expr.bindImp()
		_block.bindImp()


class BlockStmt
	inherits Stmt
	"""
	A BlockStmt holds a series of statements which are the target of complex statement such
	if, while, etc. BlockStmts are *not* the target of a method or property.
	"""

	var _stmts as List<of Stmt>

	def construct(token as IToken, stmts as List<of Stmt>)
		base.construct(token)
		_stmts = stmts

	def addSubFields is override
		base.addSubFields()
		.addField('stmts', _stmts)

	def _bindImp is override
		base._bindImp()
		for stmt in _stmts
			stmt.bindImp()


interface IVar
	inherits INamedNode
	# TODO: move to INode.cobra or somewhere else?

	pro type as IType?


class ForStmt
	inherits Stmt
	"""
	Abstract base class for ForNumericStmt and ForEnumerablebase.
	"""

	var _var as IVar
	var _block as BlockStmt

	def construct(token as IToken, varr as IVar, block as BlockStmt)
		base.construct(token)
		_var = varr
		_block = block

	def addSubFields is override
		base.addSubFields()
		.addField('var', _var)

	def _bindImp is override
		base._bindImp()
		varr = _var
		#if not var.isTracked  TODO disabled this to get tests\200-classes\804-test.cobra working.
		if 1
			ns = .compiler.nameSpaceStack.peek()
# TODO: check for existing  variables
#			existingVar = ns.findLocal(varr.name)
#			if existingVar
#				# that's fine as long as the types are the name
#				if varr.type is .compiler.passThroughType
#					varr.type = existingVar.type
#				else if existingVar.type is not varr.type
#					.error('Cannot redeclare "[varr.name]" as "[varr.type]" because it was declared as "[existingVar.type]" earlier.')
#			else
#				.compiler.nameStack.peek().pushName(varr)   # TODO should be pushSymbol() or pushVar()
		varr.bindAll()  # CallExpr() wants its definition to have bound int, so here we call bindAll() instead of bindImp()
		_block.bindImp()
		# TODO axe this
		#if not varr.isTracked
		#	.compiler.nameStack.peek().pop()   # TODO should be popSymbol() or popVar()


class ForNumericStmt
	inherits ForStmt

	var _start as Expr
	var _stop as Expr
	var _dir as int
	var _step as Expr?

	def construct(token as IToken, varr as IVar, start as Expr, stopp as Expr, dir as int, stepp as Expr?, block as BlockStmt)
		require
			true # dir==-1 or dir==+1
		code
			base.construct(token, varr, block)
			_start = start
			_stop = stopp
			_dir = dir
			_step = stepp

	def addSubFields is override
		base.addSubFields()
		.addField('start', _start)
		.addField('stop', _stop)
		.addField('dir', _dir)
		.addField('step', _step)
		.addField('block', _block)

	def _bindImp is override
		varr  = _var
		start = _start
		stopp = _stop
		stepp = _step
		start.bindImp()
		stopp.bindImp()
		if stepp
			stepp.bindImp()
		passThrough = .compiler.passThroughType
		if varr.type is nil
			if start.type is stopp.type
				varr.type = start.type
			else if stopp.type is passThrough  and  start.type is not passThrough
				varr.type = start.type
			else if start.type is passThrough  and  stopp.type is not passThrough
				varr.type = stopp.type
			else
				# TODO find the greatest common denominator between two types
				_error('Cannot determine type of for loop variable "[varr.name]".')
		base._bindImp()
		_block.bindImp()

#	def genCS(out)
#		base.genCS(out)
#		csVar = _var.asCS()
#		wr = out.write
#		#wr('for (%s %s=' % (_var.type.asCS(), csVar))
#		wr('for (%s=' % csVar)
#		_start.genCS(out)
#		wr('; %s' % csVar)
#		if .dir==1
#			wr('<')
#		else
#			wr('>')
#		_stop.genCS(out)
#		wr('; ')
#		if _step
#			if .dir==1
#				wr('%s+=' % csVar)
#			else
#				wr('%s-=' % csVar)
#			_step.genCS(out)
#		else
#			if .dir==1
#				wr('%s++' % csVar)
#			else
#				wr('%s--' % csVar)
#		wr(')')
#		_block.genCS(out)


class ForEnumerableStmt
	inherits ForStmt

	var _what as Expr
	var _varNumber as int

	def construct(token as IToken, varr as IVar, what as Expr, block as BlockStmt)
		base.construct(token, varr, block)
		_what = what

	def addSubFields is override
		base.addSubFields()
		.addField('_what', _what)
		.addField('_block', _block)

	def _bindImp is override
		_what.bindImp()
		varr = _var
		if varr.type is nil
			if _what.type is .compiler.passThroughType
				varr.type = .compiler.passThroughType
			else
				varr.type = _what.type.innerType
				if varr.type is nil
					_error('Cannot enumerate a [_what.type].')
		base._bindImp()
		_varNumber = .compiler.curBox.makeNextPrivateSerialNumber()
		_block.bindImp()

#	def genCS(out)
#		base.genCS(out)
#		# in a C# foreach, (1) you must declare a new variable, (2) you cannot reassign it and (3) you cannot access it after the loop
#		# these constraints don't exist in Cobra
#		helperName = '_lh_for_%s_%s' % (_var.name, _varNumber)
#		out.write('foreach (%s %s in ' % (_var.type.asCS(), helperName))
#		.what.genCS(out, genParens=false)
#		out.write(')')
#		_block.genCS(out, top='%s = %s;\n' % (_var.asCS(), helperName))


class IfStmt
	inherits Stmt

	var _cond as Expr
	var _trueStmts as BlockStmt
	var _falseStmts as BlockStmt?

	def construct(token as IToken, cond as Expr, trueStmts as BlockStmt, falseStmts as BlockStmt?)
		base.construct(token)
		_cond = cond
		_trueStmts  = trueStmts
		_falseStmts = falseStmts

	def addSubFields is override
		base.addSubFields()
		.addField('cond', _cond)
		.addField('trueStmts', _trueStmts)
		.addField('falseStmts', _falseStmts)

	def _bindImp is override
		base._bindImp()
		_cond.bindImp()
# TODO:		.noAssignmentAllowed(_cond)
# TODO: truthfulness
#		if _cond.type is not tbool
#			_cond = TruthExpr(_cond).bindImp()
		cond = _cond
# TODO: if-inherits
#		ifInherits = false
#		if inherits(cond, BinaryOpExpr) and cond.op=='INHERITS' and inherits(cond.left, IdentifierExpr)
#			leftVar = cond.left.definition
#			leftVar.ifInheritsStack.push(cond.right.namedType)
#			ifInherits = true
#			_trueStmts.setIfInherits(leftVar, leftVar.ifInheritsStack.peek())
		_trueStmts.bindImp()
#		if ifInherits
#			leftVar.ifInheritsStack.pop()
		if _falseStmts is not nil
			_falseStmts.bindImp()

#	def genCS(out)
#		Stmt.genCS(out)
#		out.write('if (')
#		_cond.genCS(out, genParens=false)
#		out.write(')')
#		_trueStmts.genCS(out, close=false)
#		out.dedent()
#		if _falseStmts
#			out.write('} else')
#			_falseStmts.genCS(out, close=false)
#			out.dedent()
#		out.write('}\n')


class PrintStmt
	inherits Stmt

	var _destination as Expr?
	var _args as List<of Expr>
	var _stopp as bool

	def construct(token as IToken, destination as Expr?, args as List<of Expr>, stopp as bool)
		base.construct(token)
		_destination = destination
		_args = args
		_stopp = stopp

	def _bindImp is override
		base._bindImp()
		if _destination!
			_destination.bindImp()
		for arg in _args
			arg.bindImp()

	def addSubFields is override
		base.addSubFields()
		.addField('stopp', _stopp)
		.addField('destination', _destination)
		.addField('args', _args)

#	def genCS(out):
#		Stmt.genCS(out)
#		if .destination:
#			out.write('(')
#			.destination.genCS(out)
#			out.write(').%s(' % (_stop and 'Write' or 'WriteLine'))
#		else:
#			out.write('CobraImp.%s(' % (_stop and 'PrintStop' or 'PrintLine'))
#		sep = ''
#		for arg in _args:
#			out.write(sep)
#			if arg.type.isStringClass:
#				out.write('(')
#			else:
#				out.write('CobraImp.ToString(')
#			arg.genCS(out)
#			out.write(')')
#			sep = '+'
#		out.write(');\n')


class PrintRedirectStmt
	inherits Stmt

	var _destination as Expr
	var _block as BlockStmt

	def construct(token as IToken, destination as Expr, block as BlockStmt)
		base.construct(token)
		_destination = destination
		_block = block

	def _bindImp is override
		base._bindImp()
		_destination.bindImp()
		_block.bindImp()

	def addSubFields is override
		base.addSubFields()
		.addField('destination', _destination)
		.addField('block', _block)

#	def genCS(out):
#		Stmt.genCS(out)
#		out.write('CobraImp.PushPrintTo(')
#		_destination.genCS(out, genParens=false)
#		out.write(');\n')
#		out.write('try')
#		_stmts.genCS(out)
#		out.write('finally {\n')
#		out.indent()
#		out.write('CobraImp.PopPrintTo();\n')
#		out.dedent()
#		out.write('}\n')


class ReturnStmt
	inherits Stmt

	def construct(token as IToken, expr as Expr?)
		base.construct(token)
		pass


class TryStmt
	inherits Stmt

	var _tryBlock as BlockStmt
	var _exceptBlocks as List<of ExceptBlock>  # TODO: Rename to _catchBlocks
	var _successBlock as BlockStmt?
	var _finallyBlock as BlockStmt?
	var _varNumber as int

	def construct(token as IToken, tryBlock as BlockStmt, exceptBlocks as List<of ExceptBlock>, successBlock as BlockStmt?, finallyBlock as BlockStmt?)
		base.construct(token)
		_tryBlock = tryBlock
		_exceptBlocks = exceptBlocks
		_successBlock = successBlock
		_finallyBlock = finallyBlock

	def addSubFields is override
		base.addSubFields()
		.addField('tryBlock', _tryBlock)
		.addField('exceptBlock', _exceptBlocks)
		.addField('succesBlock', _successBlock)
		.addField('finallyBlock', _finallyBlock)

	def _bindImp is override
		base._bindImp()
		_varNumber = .compiler.curBox.makeNextPrivateSerialNumber()
		_tryBlock.bindImp()
		for eb in _exceptBlocks
			eb.bindImp()
		if _successBlock
			_successBlock.bindImp()
		if _finallyBlock
			_finallyBlock.bindImp()

#	def genCS(out)
#		Stmt.genCS(out)
#		if .successBlock
#			# C# has no "success" (or in Python, "else") block for the "try" statement
#			# so it has to be simulated
#			helperName = '_lh_success_%s' % .varNumber  # lh => "local helper"
#			out.write('bool %s = false;\n' % helperName)
#			if .finallyBlock
#				out.write('try {\n')
#				out.indent()
#			out.write('try')
#			.tryBlock.genCS(out, close=false)
#			out.write('%s = true;\n' % helperName)
#			out.dedent()
#			out.write('}\n')
#			if .exceptBlocks
#				.writeExceptBlocks(out)
#			else
#				out.write('finally { }\n')  # syntactically necessary
#			out.write('if (%s)' % helperName)
#			.successBlock.genCS(out)
#			if .finallyBlock
#				out.dedent()
#				out.write('}\n')
#				out.write('finally')
#				.finallyBlock.genCS(out)
#		else
#			out.write('try')
#			.tryBlock.genCS(out)
#			.writeExceptBlocks(out)
#			if .finallyBlock
#				out.write('finally')
#				.finallyBlock.genCS(out)

#	def writeExceptBlocks(out)
#		for eb in .exceptBlocks
#			out.write('catch')
#			if eb.type
#				out.write(' (%s' % eb.type.name)
#				if eb.varName
#					helperName = eb.csHelperName
#					out.write(' %s' % helperName)
#				out.write(')')
#			top = eb.varName and '%s = %s;\n'%(eb.varName,helperName) or ''
#			eb.block.genCS(out, top=top)


# TODO: Rename to CatchBlock
class ExceptBlock
	inherits SyntaxNode

	var _var as AbstractLocalVar?
	var _type as IType?
	var _block as BlockStmt
	var _varName as String?
	var _csHelperName as String

	def construct(token as IToken, block as BlockStmt)
		"""
		This is for `success`, `finally` and typeless `catch` blocks.
		"""
		base.construct(token)
		_block = block

	def construct(token as IToken, varr as AbstractLocalVar, block as BlockStmt)
		"""
		This is for `catch` blocks that specify a type and variable.
		"""
		base.construct(token)
		_var = varr
		_varName = if(varr, varr.name, nil)
		_block = block

	def _bindImp is override
		base._bindImp()
		if _var
			_var.bindImp()
			if not _var.isTracked
				varr = _var to LocalVar  # CC: axe typecast
				codePart = .compiler.codeMemberStack.peek()
				existingVar = codePart.findLocal(varr.name)
				if existingVar
					if existingVar.type is not varr.type
						_error('Cannot redeclare "[varr.name]" as "[varr.type]" because it was declared as "[existingVar.type]" earlier.')
				else
					codePart.addLocal(varr)
			if _type is nil
				_type = _var.type
				assert _type
		_csHelperName = '_lh_except_[.compiler.curBox.makeNextPrivateSerialNumber()]'
		_block.bindImp()


class ThrowStmt
	inherits Stmt

	var _expr as Expr?

	def construct(token as IToken, expr as Expr?)
		base.construct(token)
		_expr = expr

	def addSubFields is override
		base.addSubFields()
		.addField('expr', '_expr')

	def _bindImp is override
		base._bindImp()
		if _expr
			_expr.bindImp()

#	def genCS(out):
#		Stmt.genCS(out)
#		out.write('throw ')
#		if _expr:
#			_expr.genCS(out, genParens=false)
#		out.write(';\n')


class WhileStmt
	inherits Stmt

	var _expr as Expr
	var _block as BlockStmt

	def construct(token as IToken, expr as Expr, block as BlockStmt)
		base.construct(token)
		_expr = expr
		_block = block

	def addSubFields is override
		base.addSubFields()
		.addField('expr', _expr)
		.addField('block', _block)

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
# TODO:		.noAssignmentAllowed(_expr)
# TODO: truthfulness
#		if _expr.type is not tbool
#			_expr = TruthExpr(_expr).bindImp()
		_block.bindImp()

#	def genCS(out)
#		Stmt.genCS(out)
#		out.write('while (')
#		_expr.genCS(out, genParens=false)
#		out.write(')')
#		_stmts.genCS(out)


class PostWhileStmt
	inherits WhileStmt

	def construct(token as IToken, expr as Expr, block as BlockStmt)
		base.construct(token, expr, block)

#	def genCS(out)
#		Stmt.genCS(out)
#		out.write('do')
#		_stmts.genCS(out, close=false)
#		out.dedent()
#		out.write('} while (')
#		_expr.genCS(out)
#		out.write(');\n')
