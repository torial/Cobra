class Stmt
	inherits SyntaxNode

	def construct(token as IToken)
		base.construct(token)

	def afterParserRecognizesStatement
		pass


class AssertStmt
	inherits Stmt

	var _expr as Expr
	var _info as Expr?

	def construct(token as IToken, expr as Expr, info as Expr?)
		base.construct(token)
		_expr = TruthExpr(expr)
		_info = info

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		if _info
			_info.bindImp()

#	def genCS(out):
#		Stmt.genCS(out)
#		out.write('if (!')
#		.expr.genCS(out)
#		out.write(') ')
#		out.indent()
#		s = .expr.toCobraSource()
#		s = .csStringLitFor(s)
#		out.write('throw new AssertException(%s, %s, %s, ' % (.csStringLitFor(.fileName), .lineNumber, s))
#		if .info:
#			.info.genCS(out)
#		else:
#			out.write('null')
#		out.write(');\n')
#		out.dedent()


class BlockStmt
	inherits Stmt
	"""
	A BlockStmt holds a series of statements which are the target of complex statement such
	if, while, etc. BlockStmts are *not* the target of a method or property.
	"""

	var _stmts as List<of Stmt>

	def construct(token as IToken, stmts as List<of Stmt>)
		base.construct(token)
		_stmts = stmts

	def addSubFields is override
		base.addSubFields()
		.addField('stmts', _stmts)


class IfStmt
	inherits Stmt

	var _cond as Expr
	var _trueStmts as BlockStmt
	var _falseStmts as BlockStmt?

	def construct(token as IToken, cond as Expr, trueStmts as BlockStmt, falseStmts as BlockStmt?)
		base.construct(token)
		_cond = cond
		_trueStmts  = trueStmts
		_falseStmts = falseStmts

	def addSubFields
		base.addSubFields()
		.addField('cond', _cond)
		.addField('trueStmts', _trueStmts)
		.addField('falseStmts', _falseStmts)

	def _bindImp
		base._bindImp()
		_cond.bindImp()
# TODO:		.noAssignmentAllowed(_cond)
# TODO: truthfulness
#		if _cond.type is not tbool
#			_cond = TruthExpr(_cond).bindImp()
		cond = _cond
# TODO: if-inherits
#		ifInherits = false
#		if inherits(cond, BinaryOpExpr) and cond.op=='INHERITS' and inherits(cond.left, IdentifierExpr)
#			leftVar = cond.left.definition
#			leftVar.ifInheritsStack.push(cond.right.namedType)
#			ifInherits = true
#			_trueStmts.setIfInherits(leftVar, leftVar.ifInheritsStack.peek())
		_trueStmts.bindImp()
#		if ifInherits
#			leftVar.ifInheritsStack.pop()
		if _falseStmts is not nil
			_falseStmts.bindImp()

#	def genCS(out)
#		Stmt.genCS(out)
#		out.write('if (')
#		_cond.genCS(out, genParens=false)
#		out.write(')')
#		_trueStmts.genCS(out, close=false)
#		out.dedent()
#		if _falseStmts
#			out.write('} else')
#			_falseStmts.genCS(out, close=false)
#			out.dedent()
#		out.write('}\n')


class PrintStmt
	inherits Stmt

	var _destination as Expr?
	var _args as List<of Expr>
	var _stopp as bool

	def construct(token as IToken, destination as Expr?, args as List<of Expr>, stopp as bool)
		base.construct(token)
		_destination = destination
		_args = args
		_stopp = stopp

	def _bindImp is override
		base._bindImp()
		if _destination!
			_destination.bindImp()
		for arg in _args
			arg.bindImp()

	def addSubFields is override
		base.addSubFields()
		.addField('stopp', _stopp)
		.addField('destination', _destination)
		.addField('args', _args)

#	def genCS(self, out):
#		Stmt.genCS(self, out)
#		if self.destination:
#			out.write('(')
#			self.destination.genCS(out)
#			out.write(').%s(' % (self.stop and 'Write' or 'WriteLine'))
#		else:
#			out.write('CobraImp.%s(' % (self.stop and 'PrintStop' or 'PrintLine'))
#		sep = ''
#		for arg in self.args:
#			out.write(sep)
#			if arg.type.isStringClass:
#				out.write('(')
#			else:
#				out.write('CobraImp.ToString(')
#			arg.genCS(out)
#			out.write(')')
#			sep = '+'
#		out.write(');\n')


class PrintRedirectStmt
	inherits Stmt

	var _destination as Expr
	var _block as BlockStmt

	def construct(token as IToken, destination as Expr, block as BlockStmt)
		base.construct(token)
		_destination = destination
		_block = block

	def _bindImp is override
		base._bindImp()
		_destination.bindImp()
		_block.bindImp()

	def addSubFields is override
		base.addSubFields()
		.addField('destination', _destination)
		.addField('block', _block)

#	def genCS(self, out):
#		Stmt.genCS(self, out)
#		out.write('CobraImp.PushPrintTo(')
#		self.destination.genCS(out, genParens=false)
#		out.write(');\n')
#		out.write('try')
#		self.stmts.genCS(out)
#		out.write('finally {\n')
#		out.indent()
#		out.write('CobraImp.PopPrintTo();\n')
#		out.dedent()
#		out.write('}\n')


class ReturnStmt
	inherits Stmt

	def construct(token as IToken, expr as Expr?)
		base.construct(token)
		pass


class WhileStmt
	inherits Stmt

	var _expr as Expr
	var _block as BlockStmt

	def construct(token as IToken, expr as Expr, block as BlockStmt)
		base.construct(token)
		_expr = expr
		_block = block

	def addSubFields
		base.addSubFields()
		.addField('expr', _expr)
		.addField('block', _block)

	def _bindImp()
		base._bindImp()
		_expr.bindImp()
# TODO:		.noAssignmentAllowed(_expr)
# TODO: truthfulness
#		if _expr.type is not tbool
#			_expr = TruthExpr(_expr).bindImp()
		_block.bindImp()

#	def genCS(out)
#		Stmt.genCS(out)
#		out.write('while (')
#		_expr.genCS(out, genParens=false)
#		out.write(')')
#		_stmts.genCS(out)


class PostWhileStmt
	inherits WhileStmt

	def construct(token as IToken, expr as Expr, block as BlockStmt)
		base.construct(token, expr, block)

#	def genCS(out)
#		Stmt.genCS(out)
#		out.write('do')
#		_stmts.genCS(out, close=false)
#		out.dedent()
#		out.write('} while (')
#		_expr.genCS(out)
#		out.write(');\n')
