interface ITypeProvider
	"""
	A type provider can provide essential types and serve as a place
	they are "uniqued" in order to avoid type duplication.
	"""

	def typeForName(name as String) as IType

	def typeOrNilForName(name as String) as IType?

	get boolType as BoolType

	get charType as CharType

	get decimalType as DecimalType

	get floatType as FloatType

	get intType as IntType

	get dynamicType as DynamicType

	get passThroughType as PassThroughType

	get typeType as TypeType

	get voidType as VoidType

	def variType(type as IType) as VariType

	def variType(typeNode as INode) as VariType


class BasicTypeProvider
	implements ITypeProvider
	"""
	TODO: rename to TypeProvider, change to a "mix-in" and have the Compiler class inherit it
	"""

	var _boolType			as BoolType?
	var _charType			as CharType?
	var _decimalType		as DecimalType?
	var _dynamicType		as DynamicType?
	var _floatType			as FloatType?
	var _intType			as IntType?
	var _passThroughType	as PassThroughType?
	var _typeType			as TypeType?
	var _voidType			as VoidType?
	var _variTypes			as Dictionary<of INode, VariType>

	def typeForName(name as String) as IType
		assert false, 'TODO'
		return CobraType()

	def typeOrNilForName(name as String) as IType?
		assert false, 'TODO'
		return nil

	get boolType as BoolType
		if _boolType is nil
			_boolType = BoolType()
		return _boolType to BoolType  # CC: to ! | CC: axe to !

	get charType as CharType
		if _charType is nil
			_charType = CharType()
		return _charType to CharType  # CC: to! | CC: axe to !

	get decimalType as DecimalType
		if _decimalType is nil
			_decimalType = DecimalType()
		return _decimalType to DecimalType  # CC: to! | CC: axe to !

	get dynamicType as DynamicType
		if _dynamicType is nil
			_dynamicType = DynamicType()
		return _dynamicType to DynamicType

	get floatType as FloatType
		if _floatType is nil
			_floatType = FloatType()
		return _floatType to FloatType  # CC: to! | CC: axe to !

	get intType as IntType
		if _intType is nil
			_intType = IntType()
		return _intType to IntType  # CC: to! | CC: axe to !

	get passThroughType as PassThroughType
		if _passThroughType is nil
			_passThroughType = PassThroughType()
		return _passThroughType to PassThroughType  # CC: to ! | CC: axe to !

	get typeType as TypeType
		if _typeType is nil
			_typeType = TypeType()
		return _typeType to TypeType  # CC: to ! | CC: axe to !

	get voidType as VoidType
		if _voidType is nil
			_voidType = VoidType()
		return _voidType to VoidType  # CC: to ! | CC: axe to !

	def variType(type as IType) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of INode, VariType>()
		else if _variTypes.containsKey(type)
			return _variTypes[type]
		_variTypes[type] = vt = VariType(type)
		return vt

	def variType(typeNode as INode) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of INode, VariType>()
		else if _variTypes.containsKey(typeNode)
			return _variTypes[typeNode]
		_variTypes[typeNode] = vt = VariType(typeNode)
		return vt


interface IType
	inherits INode  # TODO: does an IType need to also be an IContainer?

	get name as String

	get csInit as String

	def isAssignableTo(type as IType) as bool

	get innerType as IType?
		"""
		Used by the enumerable for statement to infer the type of the control variable.
		"""


class CobraType
	inherits Node
	implements IType

	def construct
		base.construct()

	get name as String
		return ''

	def isAssignableTo(type as IType) as bool
		throw OverrideException()
		return false

	get namedType as IType? is override
		# TODO: is this essential? if so, perhaps "namedType" --> "effectiveType"
		return this

	get innerType as IType?
		return nil

	get csInit as String
		throw OverrideException()

	def declForName(name as String) as IMember?
		"""
		Returns nil by default.
		"""
		return nil

	def equals(obj as Object) as bool is override
		if obj is nil
			return false
		if obj inherits CobraType
			return .serialNum.equals(obj.serialNum)
		else
			return false

	def getHashCode as int is override
		return .serialNum.getHashCode()


class ValueType
	inherits CobraType

	def equals(obj as Object) as bool is override
		if obj is nil
			return false
		if not obj inherits CobraType
			return false
		if .getType() is obj.getType()
			return true
		return false

	def getHashCode as int is override
		return .getType().getHashCode()


class BoolType
	inherits ValueType

	def construct
		base.construct()


class CharType
	inherits ValueType

	def construct
		base.construct()


class DecimalType
	inherits ValueType

	def construct
		base.construct()


class DynamicType
	inherits CobraType
	"""
	TODO: flesh out DynamicType
	"""

	pass


class FloatType
	inherits ValueType

	def construct
		base.construct()


class IntType
	inherits ValueType

	def construct
		base.construct()


class PassThroughType
	inherits CobraType
	"""
	This is a temporary helper type used while Cobra is still deficient in type checking mostly
	due to its inability to look up methods, properties, etc.

	Originally it overrode isDescendantOf() to always return true, but this mislead the C#
	code generation. The override was removed and now you have to check for it explicitly.

	TODO: remove this class
	"""

	def construct
		base.construct()

	get csInit as String is override
		return 'null'

	def isAssignableTo(type as IType) as bool is override
		return true


class VoidType
	inherits ValueType
	"""
	This type is used only for methods that don't declare a return type and therefore cannot return
	anything.
	"""

	def construct
		base.construct()

	get csInit as String is override
		assert false, 'No init for VoidType.'


##
## Wrapped Types
##

class WrappedType
	inherits CobraType

	# TODO: flesh this out

	var _wrappedType as IType?
	var _wrappedTypeNode as INode?
	var _hashCode as int?

	def construct(wrappedType as IType)
		base.construct()  # TODO: ? pass wrappedType.superType
		_wrappedType = wrappedType
		_wrappedTypeNode = nil

	def construct(wrappedTypeNode as INode)
		base.construct()
		_wrappedType = nil
		_wrappedTypeNode = wrappedTypeNode

	def equals(obj as Object) as bool is override
		if base.equals(obj)
			assert obj inherits WrappedType
			wt = obj to WrappedType  # CC: shouldn't need this due to the assertion just above
			if _wrappedType and wt._wrappedType
				return _wrappedType.equals(wt._wrappedType)
			else if _wrappedTypeNode and wt._wrappedTypeNode
				return _wrappedTypeNode.equals(wt._wrappedTypeNode)
			else
				throw FallThroughException([this, obj])
		return false

	def getHashCode as int is override
		if _hashCode is nil
			if _wrappedTypeNode
				_hashCode = _wrappedTypeNode.getHashCode()
			else if _wrappedType
				_hashCode = _wrappedType.getHashCode()
			else
				_hashCode = base.getHashCode()
		return _hashCode to int  # CC: to !

	get innerType as IType? is override
		require .didBindImp
		return _wrappedType.innerType

	def _bindInt is override
		_resolveType()

	def _bindImp is override
		_resolveType()

	def _resolveType
		require _wrappedType! or _wrappedTypeNode!
		if _wrappedType!
			return
		if _wrappedTypeNode inherits IType
			_wrappedType = _wrappedTypeNode to passthrough   # CC: shouldn't need the cast here
			return
		_wrappedType = _wrappedTypeNode.bindAll().namedType
		if _wrappedType is nil
			_error('Cannot resolve type.')  # TODO: add the name of the wrappedTypeNode or something


class VariType
	inherits WrappedType
	"""
	TODO: flesh out VariType
	"""

	def construct(wrappedType as IType)
		base.construct(wrappedType)

	def construct(wrappedTypeNode as INode)
		base.construct(wrappedTypeNode)

	get innerType as IType? is override
		return _wrappedType


class TypeType
	inherits CobraType

	def construct
		base.construct()

	get csInit as String is override
		return 'null'


class TypeIdentifier
	inherits SyntaxNode
	"""
	Created by CobraParser.type() for identifiers found where types are
	expected.

	Cobra allows forward references so even though types are expected in
	places like the return type of a method, they cannot be turned into
	actual types until the bindInt phase (or bindImp for expressions).
	"""
	# TODO: ? inherits AbstractTypeIdentifier

	var _name as String
	var _actualType as IType?

	def construct(token as IToken)
		require
			token.which=='ID'
			token.value
		ensure
			.name
		code
			base.construct(token)
			_name = token.value to String

	get name from var

	get actualType from var

	get namedType as IType? is override
		require
			.didBindInt
			.actualType
		code
			return _actualType

	def equals(other as Object) as bool is override
		if other is nil
			return false
		if other inherits TypeIdentifier
			if _actualType and other._actualType
				return _actualType.equals(other._actualType)
			else
				return _name.equals(other._name)
		return this is other

	def getHashCode as int is override
		return _name.getHashCode()

	def _bindInt is override
		base._bindInt()
		# don't need to check "basic types" like int, bool, etc. here. the parser does those.
		if Utils.isCapped(_name)
			symbol = .compiler.symbolForName(.name, true, false)  # nested enum and class types are capped and are members of the current class
		else
			symbol = nil
		if symbol is nil
			sugg = ''
			if not Utils.isCapped(_name)
				sugg = Utils.capped(_name)
				other = .compiler.symbolForName(sugg, true, false)
				sugg = if(other, ' Try "[sugg]".', '')
			_error('Cannot find type for "[_name]".[sugg]')

		if symbol inherits IType
			_actualType = symbol
		else
			what = symbol.namedType
			assert what!, symbol
			_actualType = what

		assert _actualType is not nil
