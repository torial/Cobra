interface ITypeProvider
	"""
	A type provider can provide essential types and serve as a place
	they are "uniqued" in order to avoid type duplication.
	"""

	def typeForName(name as String) as IType

	def typeOrNilForName(name as String) as IType?

	get boolType as BoolType

	get charType as CharType

	get decimalType as DecimalType

	get floatType as FloatType

	get intType as IntType

	get dynamicType as DynamicType

	get nilType as NilType

	get numberType as NumberType

	get passThroughType as PassThroughType

	get typeType as TypeType

	get unspecifiedType as UnspecifiedType

	get voidType as VoidType

	def variType(type as IType) as VariType

	def variType(typeNode as INode) as VariType


class BasicTypeProvider
	implements ITypeProvider
	"""
	TODO: rename to TypeProvider, change to a "mix-in" and have the Compiler class inherit it
	"""

	var _boolType			as BoolType?
	var _charType			as CharType?
	var _decimalType		as DecimalType?
	var _dynamicType		as DynamicType?
	var _floatType			as FloatType?
	var _intType			as IntType?
	var _nilType			as NilType?
	var _numberType			as NumberType?
	var _passThroughType	as PassThroughType?
	var _typeType			as TypeType?
	var _unspecifiedType	as UnspecifiedType?
	var _voidType			as VoidType?
	var _variTypes			as Dictionary<of INode, VariType>?

	def typeForName(name as String) as IType
		assert false, 'TODO'
		return CobraType()

	def typeOrNilForName(name as String) as IType?
		assert false, 'TODO'
		return nil

	get boolType as BoolType
		if _boolType is nil
			_boolType = BoolType()
		return _boolType to BoolType  # CC: to ! | CC: axe to !

	get charType as CharType
		if _charType is nil
			_charType = CharType()
		return _charType to CharType  # CC: to! | CC: axe to !

	get decimalType as DecimalType
		if _decimalType is nil
			_decimalType = DecimalType()
		return _decimalType to DecimalType  # CC: to! | CC: axe to !

	get dynamicType as DynamicType
		if _dynamicType is nil
			_dynamicType = DynamicType()
		return _dynamicType to DynamicType

	get floatType as FloatType
		if _floatType is nil
			_floatType = FloatType()
		return _floatType to FloatType  # CC: to! | CC: axe to !

	get intType as IntType
		if _intType is nil
			_intType = IntType()
		return _intType to IntType  # CC: to! | CC: axe to !

	get nilType as NilType
		if _nilType is nil
			_nilType = NilType()
		return _nilType to NilType  # CC: to! | CC: axe to !

	get numberType as NumberType
		if _numberType is nil
			_numberType = NumberType()
		return _numberType to NumberType  # CC: to! | CC: axe to !

	get passThroughType as PassThroughType
		if _passThroughType is nil
			_passThroughType = PassThroughType()
		return _passThroughType to PassThroughType  # CC: to ! | CC: axe to !

	get typeType as TypeType
		if _typeType is nil
			_typeType = TypeType()
		return _typeType to TypeType  # CC: to ! | CC: axe to !

	get unspecifiedType as UnspecifiedType
		if _unspecifiedType is nil
			_unspecifiedType = UnspecifiedType()
		return _unspecifiedType to UnspecifiedType  # CC: to ! | CC: axe to !

	get voidType as VoidType
		if _voidType is nil
			_voidType = VoidType()
		return _voidType to VoidType  # CC: to ! | CC: axe to !

	def variType(type as IType) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of INode, VariType>()
		else if _variTypes.containsKey(type)
			return _variTypes[type]
		_variTypes[type] = vt = VariType(type)
		return vt

	def variType(typeNode as INode) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of INode, VariType>()
		else if _variTypes.containsKey(typeNode)
			return _variTypes[typeNode]
		_variTypes[typeNode] = vt = VariType(typeNode)
		return vt


interface ITypeProxy
	inherits INode
	"""
	An ITypeProxy is a node that *could be* a type.
	Its realType property will return non-nil if so.
	Implemented by CobraType, AbstractTypeIdentifier, TypeExpr, IdentifierExpr, DotExpr and IndexExpr.
	NOTE: Could consider makeing realType returning a non-nil and then having a new IConditionalTypeProxy that return have a `get conditionalType as IType?`. The reason here is that some of the ITypeProxy implementors will never return nil.
	"""
	
	get realType as IType?
		"""
		If this node represents a type, this property returns it.
		Otherwise, returns nil (which is the default behavior).
		"""


interface IType
	inherits ITypeProxy, IMember  # TODO: does an IType need to also be an IContainer? TODO: Why does it have to be either?

	def isAssignableTo(type as IType) as bool

	def isDescendantOf(type as IType) as bool

	get isDynamic as bool
		"""
		Returns true if the type is a dynamic type.
		You cannot use `t inherits DynamicType` because a NilableType gives false for that even though it may be dynamic.
		"""

	get isReference as bool
		"""
		Returns true if the type is a reference type, such as a class, interface or nilable type.
		And as opposed to value type such as a struct, int, etc.).
		"""

	def isComparableTo(t as IType) as bool
		"""
		Returns true if this type can be compared to the given type via `is`, `is not`, `==`, `<>`, `>`, etc.
		"""

	get genericTypeDef as IType?
		"""
		Returns the generic type definition for a constructed type (or nil if this type is not constructed).
		"""
	
	get isGenericDef as bool
		"""
		Returns true if this type is a definition of a generic type, and
		therefore capable of making subsequent generic types via the
		`constructedTypeFor` method. A generic type will have generic
		parameters which are all GenericParam (as opposed to other types
		such as `int` or a given class).
		"""

	get isGeneric as bool
		"""
		Returns true if this type is a generic type which includes
		generic type defs and open-or-closed constructed types. Note
		that arrays of generic types and pointers to generic types will
		return false.
		"""

	get genericParams as List<of IType>
		"""
		Return the list of generic params for this generic type. This
		property requires that .isGenericDef is true.
		"""
		# TODO: require .isGenericDef

	def constructedTypeFor(typeArgs as List<of IType>) as IType
		"""
		Makes a new generic type with the given typeArgs which must
		match in number to the generic parameters. This method requires
		that .isGenericDef is true. Note that the type args can be
		GenericParams or other types or a mix. Also, this method must
		return an existing type that matches the typeArgs if one already
		exists.
		"""
		# TODO: require .isGenericDef; typesArgs.count==.genericParams.count
		# TODO: should this be moved down to Box?

	def secondaryConstructedTypeFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as IType
		"""
		Makes a new generic type, if needed, using the given map from generic params to types.
		Returns this type if no generic construction is necessary.
		This method is invoked during the type construction for return types, parameter types, etc.
		"""

	def isConstructionOf(type as IType) as bool
		"""
		Returns true if this type is a construction of the given generic type def, even going more than level deep through `genericTypeDef`.
		"""
		# TODO: require type.isGenericDef
		
	def greatestCommonDenominatorWith(type as IType) as IType
		"""
		Return the most specific type that is compatible with both this type and the arg.
		The worst case scenarious are Object and Object? since all types are compatible
		with Object. Used for at least if() expressions, list literals and dictionary
		literals.
		"""

	def indexType(argTypes as List<of IType>) as IType?
		"""
		Used by the IndexExpr.
		"""

	get innerType as IType?
		"""
		Used by the enumerable for statement to infer the type of the control variable.
		"""

	get superType as IType?
		"""
		Returns the super type of this type.
		If an implementor has multiple super types (interfaces do), then this method should
		return nil and other methods such as isDescendantOf() and memberForName() must be
		sure to take the multiple super types into consideration.
		"""

	def memberForName(name as String) as IMember?
		"""
		Used for `foo.bar` where this type is the type of `foo`.
		Should return members that are inherited (if any).
		"""

	## Code gen

	get csInit as String

	get sharpNameComponent as String
		"""
		Returns a string that refers to this type and is suitable for embedding in a larger
		identifier (meaning there will be no punction, spaces or C# comments).
		"""

	get sharpRef as String
		"""
		Returns a string that refers to this type.
		Examples: 'int'  'List<String>'  'object'
		"""


class CobraType
	inherits Node
	implements IType, ITypeProxy
	"""
	This is the parent type of all other types.
	It exists for organizational purposes.
	No actual expression as ever directly assigned this type.
	If you are looking for "dynamic", see DynamicType.
	If you are looking for the type of types, see TypeType.
	If you are looking for "object", see ObjectType.
	"""

	var _nameSpace as NameSpace?
	var _superType as IType?
	var _isUsed as bool

	def init
		base.init()

	get englishName as String
		assert false, '[.getType.name], [this]'  # TODO: pass this to OverrideException() instead
		throw OverrideException(.getType)

	get name as String
		return .getType.toString

	pro nameSpace from var

	get isCallable as bool
		return true

	get isDynamic as bool
		return false

	get isMethod as bool
		return false

	get isReference as bool
		throw OverrideException(.getType)
		return false

	get isShared as bool
		return true

	def isComparableTo(b as IType) as bool
		if b inherits NilableType
			# CC: b = b.theWrappedType
			$sharp('b = ((NilableType)b).TheWrappedType')
		if this.isAssignableTo(b to IType) or b.isAssignableTo(this)  # CC: to ! or assert above with nil flow analysis
			return true
		if b inherits NilType # TODO: axe this. but temp reason for this is due to Tests\150-basics-two\100-using.cobra
			return true
		return false

	get requiresThis as bool
		return false

	get resultType as IType?
		return this

	get typeForIdentifier as IType
		return .compiler.typeType

	get typeForReceiver as IType
		return this

	def indexType(argTypes as List<of IType>) as IType?
		return nil

	get innerType as IType?
		return nil

	get realType as IType?
		return this

	get superType from var

	get genericTypeDef as IType?  # TODO: rename to genericDef to match the following boolean properties
		return nil
		
	get isGenericDef as bool
		return false

	get isGeneric as bool
		return false

	get genericParams as List<of IType>
		if .isGenericDef
			throw Exception('.isGenericDef returns true, but there is no override to return the genericParams')
		else
			throw Exception('.isGenericDef returns false, so there can be no genericParams')

	def constructedTypeFor(typeArgs as List<of IType>) as IType
		if .isGenericDef
			throw Exception('.isGenericDef returns true, but there is no override to constructedTypeFor')
		else
			throw Exception('.isGenericDef returns false, so there can be no constructedTypeFor')
		return nil to passthrough  # TODO: axe whole line when code flow analysis proves it's not needed

	def secondaryConstructedTypeFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as IType
		return this

	def isConstructionOf(type as IType) as bool
		assert type.isGenericDef  # TODO: make a requirement of the interface
		if .genericTypeDef is nil
			return false
		if .genericTypeDef is type
			return true
		if .genericTypeDef.genericTypeDef
			return .genericTypeDef.isConstructionOf(type) # TODO: would iteration be more efficient here?
		return false
		
	def greatestCommonDenominatorWith(type as IType) as IType
		if this is type
			return this
		if type inherits NilableType
			return type.greatestCommonDenominatorWith(this)
		if type inherits NilType
			return NilableType(this)
		if .isDescendantOf(type)
			return type
		if type.isDescendantOf(this)
			return this
		if type inherits DynamicType
			return type
		# TODO: following is a guess -- haven't really thought about following both superTypes at the same type or if there is even any point
		if .superType and type.superType
			return .superType.greatestCommonDenominatorWith(type.superType to IType)
		else
			return .compiler.libraryType('System', 'Object')

	def isAssignableTo(type as IType) as bool
		require
			.compiler
		body
			if type is .compiler.passThroughType
				return true
			if type is .compiler.dynamicType
				return true
			if type is .compiler.libraryType('System', 'Object')
				return true
			# TODO: remove this:
			if type inherits GenericParam
				return true
			# TODO: would this be needed if not for qualified types?
			if type inherits WrappedType
				return .isAssignableTo(type.theWrappedType to passthrough) # CC: do something here
			return .isDescendantOf(type)

	def isDescendantOf(type as IType) as bool
		"""
		Returns true if this type is a subtype (direct or indirect) of type.
		"""
		if this is type
			return true
		curType as IType? = this  # CC: change to: curType = this to ?
		while true
			if curType is type
				return true
			curType = curType.superType
			if curType is nil
				break
		return false

	pro isUsed from var

	def declForName(name as String) as IMember?
		"""
		Returns nil by default.
		"""
		return nil

	def memberForName(name as String) as IMember?
		"""
		Returns a named member of System.Object by default.
		"""
		objectClass = .compiler.libraryType('System', 'Object')
		return objectClass.memberForName(name)

	def equals(obj as Object) as bool is override
		if obj is nil
			return false
		if obj inherits CobraType
			return .serialNum.equals(obj.serialNum)
		else
			return false

	def getHashCode as int is override
		return .serialNum.getHashCode()

	## Code gen

	get csInit as String
		throw OverrideException(.getType)

	get sharpName as String
		return .name

	get sharpNameComponent as String
		name = .name
		i = name.indexOf('/*')  # example: /*dynamic*/object
		if i <> -1
			j = name.indexOf('*/', i)
			name = name[:i] + name[j+2:]
		name = name.replace('.', '_').replace('<', '_').replace('>', '_').replace(', ', '_')
		return name

	get sharpRef as String
		return .sharpName

	def writeSharpTestInvocation(sw as SharpWriter)
		pass


class ValueType
	inherits CobraType

	get englishName as String is override
		return 'primitive type'

	get isReference as bool is override
		return false

	def equals(obj as Object) as bool is override
		if obj is nil
			return false
		if not obj inherits CobraType
			return false
		if .getType is obj.getType
			return true
		return false

	def getHashCode as int is override
		return .getType.getHashCode()


class PrimitiveType
	inherits ValueType
	"""
	The base class of BoolType, CharType, etc.
	Used purely for classification purposes (`t inherits PrimitiveType`).
	"""
	pass


class BoolType
	inherits PrimitiveType

	def init
		base.init()

	get name as String is override
		return 'bool'

	get csInit as String is override
		return 'false'


class CharType
	inherits PrimitiveType

	def init
		base.init()

	get name as String is override
		return 'char'

	def isComparableTo(b as IType) as bool
		r = base.isComparableTo(b)
		if not r and b is .compiler.libraryType('System', 'String')
			r = true
		return r

	get csInit as String is override
		return '(char)0'


class DecimalType
	inherits NumberType

	def init
		base.init()

	get name as String is override
		return 'decimal'


class DynamicType
	inherits CobraType

	get englishName as String is override
		return 'basic type'

	get name as String is override
		return 'dynamic'

	def isAssignableTo(type as IType) as bool is override
		return true

	get isDynamic as bool is override
		return true

	get isReference as bool is override
		return true

	get innerType as IType? is override
		return this

	def indexType(argTypes as List<of IType>) as IType? is override
		return this

	get csInit as String is override
		return 'null'

	get sharpName as String is override
		return '/*dynamic*/object'

	def greatestCommonDenominatorWith(type as IType) as IType is override
		if this is type
			return this
		if type inherits NilableType
			return NilableType(this)
		if type inherits NilType
			return NilableType(this)
		return this


class FloatType
	inherits NumberType

	def init
		base.init()

	get name as String is override
		return 'float'

	get sharpName as String is override
		return 'double'


class IntType
	inherits NumberType

	def init
		base.init()

	get name as String is override
		return 'int'

	def isAssignableTo(type as IType) as bool is override
		if type is .compiler.decimalType
			return true
		if type is .compiler.floatType
			return true
		return base.isAssignableTo(type)


class NilableType
	inherits WrappedType

	def init(t as IType)
		base.init(t)

	get name as String is override
		if _wrappedType
			return _wrappedType.name + '?'
		else if _wrappedTypeNode
			# CC:
			#return _wrappedTypeNode.toString + '?'
			return '[_wrappedTypeNode.toString]?'
		else
			throw FallThroughException(this)

	get isDynamic as bool is override
		return _wrappedType.isDynamic

	get isReference as bool is override
		return _wrappedType.isReference

	# TODO: I think the following is appropriate, but come up with a test case for it first.
	#get innerType
	#	return self.wrappedType.innerType

	def indexType(argTypes as List<of IType>) as IType? is override
		assert .didBindInt  # TODO: promote this to Type?
		return _wrappedType.indexType(argTypes)

	def isAssignableTo(type as IType) as bool is override
		if type inherits PassThroughType
			return true
		if type inherits NilableType
			assert _wrappedType
			return _wrappedType.isAssignableTo(type.theWrappedType to IType)  # CC: to ! or something
		return false

	def isComparableTo(b as IType) as bool is override
		return _wrappedType.isComparableTo(b)

	def isDescendantOf(type as IType) as bool is override
		return base.isDescendantOf(type) and _wrappedType.isDescendantOf(type)

	def memberForName(name as String) as IMember? is override
		assert .didBindInt
		assert _wrappedType  # TODO: can CobraType require a wrappedType
		return _wrappedType.memberForName(name)

	def greatestCommonDenominatorWith(type as IType) as IType is override
		if this is type
			return this
		if type inherits NilType
			return this
		if type inherits NilableType
			assert type.theWrappedType
			if _wrappedType is type.theWrappedType
				return this
			else
				return NilableType(_wrappedType.greatestCommonDenominatorWith(type.theWrappedType to IType)) # CC: to !
		return NilableType(_wrappedType.greatestCommonDenominatorWith(type))

	get csInit as String is override
		return 'null'

	get sharpRef as String is override
		return _wrappedType.sharpRef + if(not _wrappedType.isReference, '?', '')


class NilType
	inherits CobraType

	get name as String is override
		return 'nil'

	get isReference as bool is override
		return true

	def isAssignableTo(type as IType) as bool is override
		if this is type
			return true
		if type is .compiler.passThroughType
			return true
		if type inherits NilableType
			return true
		return false

	def greatestCommonDenominatorWith(type as IType) as IType is override
		if this is type
			return this
		if type inherits NilableType
			return type
		else
			return NilableType(type)

# TODO:
#	def checkBinaryOp(self, op, right, compiler):
#		RootType.checkBinaryOp(self, op, right, compiler)
#		if op=='TO':
#			from Expressions import TypeExpr
#			type = right.realType
#			assert types, right
#			assert not inherits(type, NilType)
#			if not inherits(type, NilableType) and type is not tpassthrough:
#				self.error('Cannot cast nil to a non-nil type.')

	get csInit as String is override
		return 'null'


class NumberType
	inherits PrimitiveType
	"""
	The base class for int, float and decimal.
	"""

	get csInit as String is override
		return '0'


class PassThroughType
	inherits CobraType
	"""
	This is a temporary helper type used while Cobra is still deficient in type checking mostly
	due to its inability to look up methods, properties, etc.

	Originally it overrode isDescendantOf() to always return true, but this mislead the C#
	body generation. The override was removed and now you have to check for it explicitly.

	TODO: remove this class
	"""

	def init
		base.init()

	get englishName as String is override
		return 'basic type'

	get isReference as bool is override
		return true

	get name as String is override
		return 'passthrough'

	def indexType(argTypes as List<of IType>) as IType? is override
		return this

	get innerType as IType? is override
		return this

	def isAssignableTo(type as IType) as bool is override
		return true

	get csInit as String is override
		return 'null'

	get sharpRef as String is override
		return 'object'


class VoidType
	inherits ValueType  # TODO: change to CobraType
	"""
	This type is used only for methods that don't declare a return type and therefore cannot return
	anything.
	"""

	def init
		base.init()

	get englishName as String is override
		return 'void type'

	get name as String is override
		return 'void'

	get csInit as String is override
		throw Exception('Cannot init a void type.')


##
## Wrapped Types
##

class WrappedType
	inherits CobraType

	# TODO: flesh this out

	var _wrappedType as IType?
	var _wrappedTypeNode as INode?
	var _hashCode as int?
	var _didResolveType as bool

	def init(wrappedType as IType)
		base.init()  # TODO: ? pass wrappedType.superType
		_wrappedType = wrappedType
		_wrappedTypeNode = nil

	def init(wrappedTypeNode as INode)
		base.init()
		_wrappedType = nil
		_wrappedTypeNode = wrappedTypeNode

	def addMinFields
		base.addMinFields
		.addField('didResolveType', _didResolveType)

	def addRefFields is override
		base.addRefFields()
		.addField('wrappedTypeNode', _wrappedTypeNode)
		.addField('wrappedType', _wrappedType)

	def equals(obj as Object) as bool is override
		if this is obj
			return true
		if obj is nil
			return false
		if this.getType is not obj.getType
			return false
		# at this point, not the identical object, but the type is the same
		assert obj inherits WrappedType
		wt = obj to WrappedType  # CC: shouldn't need this due to the assertion just above
		if _wrappedType and wt._wrappedType
			return _wrappedType.equals(wt._wrappedType)
		else if _wrappedTypeNode and wt._wrappedTypeNode
			return _wrappedTypeNode.equals(wt._wrappedTypeNode)
		else
			throw FallThroughException([this, obj])
		return false

	def getHashCode as int is override
		if _hashCode is nil
			if _wrappedTypeNode
				_hashCode = _wrappedTypeNode.getHashCode()
			else if _wrappedType
				_hashCode = _wrappedType.getHashCode()
			else
				_hashCode = base.getHashCode()
		return _hashCode to int  # CC: to !

	# CC: this should work, but C# don't dig it.
	#get wrappedType from _wrappedType

	pro didResolveType from var
	
	get theWrappedType as IType?
		return _wrappedType

	get innerType as IType? is override
		# TODO: why doesn't this `require` work?
		# require .didResolveType
		# doing this instead
		if not .didResolveType
			_resolveType()
			_wrappedType.bindInt()
		return _wrappedType.innerType

	def _bindInt is override
		base._bindInt()
		_resolveType()

	def _bindImp is override
		base._bindImp()
		_resolveType()

	def _resolveType
		require _wrappedType or _wrappedTypeNode
		if _wrappedType
			return
		if _wrappedTypeNode inherits IType
			_wrappedType = _wrappedTypeNode to passthrough   # CC: shouldn't need the cast here
			return
		_wrappedType = (_wrappedTypeNode.bindAll() to ITypeProxy).realType
		if _wrappedType is nil
			.throwError('Cannot resolve type.')  # TODO: add the name of the wrappedTypeNode or something

	get csInit as String is override
		return _wrappedType.csInit


class ArrayType
	inherits WrappedType
	"""
	Represents a .NET array.
	Only single dimension arrays have been tested and are officially supported. These are common in
	the BCL as return types and sometimes as parameters. Multi-dim and jagged arrays are not popular.
	Also, most projects can get by just fine with nested List<of>s.
	TODO: Nevertheless, this should be expanded.
	TODO: Get this related to System.Array.
	"""

	test
		a1 = ArrayType(IntType())
		a2 = ArrayType(IntType())
		assert a1 is not a2
		assert a1==a2

	def init(wrappedType as IType)
		base.init(wrappedType)

	def init(wrappedTypeNode as INode)
		base.init(wrappedTypeNode)

	get englishName as String is override
		return 'array of ' + ''  # TODO: causes the compiler to choke: if(wrappedType, wrappedType.name, wrappedTypeNode.name)

	def indexType(argTypes as List<of IType>) as IType? is override
		return _wrappedType

	get innerType as IType? is override
		return _wrappedType

	get isReference as bool is override
		return true

	get name as String is override
		if _wrappedType
			return _wrappedType.name+r'[]'
		else
			return 'array UNBOUND'

	def isAssignableTo(type as IType) as bool is override
		if base.isAssignableTo(type)
			return true
		if type inherits ArrayType
			if _wrappedType==type.theWrappedType
				return true
		return false

	get sharpRef as String is override
		return '[_wrappedType.sharpRef]' + r'[]'

	get csInit as String is override
		return 'null'


class VariType
	inherits WrappedType
	"""
	Represents the type for variable number of arguments:
		def sumInts(nums as vari int)
	Not valid for non-parameters such as locals and class fields.
	"""

	def init(wrappedType as IType)
		base.init(wrappedType)

	def init(wrappedTypeNode as INode)
		base.init(wrappedTypeNode)

	get englishName as String is override
		return 'variable args type'

	def indexType(argTypes as List<of IType>) as IType? is override
		return _wrappedType

	get innerType as IType? is override
		return _wrappedType

	get isReference as bool is override
		return true

	get name as String is override
		if _wrappedType
			return 'vari ' + _wrappedType.name
		else
			return 'vari UNBOUND'

	def isAssignableTo(type as IType) as bool is override
		# TODO: should also be assignable to IEnumerable, I think
		return base.isAssignableTo(type)

	get sharpRef as String is override
		return 'params [_wrappedType.sharpRef]' + r'[]'


class QualifiedType
	inherits WrappedType
	"""
	Represents types such as SomeNamespace.SomeClass.SomeEnum.
	The parser has to track these namespace navigations in the code.
	"""

	var _initNodes as List<of AbstractTypeIdentifier>
	var _boundNodes as List<of Container>
	var _dottedParentNames as String?

	def init(nodes as IList<of AbstractTypeIdentifier>)
		require
			nodes
		body
			base.init(nodes[nodes.count-1])
			_initNodes = List<of AbstractTypeIdentifier>(nodes)
			_boundNodes = List<of Container>()  # set by _bindInt()
			_dottedParentNames = nil

	def addRefFields is override
		base.addRefFields()
		.addField('boundNodes', _boundNodes)

	def addSubFields is override
		base.addSubFields()
		.addField('initNodes', _initNodes)
		if _dottedParentNames
			.addField('dottedParentNames', _dottedParentNames)

	get name as String is override
		sb = StringBuilder()
		for ti in _initNodes
			if sb.length
				sb.append('.')
			sb.append(ti.name)
		return sb.toString
		# TODO:
#		if false and _wrappedType
#			return _dottedParentNames to String + _wrappedType.name  # CC: axe the cast
#		else
#			nodes = Utils.join(', ', _initNodes)
#			return '[.getType.name]([nodes])'

	get englishName as String is override
		assert .didBindInt # TODO: try moving this to CobraType
		return _wrappedType.englishName

	def memberForName(name as String) as IMember? is override
		assert .didBindInt
		assert _wrappedType  # TODO: can CobraType require a wrappedType
		return _wrappedType.memberForName(name)

	def toString as String is override
		if _dottedParentNames is nil
			return .name
		else
			return '[_dottedParentNames].[_wrappedType]'

	def isDescendantOf(type as IType) as bool is override
		assert .didBindInt
		return _wrappedType.isDescendantOf(type)

	get isReference as bool is override
		assert .didBindInt
		return _wrappedType.isReference

	def indexType(argTypes as List<of IType>) as IType? is override
		assert .didBindInt
		return _wrappedType.indexType(argTypes)

	get innerType as IType? is override
		assert .didBindInt
		return _wrappedType.innerType

	def _bindInt is override
		# TODO?: base._bindInt()
		_dottedParentNames = ''
		prevNode as Container? = nil
		node as INode? = nil
		sep = ''
		for initNode in _initNodes
			isLast = initNode is _initNodes[_initNodes.count-1]  # CC: ... _initNodes.last
			if prevNode is nil
				initNode.bindInt()
				node = initNode.realType
				if node inherits Container
					node.bindInt()
					_boundNodes.add(node)
					prevNode = node
					if not isLast
						_dottedParentNames += sep + node.name
				else
					assert false, node
			else
				node = initNode.memberFrom(prevNode to Container)  # CC: axe cast if "else" is smart about "not nil"
				if node is nil
					# TODO: there is no line number info because this is a type, not a syntax node.
					# ANOTHER example of how QualifiedType needs to be reworked.
					.throwError('*** Cannot find "[initNode.name]" in [prevNode.name] at line [initNode.token.lineNum].') #  nodes = [CobraCore.toTechString(_initNodes)]')
				if node inherits Container
					node.bindInt()
					_boundNodes.add(node)
					prevNode = node
					if not isLast
						_dottedParentNames += sep + node.name
				else
					assert false, node
			sep = '.'
		_wrappedType = _boundNodes[_boundNodes.count-1]
		base._bindInt()

	get superType as IType? is override
		assert .didBindInt
		return _wrappedType.superType

	## Code gen

	get sharpRef as String is override
		return '[_dottedParentNames].[_wrappedType.sharpRef]'

	get csInit as String is override
		cs = _wrappedType.csInit
		if cs<>'null'
			cs = _dottedParentNames to String + '.' + cs  # CC: axe cast
		return cs


class UnspecifiedType
	inherits CobraType
	"""
	This is for the compiler's internal use.
	See CobraParser.localVarDecl() and the methods that use it.
	"""

	pass


class TypeType
	inherits CobraType

	def init
		base.init()

	get englishName as String is override
		return 'type for types'

	get isReference as bool is override
		return true

	get name as String is override
		return 'Type'

	def isAssignableTo(type as IType) as bool is override
		b = base.isAssignableTo(type)
		b = b or type is .compiler.libraryType('System', 'Type')
		return b

	get csInit as String is override
		return 'null'


class AbstractTypeIdentifier
	inherits SyntaxNode
	implements ITypeProxy
	"""
	The ancestor class for specific kinds of type identifiers including TypeIdentifier, GenericTypeIdentifier, WrappedTypeIdentifier and more.
	"""

	var _name as String
	var _actualType as IType? is private
	var _didResolveType as bool is private

	def init(token as IToken, name as String)
		base.init(token)
		_name = name

	def init(token as IToken, name as String, type as IType)
		.init(token, name)
		_actualType = type
		_didResolveType = true

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)
		.addField('didResolveType', _didResolveType)

	def addRefFields is override
		base.addSubFields()
		.addField('actualType', _actualType)

	get name from var

	get actualType from var

	get didResolveType from var
	
	get realType as IType?
		ensure .actualType
		if not .didBindInt
			.bindInt
		if not .didResolveType
			_actualType = _resolveType()  # CC: axe parens
			assert .actualType
			didResolveType = true
		assert _actualType
		return _actualType

	def equals(other as Object) as bool is override
		if other is nil
			return false
		if this is other
			return true
		if other inherits AbstractTypeIdentifier
			if _actualType and other._actualType
				return _actualType.equals(other._actualType)
			else
				return _name.equals(other._name)
		return false

	def getHashCode as int is override
		return _name.getHashCode()

	def memberFrom(container as Container) as IMember?
		"""
		Used to get the real member represented by this type identifier in container.
		Used for qualified types such as:
			System.Windows.Forms.Control
			System.Collections.Generic.List<of String>
		The default implementation is:
			return container.memberForName(.name)
		Generics have to do more work, though.
		"""
		return container.memberForName(.name)

	def _bindInt is override
		base._bindInt()

	def _bindImp is override
		base._bindImp()
		# A TypeIdentifier can be given a type that is constructed
		# during parsing (such as a QualifiedType). Consequently, it may
		# not have gotten a bindInt() and without one, it will barf at
		# some point. So:
		# TODO: this may be axeable when QualifiedType is retired
		# then again, generic types are constructed as well (but then maybe they can be bound upon construction)
		# TODO: axe this
		.realType.bindInt()

	def _resolveType as IType
		"""
		Invoked by .realType only when needed.
		Subclasses must override to compute and return the actual type that this identifier represents (or invoke `.throwError('...')`).
		Subclasses should not bother with other operations such as checking or setting _actualType or _didResolveType to true.
		Subclasses need not invoke `base`.
		"""
		return nil to passthrough  # CC: throw an exception when Cobra code flow analysis is implemented


class WrappedTypeIdentifier
	inherits AbstractTypeIdentifier

	var _typeId as AbstractTypeIdentifier

	def init(token as IToken, typeId as AbstractTypeIdentifier)
		require
			token.text
		ensure
			.name
		body
			base.init(token, token.text)
			_typeId = typeId

	get theWrappedTypeIdentifier from _typeId

	def _bindInt is override
		_typeId.bindInt()
		base._bindInt()

	def _bindImp is override
		_typeId.bindImp()
		base._bindImp()


class ArrayTypeIdentifier
	inherits WrappedTypeIdentifier

	def init(token as IToken, typeId as AbstractTypeIdentifier)
		base.init(token, typeId)

	def memberFrom(container as Container) as IMember? is override
		return container.memberForName(.theWrappedTypeIdentifier.name)

	def _resolveType as IType is override
		assert _typeId.realType
		return ArrayType(_typeId.realType)
		

class NilableTypeIdentifier
	inherits WrappedTypeIdentifier

	def init(token as IToken, typeId as AbstractTypeIdentifier)
		base.init(token, typeId)

	def _resolveType as IType is override
		assert _typeId.realType
		return NilableType(_typeId.realType)
		

class TypeIdentifier
	inherits AbstractTypeIdentifier
	"""
	Created by CobraParser.type() for identifiers found where types are
	expected.

	Cobra allows forward references so even though types are expected in
	places like the return type of a method, they cannot be turned into
	actual types until the bindInt phase (or bindImp for expressions).
	"""

	def init(token as IToken)
		require
			token.which=='ID'
			token.value
		ensure
			.name
		body
			base.init(token, token.text)

	def init(token as IToken, type as IType)
		require
			token.text
		ensure
			.name
		body
			base.init(token, token.text, type)

	def init(token as IToken, name as String, type as IType)
		"""
		Use this to dictate a name other than what is specified by the token.
		Used for QualifiedTypes, for example, that are created from multiple tokens.
		"""
		require
			name
		ensure
			.name
		body
			base.init(token, name, type)
			assert name == token.text or type inherits QualifiedType

	def _resolveType as IType is override
		# don't need to check "basic types" like int, bool, etc. here. the parser does those.
		if Utils.isCapped(_name)
			symbol = .compiler.symbolForName(.name, true, false)  # nested enum and class types are capped and can be members of the current class
		else
			symbol = nil
		if symbol is nil
			sugg = ''
			if not Utils.isCapped(_name)
				sugg = Utils.capped(_name)
				other = .compiler.symbolForName(sugg, true, false)
				sugg = if(other, ' Try "[sugg]".', '')
			.throwError('Cannot find type for "[_name]".[sugg]')
		if symbol inherits ITypeProxy
			return symbol.realType to IType  # CC: axe cast
		else
			throw FallThroughException(symbol)


class GenericTypeIdentifier
	inherits AbstractTypeIdentifier
	"""
	The parser produces these when it encounters "List<of String>", for example.
	"""

	var _rootName as String  # ex: 'List'
	var _fullName as String  # ex: 'List<of String>'
	var _typeRefName as String # ex: 'List<of>' 'IDictionary<of,>' -- matches the actual box

	var _typeNodes as List<of ITypeProxy>

	def init(token as IToken, rootName as String, typeNodes as List<of ITypeProxy>, fullName as String)
		require
			token.which=='OPEN_GENERIC'
			rootName
			fullName
		body
			base.init(token, fullName)
			_rootName = rootName
			_typeNodes = typeNodes
			_fullName = fullName
			_typeRefName = _rootName + '<of'
			for i = 0 .. _typeNodes.count-1
				_typeRefName += ','
			_typeRefName += '>'

	def memberFrom(container as Container) as IMember? is override
		# happens for a qualified generic. See ../Tests/160-qualified/200-qual-generic.cobra
		genericType = container.memberForName(_typeRefName)
		assert genericType
		return _locateType(genericType to IMember) # CC: axe cast

	def _resolveType as IType is override
		genericType = .compiler.symbolForName(_typeRefName, Utils.isCapped(_name), false)
		if genericType is nil
			.throwError('Cannot find a generic type named "[_typeRefName]".')
		return _locateType(genericType to IMember)  # CC: axe cast

	def _locateType(genericType as IMember) as IType
		if genericType inherits IType
			gt as IType = genericType to IType  # CC: shouldn't need this local. if-inherits looks broken for interfaces
			if not gt.isGeneric
				.throwError('"[_rootName]" is not a generic type.')
			types = List<of IType>()
			for tn in _typeNodes
				tn.bindInt()
				types.add(tn.realType to IType)  # CC: to !
			if gt.genericParams.count<>types.count
				.throwError('The generic type "[_rootName]" expects [gt.genericParams.count] type arguments, not [types.count].')
			t = gt.constructedTypeFor(types)
			assert t
			assert t.isGeneric
			# TODO: is this a good idea or not? t.bindInt()
			# assert not t.isGenericDef  Wrong! If some of the parameters are generic, then the constructed type could have generic params...
			# ... hmmm, but am I using the wrong terms? Maybe the returned type is an open or closed constructed type and never a generic def. TODO: resolve this.
			return t
		else
			assert false, 'When does this happen?'
			.throwError('The definition for "[_fullName]" is not a type.')
			return nil to passthrough


class QualifiedTypeIdentifier
	inherits AbstractTypeIdentifier

	var _typeNodes as List<of AbstractTypeIdentifier>

	def init(typeNodes as List<of AbstractTypeIdentifier>)
		require typeNodes.count > 1
		base.init(typeNodes[0].token, '(uninitialized name)')
		_typeNodes = typeNodes
		sb = StringBuilder()
		sep = ''
		for t in typeNodes
			sb.append(sep)
			sb.append(t.name)
			sep = '.'
		_name = sb.toString
		# TODO: would it be useful to set the _token.text to the name? Maybe it would help with syntax highlighting

	def _resolveType as IType is override
		member = .compiler.symbolForName(_typeNodes[0].name, true, false)
#		print
#		print '_resolveType'
#		trace _typeNodes
#		trace member
		i = 1
		while i < _typeNodes.count and member <> nil
			if member inherits IContainer
#				trace i
#				trace _typeNodes[i].name
				m = member.memberForName(_typeNodes[i].name)
#				n = member.declForName(_typeNodes[i].name)
#				trace m
#				trace n
				if m
					$sharp('member = m')
				else
					.throwError('Cannot find "[_name]" at component [i+1].')
				i += 1
			else
				.throwError('"[member]" cannot contain additional members.')
		if member inherits IType
			return member
		else
			.throwError('The definition for "[_name]" is not a type.')
			return nil to passthrough  # CC: axe when 'always throws' for methods is available
