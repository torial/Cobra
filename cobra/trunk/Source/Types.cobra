interface ITypeProvider
	"""
	A type provider can provide essential types and serve as a place
	they are "uniqued" in order to avoid type duplication.
	"""

	def typeForName(name as String) as IType

	def typeOrNilForName(name as String) as IType?

	get boolType as BoolType

	get dynamicType as DynamicType

	get passThroughType as PassThroughType

	def variType(type as IType) as VariType

	def variType(typeNode as INode) as VariType


interface IType
	inherits INode

	get name as String

	get csInit as String

	def isAssignableTo(type as IType) as bool


class CobraType
	inherits Node
	implements IType

	def construct
		base.construct()

	get name as String
		return ''

	def isAssignableTo(type as IType) as bool
		throw OverrideException()
		return false

	get csInit as String
		throw OverrideException()


class IntType
	inherits CobraType

	def construct
		base.construct()


class BoolType
	inherits CobraType

	def construct
		base.construct()


class DynamicType
	inherits CobraType
	"""
	TODO: flesh out DynamicType
	"""

	pass


class PassThroughType
	inherits CobraType
	"""
	This is a temporary helper type used while Cobra is still deficient in type checking mostly
	due to its inability to look up methods, properties, etc.

	Originally it overrode isDescendantOf() to always return true, but this mislead the C#
	code generation. The override was removed and now you have to check for it explicitly.

	TODO: remove this class
	"""

	def construct
		base.construct()

	get csInit as String is override
		return 'null'

	def isAssignableTo(type as IType) as bool is override
		return true


##
## Wrapped Types
##

class WrappedType
	inherits CobraType

	# TODO: flesh this out

	var _wrappedType as IType?
	var _wrappedTypeNode as INode?

	def construct(wrappedType as IType)
		base.construct()  # TODO: ? pass wrappedType.superType
		_wrappedType = wrappedType
		_wrappedTypeNode = nil

	def construct(wrappedTypeNode as INode)
		base.construct()
		_wrappedType = nil
		_wrappedTypeNode = wrappedTypeNode

	def _bindInt is override
		_resolveType()

	def _bindImp is override
		_resolveType()

	def _resolveType
		require _wrappedType! or _wrappedTypeNode!
		if _wrappedType!
			return
		if _wrappedTypeNode inherits IType
			_wrappedType = _wrappedTypeNode to passthrough   # CC: shouldn't need the cast here
			return
		_wrappedType = _wrappedTypeNode.bindAll().namedType
		if _wrappedType is nil
			_error('Cannot resolve type.')  # TODO: add the name of the wrappedTypeNode or something


class VariType
	inherits WrappedType
	"""
	TODO: flesh out VariType
	"""

	def construct(wrappedType as IType)
		base.construct(wrappedType)

	def construct(wrappedTypeNode as INode)
		base.construct(wrappedTypeNode)


class TypeIdentifier
	inherits SyntaxNode
	"""
	Created by CobraParser.type().
	"""
	# ? inherits AbstractTypeIdentifier

	var _name as String
	var _actualType as IType?

	def construct(token as IToken)
		require
			token.which=='ID'
			token.value
		ensure
			.name
		code
			base.construct(token)
			_name = token.value to String

	get name from var

	def equals(other as Object) as bool is override
		if other is nil
			return false
		if other inherits TypeIdentifier
			if _actualType and other._actualType
				return _actualType.equals(other._actualType)
			else
				return _name.equals(other._name)
		return this is other

	def getHashCode as int is override
		return _name.getHashCode()

	def _bindInt is override
		base._bindInt()
		# don't need to check "basic types" like int, bool, etc. here. the parser does those.
		if Utils.isCapped(_name)
			symbol = .compiler.symbolForName(.name, true)  # nested enum and class types are capped and are members of the current class
		else
			symbol = nil
		if symbol is nil
			sugg = ''
			if not Utils.isCapped(_name)
				sugg = Utils.capped(_name)
				other = .compiler.symbolForName(sugg, true)
				sugg = if(other, ' Try "[sugg]".', '')
			_error('Cannot find type for "[_name]".[sugg]')

		what = symbol.namedType
		assert what!
		_actualType = what
