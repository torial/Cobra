interface ITypeProvider
	"""
	A type provider can provide essential types and serve as a place
	they are "uniqued" in order to avoid type duplication.
	"""

	def typeForName(name as String) as IType

	def typeOrNilForName(name as String) as IType?

	get boolType as BoolType

	get dynamicType as DynamicType

	get passThroughType as PassThroughType

	def variType(type as IType) as VariType

	def variType(typeNode as INode) as VariType


interface IType
	inherits INode

	get name as String

	get csInit as String

	def isAssignableTo(type as IType) as bool


class CobraType
	inherits Node
	implements IType

	def construct
		base.construct()

	get name as String
		return ''

	def isAssignableTo(type as IType) as bool
		throw OverrideException()
		return false

	get csInit as String
		throw OverrideException()


class IntType
	inherits CobraType

	def construct
		base.construct()


class BoolType
	inherits CobraType

	def construct
		base.construct()


class DynamicType
	inherits CobraType
	"""
	TODO: flesh out DynamicType
	"""

	pass


class PassThroughType
	inherits CobraType
	"""
	This is a temporary helper type used while Cobra is still deficient in type checking mostly
	due to its inability to look up methods, properties, etc.

	Originally it overrode isDescendantOf() to always return true, but this mislead the C#
	code generation. The override was removed and now you have to check for it explicitly.

	TODO: remove this class
	"""

	def construct
		base.construct()

	get csInit as String is override
		return 'null'

	def isAssignableTo(type as IType) as bool is override
		return true


##
## Wrapped Types
##

class WrappedType
	inherits CobraType

	# TODO: flesh this out

	var _wrappedType as IType?
	var _wrappedTypeNode as INode?

	def construct(wrappedType as IType)
		base.construct()  # TODO: ? pass wrappedType.superType
		_wrappedType = wrappedType
		_wrappedTypeNode = nil

	def construct(wrappedTypeNode as INode)
		base.construct()
		_wrappedType = nil
		_wrappedTypeNode = wrappedTypeNode

	def _bindInt is override
		_resolveType()

	def _bindImp is override
		_resolveType()

	def _resolveType
		require _wrappedType! or _wrappedTypeNode!
		if _wrappedType!
			return
		if _wrappedTypeNode inherits IType
			_wrappedType = _wrappedTypeNode to passthrough   # CC: shouldn't need the cast here
			return
		_wrappedType = _wrappedTypeNode.bindAll().namedType
		if _wrappedType is nil
			_error('Cannot resolve type.')  # TODO: add the name of the wrappedTypeNode or something


class VariType
	inherits WrappedType
	"""
	TODO: flesh out VariType
	"""

	def construct(wrappedType as IType)
		base.construct(wrappedType)

	def construct(wrappedTypeNode as INode)
		base.construct(wrappedTypeNode)
