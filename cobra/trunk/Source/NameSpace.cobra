

class NameSpace
	inherits Container  # TODO: in python version, inherited Type. should implement IType?

	var _superNameSpace as NameSpace?
	var _type as IType
	var _subNameSpaces as Dictionary<of String, NameSpace>

	def init(token as IToken, name as String)
		.init(token, name, nil, nil)

	def init(token as IToken, name as String, superNameSpace as NameSpace?)
		.init(token, name, superNameSpace, nil)

	def init(token as IToken, name as String, superNameSpace as NameSpace?, docString as String?)
		base.init(token, name, docString)
		_superNameSpace = superNameSpace
# TODO:		_type = tnamespace
		_subNameSpaces = Dictionary<of String, NameSpace>()

	get isGlobal as bool
		return _superNameSpace is nil and _name=='(global)'

	get superNameSpace from var

	def addMinFields is override
		base.addMinFields()
		.addField('subCount', _subNameSpaces.count)

	def addRefFields is override
		base.addRefFields()
		.addField('superNameSpace', _superNameSpace)
		.addField('type', _type)

#	@property
#	def fullyQualifiedName(self):
#		parts = []
#		ns = self
#		while ns is not nil and ns.name!='global':
#			parts.append(ns)
#			ns = ns.superNameSpace
#		parts.reverse()
#		fqn = '.'.join([ns.name for ns in parts])
#		return fqn

	def getOrMakeNameSpaceNamed(token as IToken, name as String) as NameSpace  # CC: same
		"""
		Returns the existing sub-namespace with the given name or creates it.
		Raises ValueError if there is a declaration in the namespace with the given name that is not a namespace.
		"""
		# TODO: enforce that case must match and 2 decls cannot be the same but for case. You cannot have a namespace FooBar and class Foobar under the same namespace
		if _subNameSpaces.containsKey(name)
			ns = _subNameSpaces[name]
		else
			if _declsByName.containsKey(name)
				throw Exception('There is a non-namespace declaration named "[name]".')
			ns = NameSpace(token, name, this)  # TODO: replace hardcoded class
			.addDecl(ns)
		return ns

	get typeForIdentifier as IType? is override
		# TODO: in reality, you can't say "x = SomeNameSpace" or pass a
		# namespace as an argument. That should be fixed by allowing those
		# things perhaps as some form of reflection where namespaces
		# become runtime objects. Or this property should return a new
		# .compiler.invalidType which then triggers an error if you try to
		# use it.
		return this

	get typeForReceiver as IType? is override
		return this

	def _bindInt is override
		base._bindInt()
		.compiler.nameSpaceStack.push(this)
		try
			for decl in _declsInOrder
				decl.bindInt()
		finally
			.compiler.nameSpaceStack.pop()

	def _bindImp is override
		base._bindImp()
		.compiler.nameSpaceStack.push(this)
		try
			for decl in _declsInOrder
				decl.bindImp()
		finally
			.compiler.nameSpaceStack.pop()

	def symbolForName(name as String) as IMember?
		# our name?
		if name==_name
			return this

		# our decl?
		x = .declForName(name)
		if x is not nil
			return x

		# a parent namespace?
		if _superNameSpace and not _superNameSpace.isGlobal  # Compiler will search the global namespace
			x = _superNameSpace.symbolForName(name)
			if x is not nil
				return x

		# inside a use directive?
		for decl in _declsInOrder
			if decl inherits UseDirective
				x = decl.findSymbol(name)
				if x is not nil
					return x
		return nil

#		else:
#			symbol = self.declsByName.get(name, nil)
#			if symbol is nil:
#				if name==self.name:
#					symbol = self
#				else:
#					for decl in self.declsInOrder:
#						if v: print '<> checking %s named %r' % (decl.__class__, decl.name)
#						if inherits(decl, UseDirective):
#							if v: print '<> will ask', decl.name, 'for', name
#							symbol = decl.symbolForName(name)
#							if symbol:
#								break
#		if symbol is nil and self.superNameSpace and self.superNameSpace.superNameSpace:  # that last expr is to avoid searching the global namespace (prematurely; the compiler will search it)
#			if v: print '<> will call super name space. self=%r, super=%r' % (self.name, self.superNameSpace.name)
#			symbol = self.superNameSpace.symbolForName(name, canBeMember)
#		if v:
#			sys.stdout.dedent()
#			print '<< NameSpace.symbolForName(%r, %s) self=%s, returning %s' % (name, canBeMember, self.name, symbol)
#		return symbol

	def addDecl(decl as IMember) is override
		base.addDecl(decl)
		if decl inherits NameSpace
			_subNameSpaces.add(decl.name, decl)  # TODO: add some require and ensure around the subNameSpaces
			assert decl.superNameSpace is this  # TODO: can this be moved to require?
#		decl.nameSpace = self  # @@@@ TODO: Do I need this?

	def subNameSpaceForName(name as String) as NameSpace?
		require name
		if _subNameSpaces.containsKey(name)
			return _subNameSpaces[name]
		else
			return nil

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		sw.writeAndIndent('namespace [.name] {\n\n')
		for decl in _declsInOrder
			decl.writeSharpDef(sw)
		sw.dedentAndWrite('} // namespace [.name]\n')

#	def asCS(self):
#		"""
#		Used in expressions.
#		"""
#		return self.name


class UseDirective
	inherits SyntaxNode
	implements IMember  # TODO: why is a UseDirective an IMember???

	var _nameParts as List<of String>
	var _boundNameSpace as NameSpace?
	var _fullName as String

	def init(token as IToken, nameParts as List<of String>)
		base.init(token)
		_nameParts = nameParts
		# CC: can't use String.join because it takes the parts as an array instead of IEnumerable<of String>. add that as an extension method.
		_fullName = Utils.join('.', nameParts)

	def addMinFields is override
		base.addMinFields()
		.addField('name', .name)

	get isCallable as bool
		return false

	def findSymbol(name as String) as IMember?
		if not .didBindInt
			return nil
		return _boundNameSpace.symbolForName(name)

	def _bindInt is override
		require .compiler.globalNS
		base._bindInt()
		curNS as NameSpace? = .compiler.globalNS  # CC: either "as ?" or "to ?"
		for name in _nameParts
			curNS = curNS.subNameSpaceForName(name)
			if curNS is nil
				break
		if curNS is nil
			_error('Cannot locate namespace "[_fullName]".')  # TODO: include last valid namespace
		# TODO: this assertion can be re-established when Cobra reads DLLs
		#assert curNS, 'last name=%r, self.dottedNames=%r' % (name, self.dottedNames)
		_boundNameSpace = curNS

	## IMember

	get englishName as String
		return 'use directive'

	get isShared as bool
		return true

	get name as String
		return '_use_[.serialNum]_[CobraCore.toTechString(_nameParts)]'  # TODO: clean this up a bit and give this an impossible prefix so it can't actually be referred to from a Cobra program

	get requiresThis as bool
		return false

	get resultType as IType
		assert false, 'should never use the result type of a UseDirective'

	## INamedNode

	get typeForIdentifier as IType?
		assert false, 'not expecting `typeForIdentifier` for UseDirective'

	get typeForReceiver as IType?
		assert false, 'not expecting `typeForReceiver` for UseDirective'

	## Code gen

	def writeSharpDef(sw as SharpWriter) is override
		sw.write('using [_fullName];\n')

	get sharpName as String
		throw UnexpectedInvocationException(this)

	def writeSharpTestInvocation(sw as SharpWriter)
		pass


class ArgumentException
	is fake
	inherits Exception
	pass
