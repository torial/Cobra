

class NameSpace
	inherits Container

	var _unifiedNameSpace as NameSpace?
	var _superNameSpace as NameSpace?
	var _subNameSpaces as Dictionary<of String, NameSpace>

	def init(unifiedNameSpace as NameSpace, name as String)
		.init(TokenFix.empty, name)
		_unifiedNameSpace = unifiedNameSpace
		
	def init(token as IToken, name as String)
		.init(token, name, nil, nil)

	def init(token as IToken, name as String, superNameSpace as NameSpace?)
		.init(token, name, superNameSpace, nil)

	def init(token as IToken, name as String, superNameSpace as NameSpace?, docString as String?)
		base.init(token, name, List<of String>(), docString)
		_superNameSpace = superNameSpace
		_subNameSpaces = Dictionary<of String, NameSpace>()

	get isGlobal as bool
		return _superNameSpace is nil and _name=='(global)'

	get isRoot as bool
		"""
		Returns true if this is a root namespace with no parent namespace.
		All module top-level namespaces are root as well as their common, unified namespace, the global namespace.
		"""
		return _superNameSpace is nil
		
	get isUnified as bool
		return _unifiedNameSpace is nil

	get superNameSpace from var

	get unifiedNameSpace from var
	
	def addMinFields is override
		base.addMinFields()
		.addField('subCount', _subNameSpaces.count)
		.addField('isUnified', .isUnified)

	def addRefFields is override
		base.addRefFields()
		.addField('superNameSpace', _superNameSpace)
		.addField('unifiedNameSpace', _unifiedNameSpace)

	get fullName as String
		ensure
			not .isRoot implies .name in result
			not result.startsWith('.')
			not result.endsWith('.')
		body
			# TODO: cache this
			t = List<of String>()
			ns = this to NameSpace?  # CC: to ?
			while ns and not ns.isRoot
				t.add(ns.name)
				ns = ns._superNameSpace
			t.reverse
			return Utils.join('.', t)
		
	def getOrMakeNameSpaceNamed(token as IToken, name as String) as NameSpace  # CC: same
		"""
		Returns the existing sub-namespace with the given name or creates it.
		Raises ValueError if there is a declaration in the namespace with the given name that is not a namespace.
		"""
		ensure result.superNameSpace is this
		# TODO: enforce that case must match and 2 decls cannot be the same but for case. You cannot have a namespace FooBar and class Foobar under the same namespace
		if _subNameSpaces.containsKey(name)
			ns = _subNameSpaces[name]
		else
			if _declsByName.containsKey(name)
				throw Exception('There is a non-namespace declaration named "[name]".')
			ns = NameSpace(token, name, this)
			if not .isUnified
				# mirror in the unified namespace
				uns = _unifiedNameSpace.getOrMakeNameSpaceNamed(token, name)
				assert uns.isUnified
				ns._unifiedNameSpace = uns
			.addDecl(ns)
		return ns

	get typeForIdentifier as IType? is override
		# TODO: in reality, you can't say "x = SomeNameSpace" or pass a
		# namespace as an argument. That should be fixed by allowing those
		# things perhaps as some form of reflection where namespaces
		# become runtime objects. Or this property should return a new
		# .compiler.invalidType which then triggers an error if you try to
		# use it.
		return this

	get typeForReceiver as IType? is override
		return this

	def _bindInt is override
		base._bindInt()
		.compiler.nameSpaceStack.push(this)
		try
			for decl in _declsInOrder
				decl.bindInt()
		finally
			.compiler.nameSpaceStack.pop()

	def _bindImp is override
		base._bindImp()
		.compiler.nameSpaceStack.push(this)
		try
			for decl in _declsInOrder
				decl.bindImp()
		finally
			.compiler.nameSpaceStack.pop()

	def symbolForName(name as String) as IMember?
		if not .isUnified
			x = _unifiedNameSpace.symbolForName(name)
			if x
				return x
			# inside a use directive?
			return _symbolForNameFromUseDirectives(name)
		else
			# our name?
			if name == _name
				return this

			# our decl?
			# TODO: should this come before checking our name? what does C# do?
			x = .declForName(name)
			if x
				return x

			# a parent namespace?
			if _superNameSpace
				x = _superNameSpace.symbolForName(name)
				if x
					return x

		return nil

	def _symbolForNameFromUseDirectives(name as String) as IMember?
		for decl in _declsInOrder
			if decl inherits UseDirective
				x = decl.findSymbol(name)
				if x
					return x
		if _superNameSpace
			return _superNameSpace._symbolForNameFromUseDirectives(name)
		else
			return nil

	def addDecl(decl as IMember) is override
		base.addDecl(decl)
		if decl inherits NameSpace
			assert decl.superNameSpace is this
			assert (.isUnified and decl.isUnified) or (not .isUnified and not decl.isUnified)
			_subNameSpaces.add(decl.name, decl)  # TODO: add some require and ensure around the subNameSpaces
		if decl inherits NameSpace
			assert decl.parentNameSpace is this or decl.parentNameSpace is nil
			decl.parentNameSpace = this
		else
			if decl.parentNameSpace
				assert .isUnified
				assert decl.parentNameSpace.unifiedNameSpace is this
			else
				assert not .isUnified
				decl.parentNameSpace = this
		if not .isUnified
			# mirror the declarations in the unified namespace
			if decl inherits NameSpace
				pass
			else if not decl inherits UseDirective
				_unifiedNameSpace.addDecl(decl)

	def subNameSpaceForName(name as String) as NameSpace?
		require name
		if _subNameSpaces.containsKey(name)
			return _subNameSpaces[name]
		else
			return nil

	get sharpRef as String is override
		return .fullName

	def writeSharpDef(sw as SharpWriter) is override
		assert not .isUnified
		base.writeSharpDef(sw)
		if not .isRoot
			sw.writeAndIndent('namespace [.name] {\n\n')
		for decl in _declsInOrder
			if decl inherits Box
				.compiler.boxStack.push(decl)
			decl.writeSharpDef(sw)
			if decl inherits Box
				.compiler.boxStack.pop
		if not .isRoot
			sw.dedentAndWrite('} // namespace [.name]\n')

	def writeSharpTestInvocation(sw as SharpWriter) is override
		for decl in _declsInOrder
			decl.writeSharpTestInvocation(sw)


class UseDirective
	inherits SyntaxNode
	implements IMember  # TODO: why is a UseDirective an IMember???
	# TODO: it seems that use directives should *not* be declarations of a namespace, but instead the namespace should simply have a list of use directives

	var _parentNameSpace as NameSpace?
	var _nameParts as List<of String>
	var _boundNameSpace as NameSpace?
	var _fullName as String

	def init(token as IToken, nameParts as List<of String>)
		base.init(token)
		_nameParts = nameParts
		# CC: can't use String.join because it takes the parts as an array instead of IEnumerable<of String>. add that as an extension method.
		_fullName = Utils.join('.', nameParts)

	def addMinFields is override
		base.addMinFields()
		.addField('name', .name)

	get isCallable as bool
		return false

	get isMethod as bool
		return false

	pro isUsed as bool
		get
			return true
		set
			pass

	pro parentNameSpace from var

	def findSymbol(name as String) as IMember?
		if not .didBindInt
			.bindInt
		if not .didBindInt
			return nil
		return _boundNameSpace.symbolForName(name)

	def _bindInt is override
		base._bindInt()
		curNS as NameSpace? = .compiler.globalNS  # CC: either "as ?" or "to ?"
		for name in _nameParts
			curNS = curNS.subNameSpaceForName(name)
			if curNS is nil
				break
		if curNS is nil
			.throwError('Cannot locate namespace "[_fullName]".')  # TODO: include last valid namespace
		# TODO: this assertion can be re-established when Cobra reads DLLs
		#assert curNS, 'last name=[name], dottedNames=[.dottedNames]'
		_boundNameSpace = curNS

	## IMember

	get englishName as String
		return 'use directive'

	get isShared as bool
		return true

	get name as String
		return '!_use_[.serialNum]_[CobraCore.toTechString(_nameParts)]'

	get requiresThis as bool
		return false

	get resultType as IType
		throw DoNotUseException('should never use the result type of a UseDirective')

	## INamedNode

	get typeForIdentifier as IType?
		throw DoNotUseException('not expecting `typeForIdentifier` for UseDirective')

	get typeForReceiver as IType?
		throw DoNotUseException('not expecting `typeForReceiver` for UseDirective')

	## Code gen

	def writeSharpDef(sw as SharpWriter) is override
		sw.write('using [_fullName];\n')

	get sharpName as String
		throw UnexpectedInvocationException(this)

	def writeSharpTestInvocation(sw as SharpWriter)
		pass
