class Expr
	inherits Stmt

	var _type as IType?
	var _receiverType as IType?
		"""
		The type for receiving messages which can be different than the
		_type in a static situation such as `ChessPiece.Color` (where
		Color is an enum). The type of that expression, if assigned to a
		local var, is Type. But if accessed with a further dot
		(`ChessPiece.Color.Black`), then the type is the Color
		enumeration itself--the receiverType.

		For a runtime access (ex: `user.name`) the two types are
		conceptually the same (ex: `String`) and _receiverType is left
		nil.

		_receiverType is used in memberForName() to look up members such
		as "Black".

		TODO: rename to _typeForMemberAccess
		"""

	def construct(token as IToken)
		base.construct(token)

	def addRefFields is override
		base.addRefFields()
		.addField('type', _type)

	pro type from var

	get receiverType as IType?  # TODO: consider renaming to typeForReceiver.
		return _receiverType ? _type

	def canBeAssignedTo(type as IType) as bool
		require
			.didBindImp
			.type
		code
			return .type.isAssignableTo(type)

	def toCobraSource as String
		return ''

	def isKindOf(type as IType) as bool
		require
			.type
			.compiler
		code
			# TODO: try pulling this if-statement out, since passThroughType should return true for isDescendantOf()
			if .type is .compiler.passThroughType
				return true
			return .type.isDescendantOf(type)

	def memberForName(name as String) as IMember?
		require
			.didBindImp
			.type
		code
			t = _receiverType ? _type  # TODO: change to .receiverType
			# TODO: change code below to something like. if container inherits IContainer ...
			while true
				if t inherits QualifiedType  # TODO: another example of QualifiedType being a pain
					wt = t.theWrappedType
					if wt is nil
						t.bindInt()
						wt = t.theWrappedType
						assert wt
					$sharp('t = wt')
				else
					break
			container = t to? IContainer
			if container!
				return container.memberForName(name)
			else
				# TODO: at some point this might be an error to access a member of a nilable type, but not for now...
				if t inherits NilableType
					nt = t to NilableType
					container = nt.theWrappedType to? IContainer
					if container!
						return container.memberForName(name)
				return nil

	get binarySuperNode as BinaryOpExpr
		require
			.superNode
			.superNode inherits BinaryOpExpr
		code
			return .superNode to BinaryOpExpr

	def bindImp as INode is override
		base.bindImp()
		assert .didBindImp, this
		.postBindImpAssertType()
		return this

	def postBindImpAssertType
		"""
		This is broken out because in rare cases, it doesn't apply. (Those classes override this to
		do nothing.)
		"""
		assert .type, this

	def _bindImp is override
		base._bindImp()
		if _type is nil and .getType().name=='Expr'  # CC: cannot say ... and .getType() is Expr
			# TODO: this happens with formatted strings, but why?
			# I mean, why does an Expr get created in the first place? Could put an assert in the constructor to trap it.
			_type = .compiler.passThroughType

	## Code gen

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		.writeSharpDef(sw, true)

	def writeSharpDef(sw as SharpWriter, parens as bool)
		pass

	def writeSharpStmt(sw as SharpWriter) is override
		assert .didBindImp
		.writeSharpSetLine(sw)
		.writeSharpDef(sw, false)
		sw.write(';\n')


class AsExpr
	inherits Expr
	"""
	i as int = 5
	The "i as int" is an AsExpr.
	"""

	var _name as String
	var _nameToken as IToken  # the identifier vs. the `as` keyword which is the main token
	var _typeNode as INode
	var _definition as INode?

	def construct(token as IToken, nameToken as IToken, typeNode as INode)
		base.construct(token)
		_nameToken = nameToken
		_name = nameToken.text
		_typeNode = typeNode

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addSubFields is override
		base.addSubFields()
		.addField('typeNode', _typeNode)
		.addField('definition', _definition)

	def _bindImp is override
		base._bindImp()
		_typeNode.bindAll()
		_type = _typeNode.namedType
		assert _type, _typeNode
		# make the local var if necessary (usually is)
		definition = .compiler.findLocal(_name)
		if definition is nil
			newVar = LocalVar(_nameToken, _type)
			newVar.bindAll()
			.compiler.codeMemberStack.peek().addLocal(newVar)
			_definition = newVar
		# TODO: check for redefinitions that are invalid by comparing .type with definition.type

	def afterStatementBindImp is override
		base.afterStatementBindImp()
		if not .type inherits NilableType
			if .type.isReference
				_error('Must initialize this non-nil object type, or change the type to nilable (suffix a ?).')

	get asSharp as String
		return _name

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write(.asSharp)

	def writeSharpStmt(sw as SharpWriter) is override
		# this happens for declarations like "i as int"
		sw.write('// [_name] as [_type.name]')


class CallExpr
	inherits Expr

	var _name as String
	var _args as List<of Expr>
	var _definition as INamedNode?

	def construct(token as IToken, name as String, args as List<of Expr>)
		base.construct(token)
		_name = name
		_args = args
		_definition = nil

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	def addSubFields is override
		base.addSubFields()
		.addField('args', _args)

	get name from var

	def _bindImp is override
		base._bindImp()

		for arg in _args
			arg.bindImp()

		definition as INamedNode?
		type as IType?

		if _definition is nil  or  _type is nil
			handled = false
			if _superNode inherits BinaryOpExpr
				if _superNode.op=='DOT' and this is _superNode.right
					checkName = _name
					while checkName.startsWith('_')
						checkName = checkName.substring(1)
					if checkName and Utils.startsNonLower(checkName)
						_error('Methods must start with lowercase letters (not counting underscores). The name is \"[_name]\".')
					# handle foo.bar() where this is the `bar()` part
					possibleDefinition = _superNode.left.memberForName(_name)
					if possibleDefinition is nil
						if _superNode.left.receiverType is .compiler.passThroughType
							type = .compiler.passThroughType
						else
							_error('Cannot find "[_name]" in [_superNode.left.receiverType.name].')
					else
						if not possibleDefinition.isCallable
							_error('Cannot call "[_name]" because it is a "[possibleDefinition.englishName]".')
						definition = possibleDefinition
						type = possibleDefinition.resultType
					handled = true
			if handled
				assert type is not nil
			else
				# handle instantiation such Car() or t() (where t is a System.Type)
				canBeMember = _name.startsWith('_') or Utils.isCapped(_name)
				if canBeMember
					assert .compiler.boxStack
					definition = .compiler.symbolForName(_name, canBeMember, false) to passthrough
				else
					definition = .compiler.findLocal(_name)
				if definition is nil
					_error('Cannot find "[_name]".')
			if definition is not nil
				if definition inherits IVar
					# such as having:
					#	t as Type
					#	...
					#	x = t()
					if definition.type.isDescendantOf(.compiler.libraryType('System', 'Type'))
						type = .compiler.libraryType('System', 'Object')  # TODO: should be dynamic type
					else
						_error('Cannot call a variable of type [definition.type.name].')
				else if definition inherits Box
					if definition inherits Interface
						_error('Cannot instantiate an interface.')
					else if definition inherits Class or definition inherits Struct
						# constructing an instance of a class or struct
						type = definition
					else
						# not ever expected since the three Box types are covered above
						throw FallThroughException(definition)
				else if definition inherits ClassMember
					type = definition.resultType  # NOTE: used to have .namedType at the end
					if definition inherits MemberOverload
						pass  # TODO handle overloads (1)
					else
						args = _args
						hasVari = false
						for param in definition.params
							if param.type inherits VariType
								hasVari = true
						if hasVari
							# TODO handle variable number of args (4)
							pass
						else
							check = true
							if not definition.hasParams
								if args.count
									_error('The method "[definition.name]" is expecting 0 arguments, but [args.count] are being supplied in this call.')
							else
								paramsx = definition.params  # CC: rename paramsx to params
								if args.count<>paramsx.count
									if _name=='toString'  # TODO because many structs like Decimal have a toString() overload which cannot currently be expressed in SystemInterfaces.cobra
										check = false
									else
										_error('The method "[definition.name]" is expecting [paramsx.count] arguments, but [args.count] are being supplied in this call.')
								if check
									for i = 0 .. args.count
										arg = args[i]
										paramx = paramsx[i]  # CC: rename paramx to param
										assert arg.didBindImp
										assert paramx.didBindInt
										if not arg.canBeAssignedTo(paramx.type)
		# TODO
		#									if paramx.type.__class__.__name__.startswith('GenericParam')
		#										# TODO support generic params (2)
		#										pass
		#									else
											if true
												if false
													print '<> arg = ' stop
													arg.writeDeepString()
													print '<> paramx = ' stop
													paramx.writeDeepString()
												_error('Argument [i+1] of method "[_name]" expects type [paramx.type.name], but the call is supplying type [arg.type.name].')
				else
					throw FallThroughException(definition)
			if type is nil
				type = .compiler.passThroughType
			_definition = definition
			_type = type
		assert _type, 'this=[this], def=[_definition]'

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_name)
		sb.append('(')
		sep = ''
		for arg in _args
			sb.append(sep)
			sb.append(arg.toCobraSource())
			sep = ', '
		sb.append(')')
		return sb.toString()

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		# TODO: axe
		#if .isNew
		#	if genParens
		#		out.write('(')
		#	out.write('new ')
		#name = .isDotted and capped(.name) or .name
		assert .superNode inherits DotExpr, .superNode  # TODO: could be wrong
		sw.write('[Utils.capped(_name)](')
		sep = ''
		for arg in _args
			sw.write(sep)
			arg.writeSharpDef(sw, false)
			sep = ', '
		sw.write(')')
		# TODO: axe
		#if .isNew
		#	if genParens
		#		out.write(')')


class IdentifierExpr
	inherits Expr

	var _text as String
	var _definition as INamedNode?

	def construct(token as IToken, text as String, definition as INamedNode?)
		base.construct(token)
		_text = text
		_definition = definition

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	pro definition from var

	get text from var

	get namedType as IType? is override
		# overridden to return the type this identifier represents in those cases when it does represent a type such an "int" or a class
		assert .didBindImp
		assert .type
		assert .compiler
		if .type.isDescendantOf(.compiler.typeType) or .type inherits Box
			assert .definition
			defi = .definition
			if defi inherits IType
				return defi
			else
				throw FallThroughException(defi)
		else
			return nil

	def memberForName(name as String) as IMember? is override
		require
			.didBindImp
			.definition
		code
			return _definition.typeForReceiver.memberForName(name)

	def _bindImp is override
		base._bindImp()
		if _definition is nil
			canBeMember = _text.startsWith('_') or Utils.isCapped(_text)  # isCapped could be an enum or, in the future, a nested class
			if canBeMember
				assert .compiler.boxStack
				_definition = .compiler.symbolForName(_text, canBeMember, false) to passthrough
			else
				_definition = .compiler.findLocal(_text)
			if _definition is nil and not canBeMember
				if _superNode inherits BinaryOpExpr
					if _superNode.right is this
						curBox = .compiler.boxStack.peek()  # TODO: would like to use compiler.curClass except that could be an interface or struct. compiler.curCompositeType
						definition = curBox.symbolForName(_text, true, true)
						if definition is not nil
							_error('You must refer to non-underscored members with a leading dot (.). Member name is "[_text]".')

			# TODO: The effect of using symbolForName() just above and the next 3 lines is that class members mask globals of the same name. This will become a problem when module-level functions are supported.
			#from Module import ClassMemberDecl
			#if compiler.opStack and compiler.opStack.peek()!='ASSIGN':  # don't interfere with type inference. tests\200-class-decls\508-properties-access.cobra
			#if isinstance(self.definition, ClassMemberDecl) and self.definition.requiresDotPrefix: # and not self.text.startswith('_'):
			#	self.error('You must refer to non-underscored members with a leading dot (.).')

			if _definition is nil and (not _superNode inherits BinaryOpExpr or .binarySuperNode.op<>'ASSIGN')
				msg = 'Unknown identifier: "[_text]".'
				sug = .compiler.suggestionFor(_text)
				if sug
					msg += ' Maybe you should try "[sug]".'
				_error(msg)
		if _type is nil
			if _definition
				_type = _definition.typeForIdentifier
			else
				if .binarySuperNode and .binarySuperNode inherits AssignExpr and this is .binarySuperNode.left
					pass  # let the AssignExpr have its chance at type inference
				else
					.errorUnknownId(.text)

	def postBindImpAssertType is override
		pass

	def toCobraSource as String is override
		return _text

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if .superNode inherits DotExpr
			sw.write(Utils.capped(_text))
		else
			# if this names a type and it's not dotted, then C# requires typeof()
			if _type inherits TypeType
				if .superNode is nil or .superNode inherits AssignExpr and .binarySuperNode.right is this and not .sharpName.startsWith('_lh')
					sw.write('typeof('+.sharpName+')')
					return
			sw.write(.sharpName)

	get sharpName as String
		assert .didBindImp, this
		assert .definition, this
		assert not .type inherits UnspecifiedType
		return if(.definition, .definition.sharpName, _text)

	# TODO?
#	def genCSStatement(self, out):
#		assert 0, 'not expecting to be called'

	# TODO?
#	@property
#	def csAssignmentNames(self):
#		assert self.didBindImp, self
#		assert self.definition, self
#		assert self.definition is not UnknownId
#		return self.definition.csAssignmentNames



class IfExpr
	inherits Expr

	var _cond as Expr
	var _tpart as Expr
	var _fpart as Expr

	def construct(token as IToken, cond as Expr, tpart as Expr, fpart as Expr)
		base.construct(token)
		_cond = cond
		_tpart = tpart
		_fpart = fpart

	def addSubFields is override
		base.addSubFields()
		.addField('cond', _cond)
		.addField('tpart', _tpart)
		.addField('fpart', _fpart)

	def _bindImp is override
		base._bindImp()
		tpart = _tpart
		fpart = _fpart
		_cond.bindImp()
		if not _cond.type.isDescendantOf(.compiler.boolType)
			_cond = TruthExpr(_cond)
		_tpart.bindImp()
		_fpart.bindImp()
		# @@ TODO: use greatest common denominator between the 2 types. Right now if() expects that one inherits the other or one of them is nil.
		assert tpart.type
		assert fpart.type
		if tpart.isKindOf(fpart.type to IType)  # CC: change: to !
			_type = fpart.type
		else if fpart.isKindOf(tpart.type to IType)  # CC: change: to !
			_type = tpart.type
		else if fpart.isKindOf(.compiler.nilType)
			_type = .compiler.nilableType(tpart.type to IType)  # CC: change: to !
		else if tpart.isKindOf(.compiler.nilType)
			_type = .compiler.nilableType(fpart.type to IType)  # CC: change: to !
		else
			_error('The return expressions of the if() do not have compatible types. They are "[tpart.type.name]" and "[fpart.type.name]".')

#	def genCS(self, out, genParens=true):
#		out.write('(')
#		self.cond.genCS(out)
#		out.write('?')
#		self.tpart.genCS(out)
#		out.write(':')
#		self.fpart.genCS(out)
#		out.write(')')


class IndexExpr
	inherits Expr

	var _target as Expr
	var _args as List<of Expr>

	def construct(token as IToken, target as Expr, args as List<of Expr>)
		base.construct(token)
		_target = target
		_args = args

	def addSubFields is override
		base.addSubFields()
		.addField('target', _target)
		.addField('args', _args)

	def _bindImp is override
		base._bindImp()
		_target.bindImp()
		for arg in _args
			arg.bindImp()  # TODO: error recovery
		if _type is nil
			# CC: use a list comprehension to get the types
			# _target.type.indexType(for arg in _args get arg.type)
			argTypes = List<of IType>()
			for arg in _args
				argTypes.add(arg.type)
			_type = _target.type.indexType(argTypes)
			if _type is nil
				_type = .compiler.passThroughType



class IsNilExpr
	inherits Expr

	def construct(token as IToken, expr as Expr)
		base.construct(token)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType


class IsNotNilExpr
	inherits Expr

	def construct(token as IToken, expr as Expr)
		base.construct(token)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType


class MemberExpr
	inherits Expr
	"""
	Example members are fields and properties.
	"""

	var _name as String
	var _definition as IMember?

	def construct(token as IToken, name as String)
		base.construct(token)
		_name = name

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	def _bindImp is override
		require
			.superNode inherits BinaryOpExpr
			.binarySuperNode.op == 'DOT'
			.binarySuperNode.right is this
		ensure
			true or .type  # TODO: get rid of true @@@@@ # CC: should really be the ensure of Expr
		code
			base._bindImp()
			if _definition is nil or _type is nil
				_definition = .binarySuperNode.left.memberForName(_name)
				if _definition is nil
					if .binarySuperNode.left.receiverType is .compiler.passThroughType
						_type = .compiler.passThroughType
						return
					if _name=='length'
						# TODO get rid of this total hack to support the vari type (and possibly arrays in general)
						_type = .compiler.intType
						.binarySuperNode.type = .type
						return
					if Utils.isCapped(_name)
						sugg = 'If the name is essentially correct, try the lowercase version ("[Utils.uncapped(_name)]") instead.'
					else
						sugg = ''
					_error('Cannot find a definition for "[_name]" in "[.binarySuperNode.left.token.text]" whose type is "[.binarySuperNode.left.receiverType.name]". [sugg]')
				assert _definition
				if _definition inherits IType
					effectiveType as IType = .compiler.typeType  # namespace, class, interface
					receiverType as IType? = _definition to IType  # TODO: should not need "as IType". Type inference is not respecting the if-inherits stack
				else
					effectiveType = _definition.resultType
					receiverType = nil
				assert effectiveType
				_type = effectiveType
				_type.bindImp()  # @@@@ TODO: should be bindInt
				# TODO: there should be a subclass of BinaryOpExpr called DotExpr and it should do the following work and maybe even the work above.
				# TODO: _receiverType = receiverType
				.binarySuperNode.definition = _definition  # TODO: is this needed?
				.binarySuperNode.type = .type  # the type of foo.bar is what bar returns. A MemberExpr is the "bar" part.
				.binarySuperNode.setReceiverType(receiverType)
			assert _type
			_type.bindImp()  # @@@@ TODO: should be bindInt

	def toCobraSource as String is override
		return _name

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		assert .superNode inherits DotExpr
		sw.write(Utils.capped(_name))


class OldExpr
	inherits Expr

	var _expr as Expr

	def construct(token as IToken, expr as Expr)
		base.construct(token)
		_expr = expr

	get name as String
		return 'old'

	def addSubFields is override
		base.addSubFields()
		.addField('expr', _expr)

	def _bindImp is override
		base._bindImp()
		curCodeMember = .compiler.codeMemberStack.peek()
		assert curCodeMember
		curCodeMember.addOldExpr(this)  # will set the csVarName
		_expr.bindImp()
		_type = _expr.type
		assert _type

# TODO:
#	def genCSAssignment(self, out):
#		assert self.didBindImp
#		assert self.csVarName
#		assert self.type
#		out.write('%s %s = ' % (self.type.asCS(), self.csVarName))
#		self.expr.genCS(out)
#		out.write(';\n')

# TODO:
#	def genCS(self, out):
#		assert self.csVarName
#		# this gets called when generating the `ensure` code
#		out.write(self.csVarName)


class PostCallExpr
	inherits Expr
	"""
	Covers cases like:
		obj[i]('x')
	For "bar.foo('x')" that's a binary dot expression with a CallExpr on the right hand side.
	For "Car()" or "someType()" that's also a CallExpr.
	"""

	var _expr as Expr
	var _args as List<of Expr>

	def construct(token as IToken, expr as Expr, args as List<of Expr>)
		base.construct(token)
		_expr = expr
		_args = args

	def addSubFields is override
		base.addSubFields()
		.addField('expr', _expr)
		.addField('args', _args)

	def _bindImp is override
		base._bindImp()
		for arg in _args
			arg.bindImp()
		_expr.bindImp()
		if _expr inherits TypeExpr
			assert _expr.containedType
			_type = _expr.containedType
		else
			assert false, 'what is this? _expr=[_expr]'

	def toCobraSource as String is override
		assert false, 'TODO'
		return ''
#		sb = []
#		sb.append(_expr.toCobraSource())
#		sb.append('(')
#		sep = ''
#		for arg in _args
#			sb.append(sep)
#			sb.append(arg.toCobraSource())
#			sep = ', '
#		sb.append(')')
#		return ''.join(sb)

#	def genCS(out, genParens=false)
#		if genParens
#			out.write('(')
#		#out.write('(')
#		#print '<> post call expr, _expr class=%r' % _expr.className
#		if inherits(_expr, TypeExpr)
#			out.write('new ')
#		_expr.genCS(out)
#		#out.write(')')
#		out.write('(')
#		sep = ''
#		for arg in _args
#			assert inherits(arg, Expr)
#			out.write(sep)
#			arg.genCS(out, genParens=false)
#			sep = ','
#		out.write(')')
#		if genParens
#			out.write(')')


class SharpExpr
	inherits Expr

	var _expr as StringLit

	def construct(token as IToken, expr as Expr)
		base.construct(token)
		if expr inherits StringLit  # TODO:? make this an arg type
			_expr = expr
		else
			assert false, expr

	def _bindImp is override
		base._bindImp()
		_type = .compiler.passThroughType
		_expr.bindImp()

#	def genCS(self, out, genParens=true):
#		if genParens:
#			out.write('(')
#		out.write(self.expr.token.value)
#		if genParens:
#			out.write(')')


class TruthExpr
	inherits Expr
	"""
	A truth expr wraps an expression such that it can be used where a bool is expected in .NET/C#.
	For example, if passed an integer typed expression, the truth expression will wrap it with a
	comparison 0!=expr.
	"""

	var _useRuntimeService as bool
	var _expr as Expr

	def construct(expr as Expr)
		base.construct(expr.token)
		_useRuntimeService = false
		_expr = expr

	def addSubFields is override
		base.addSubFields()
		.addField('useRuntimeService', _useRuntimeService)
		.addField('expr', _expr)

	get expr from var

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		if _expr.type is not .compiler.boolType
			if _expr.isKindOf(.compiler.passThroughType)
				_useRuntimeService = true
			else if _expr.isKindOf(.compiler.numberType)
				_expr = CompareExpr(_expr.token, 'NE', IntegerLit(_expr.token, 0), _expr)
			else if $sharp('_expr is NilLiteral')
				_expr = BoolLit(_expr.token, false)
			else
				_useRuntimeService = true
			_expr.bindImp()
		_type = .compiler.boolType

	def toCobraSource as String is override
		return _expr.toCobraSource()

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _useRuntimeService
			sw.write('CobraImp.IsTrue(')
			_expr.writeSharpDef(sw, false)
			sw.write(')')
		else
			_expr.writeSharpDef(sw, parens)


class TypeExpr
	inherits Expr

	var _typeNode as ISyntaxNode?
	var _containedType as IType?

	def construct(typeNode as ISyntaxNode)
		base.construct(typeNode.token)
		_typeNode = typeNode

	def construct(token as IToken, type as IType)
		base.construct(token)
		_containedType = type
		_receiverType = type

	get containedType from var

	def addRefFields is override
		base.addRefFields()
		.addField('containedType', _containedType)

	def addSubFields is override
		base.addSubFields()
		.addField('typeNode', _typeNode)

	def _bindImp is override
		base._bindImp()
		if _typeNode is not nil
			_typeNode.bindImp()
			t = _typeNode.namedType
			if t is nil
				assert false, 'when does this happen?'
			if t is not nil
				_containedType = t
				_receiverType = t
		_type = .compiler.typeType


class UnaryOpExpr
	inherits Expr

	var _expr as Expr

	def construct(token as IToken, op as String, expr as Expr)
		base.construct(token)
		_expr = expr

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		if _type is nil
			_type = _expr.type


##
## Literals
##

class Literal
	inherits Expr

	def construct(token as IToken)
		base.construct(token)

	get asSharp as String
		return ''

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write(.asSharp)


class AtomicLiteral
	inherits Literal

	var _text as String

	def construct(token as IToken)
		base.construct(token)
		_text = token.text

	def bindImp as INode is override
		base.bindImp()
		.checkType()
		return this

	def checkType
		assert _type, this

	def _bindImp is override
		base._bindImp()

	def toCobraSource as String is override
		return _text


class BoolLit
	inherits AtomicLiteral

	var _value as bool

	def construct(token as IToken)
		require token.text in ['true', 'false']
		base.construct(token)
		_value = token.text=='true'

	def construct(token as IToken, value as bool)
		base.construct(token)
		_value = value

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType

	get asSharp as String is override
		return if(_value, 'true', 'false')


class CharLit
	inherits AtomicLiteral

	var _value as String  # TODO: should probably be char

	def construct(token as IToken)
		require
			token.which in ['CHAR_LIT_SINGLE', 'CHAR_LIT_DOUBLE']
			token.value inherits String
		code
			base.construct(token)
			_value = token.value to String

	def _bindImp is override
		base._bindImp()
		_type = .compiler.charType

	get asSharp as String is override
		return "'" + _value.toString() + "'"


class DecimalLit
	inherits AtomicLiteral

	var _value as decimal

	def construct(token as IToken)
		require token.value inherits decimal
		base.construct(token)
		_value = token.value to decimal

	def _bindImp is override
		base._bindImp()
		_type = .compiler.decimalType

	get asSharp as String is override
		return _value.toString()


class FloatLit
	inherits AtomicLiteral

	var _value as float

	def construct(token as IToken)
		require token.value inherits float
		base.construct(token)
		_value = token.value to float

	def _bindImp is override
		base._bindImp()
		_type = .compiler.floatType

	get asSharp as String is override
		return _value.toString()


class IntegerLit
	inherits AtomicLiteral

	var _value as int

	def construct(token as IToken)
		require token.value inherits int
		base.construct(token)
		_value = token.value to int

	def construct(token as IToken, value as int)
		base.construct(token)
		_value = value

	def _bindImp is override
		base._bindImp()
		_type = .compiler.intType

	get asSharp as String is override
		return _value.toString()


class NilLiteral
	inherits AtomicLiteral

	def construct(token as IToken)
		base.construct(token)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.nilType

	get asSharp as String is override
		return 'nil'


class StringLit
	inherits AtomicLiteral

	var _string as String  # String contents (with no surrounding quotes or escaping)

	def construct(token as IToken)
		require token.which.startsWith('STRING')
		base.construct(token as IToken)
		_string = token.value to String

	def _bindInt is override
		if not _type
			_type = .compiler.libraryType('System', 'String')
		base._bindInt()

	def _bindImp is override
		if not _type
			_type = .compiler.libraryType('System', 'String')
		base._bindImp()

	def toCobraSource as String is override
		return .token.text

	get asSharp as String is override
		return Utils.csStringLitFor(_string)


class StringSubstLit
	inherits Literal

	var _items as List<of Expr>

	def construct(items as List<of Expr>)
		require items
		base.construct(items[0].token)
		_items = items

	def addSubFields is override
		base.addSubFields()
		.addField('items', _items)

	def _bindImp is override
		base._bindImp()
		for item in _items
			item.bindImp()
		if not _type
			_type = .compiler.libraryType('System', 'String')

	get asSharp as String is override
		assert false
#		out.write('CobraImp.MakeString(')
#		sep = ''
#		for item in _items
#			out.write(sep)
#			if inherits(item, str)
#				out.write(_csStringLitFor(item))
#			else if inherits(item, FormattedExpr)
#				out.write('CobraImp.ToString(')
#				item.expr.genCS(out)
#				out.write(',')
#				out.write(_csStringLitFor(item.format))
#				out.write(')')
#			else if inherits(item, Expr)
#				out.write('CobraImp.ToString(')
#				item.genCS(out)
#				out.write(')')
#			else
#				assert 0, item
#			sep = ','
#		out.write(')')


class FormattedExpr
	inherits Expr
	"""
	This is used exclusively for string substitutions that have formatting:
		'[i:N]'
	"""

	var _expr as Expr
	var _format as String

	def construct(expr as Expr, format as String)
		base.construct(expr.token)
		_expr = expr
		_format = format

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		_type = .compiler.libraryType('System', 'String')


class BaseLit
	inherits AtomicLiteral

	def construct(token as IToken, box as Box)
		base.construct(token)
		_type = box

	def checkType is override
		pass

	def memberForName(name as String) as IMember? is override
		assert .didBindImp
		assert _type
		t = .receiverType
		if t.superType
			t = t.superType
		#return t.symbolForName(name, true, true)
		return t.memberForName(name)

	get asSharp as String is override
		return 'base'


class ThisLit
	inherits AtomicLiteral

	# TODO: somewhere it has to be error checked that you're not assigning to
	# "this" (unless C# allows that which I doubt)

	def construct(token as IToken, box as Box)
		base.construct(token)
		_type = box

	get asSharp as String is override
		return 'this'


class VarLit
	inherits AtomicLiteral

	var _propertyMember as PropertyXetter?
	var _name as String
	var _var as IVar

	def construct(token as IToken, propertyMember as PropertyXetter)
		base.construct(token)
		_propertyMember = propertyMember
		_name = '_'+propertyMember.property.name

	def _bindImp is override
		possible = _propertyMember.property.box.symbolForName(_name, true, true)
		if possible is nil
			_error('Cannot find a class variable named "[_name]".')
		else if possible inherits IVar
			_var = possible
		else
			assert false, possible
		_type = _var.type
		_propertyMember = nil  # don't need this reference anymore
		base._bindImp()

	get asSharp as String is override
		return _name


class CompositeLiteral
	inherits Literal

	def construct(token as IToken)
		base.construct(token)


class ListLit
	inherits CompositeLiteral

	var _exprs as List<of Expr>

	def construct(token as IToken, exprs as List<of Expr>)
		base.construct(token)
		_exprs = exprs

	def addSubFields is override
		base.addSubFields()
		.addField('exprs', _exprs)

	def _bindImp is override
		base._bindImp()
		for expr in _exprs
			expr.bindImp()
		if _type is nil
			exprs = _exprs
			if exprs.count==0
				type = .compiler.libraryType('System', 'Object')
			else
				type = exprs[0].type to IType
				i = 1
				while i<exprs.count
					exprs[i].bindImp()
					type = exprs[i].type.greatestCommonDenominatorWith(type)
					i += 1
				# TODO: get rid of this hack:
				if type.getType().name=='CobraType'
					type = .compiler.libraryType('System', 'Object')
			_type = .compiler.libraryType('System', 'Collections', 'Generic', 'List<of>').constructedTypeFor([type])
			_type.bindAll()

# TODO
#	def toCobraSource(self):
#		sb = []
#		sb.append('[')
#		sep = ''
#		for expr in self.exprs:
#			sb.append(sep)
#			sb.append(expr.toCobraSource())
#			sep = ', '
#		sb.append(']')
#		return ''.join(sb)

# TODO
#	def genCS(self, out, genParens=false):
#		innerType = self.type.typeArgs[0]
#		out.write('CobraImp.MakeList<%s>(typeof(%s)' % (innerType.asCS(), self.type.asCS()))
#		if self.exprs:
#			out.write(', ')
#			sep = ''
#			for expr in self.exprs:
#				out.write(sep)
#				expr.genCS(out)
#				sep = ', '
#		out.write(')')


class DictLit
	inherits CompositeLiteral

	var _entries as List<of List<of Expr> >  # CC: >>

	def construct(token as IToken, entries as List<of List<of Expr> >)  # CC: >>
		base.construct(token)
		_entries = entries

	def addSubFields is override
		base.addSubFields()
		.addField('_entries', _entries)

	def _bindImp is override
		base._bindImp()
		for entry in _entries
			entry[0].bindImp()
			entry[1].bindImp()
		if .type is nil
			entries = _entries
			if _entries.count==0
				keyType = valueType = .compiler.libraryType('System', 'Object')
			else
				keyType   = entries[0][0].type to IType  # CC: to !
				valueType = entries[0][1].type to IType  # CC: to !
				i = 1
				while i<entries.count
					keyType   = entries[i][0].type.greatestCommonDenominatorWith(keyType)
					valueType = entries[i][1].type.greatestCommonDenominatorWith(valueType)
					i += 1
				# TODO: get rid of this hack
				# if keyType is troot: keyType = compiler.typeForName('Object')
				# if valueType is troot: valueType = compiler.typeForName('Object')
			_type = .compiler.libraryType('System', 'Collections', 'Generic', 'Dictionary<of,>').constructedTypeFor([keyType, valueType])
			_type.bindAll()

#	def genCS(self, out, genParens=false):
#		assert len(self.type.typeArgs)==2
#		keyType = self.type.typeArgs[0]
#		valueType = self.type.typeArgs[1]
#		out.write('CobraImp.MakeDict<%s,%s>(typeof(%s)' % (keyType.asCS(), valueType.asCS(), self.type.asCS()))
#		if self.entries:
#			out.write(', ')
#			sep = ''
#			for entry in self.entries:
#				out.write(sep)
#				entry[0].genCS(out)
#				out.write(',')
#				entry[1].genCS(out)
#				sep = ', '
#		out.write(')')
