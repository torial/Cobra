class Expr
	inherits Stmt

	var _type as IType?
	var _receiverType as IType?
		"""
		The type for receiving messages which can be different than the
		_type in a static situation such as `ChessPiece.Color` (where
		Color is an enum). The type of that expression, if assigned to a
		local var, is Type. But if accessed with a further dot
		(`ChessPiece.Color.Black`), then the type is the Color
		enumeration itself--the receiverType.

		For a runtime access (ex: `user.name`) the two types are
		conceptually the same (ex: `String`) and _receiverType is left
		nil.

		_receiverType is used in memberForName() to look up members such
		as "Black".

		TODO: rename to _typeForMemberAccess
		"""
	var _contextType as IType?

	def init(token as IToken)
		base.init(token)

	def addRefFields is override
		base.addRefFields()
		.addField('type', _type)

	get hasError as bool
		return if(_errors, true, false)

	pro type from var

	get receiverType as IType?  # TODO: consider renaming to typeForReceiver.
		return _receiverType ? _type

	pro contextType from var
		"""
		The type expected where this expression is being used.
		Normally this is the same type as the expression, but it can be different, for example when
		assigning a dynamic-typed expression to a static-typed variable.
		"""

	def canBeAssignedTo(type as IType) as bool
		require
			.didBindImp
			.type
		body
			return .type.isAssignableTo(type)

	def toCobraSource as String
		return '[.getType.name].toCobraSource'

	get isCalling as bool
		"""
		Return true is this expression is making a call.
		The default implementation returns false.
		You might think "inherits CallExpr" would suffice, but MemberExpr and IdentifierExpr can
		also return true when they refer to methods or constructors.
		"""
		return false

	def isKindOf(type as IType) as bool
		require
			.type
			.compiler
		body
			return .type.isDescendantOf(type)

	def memberForName(name as String) as IMember?
		require
			.didBindImp
			.type
		body
			t = _receiverType ? _type  # TODO: change to .receiverType
			# TODO: change code below to something like. if container inherits IContainer ...
			while true
				if t inherits QualifiedType  # TODO: another example of QualifiedType being a pain
					wt = t.theWrappedType
					if wt is nil
						t.bindInt()
						wt = t.theWrappedType
						assert wt
					$sharp('t = wt')
				else
					break
			container = t to? IContainer
			if container
				return container.memberForName(name)
			else
				# TODO: at some point this might be an error to access a member of a nilable type, but not for now...
				if t inherits NilableType
					nt = t to NilableType
					container = nt.theWrappedType to? IContainer
					if container
						return container.memberForName(name)
				return nil

	get binarySuperNode as BinaryOpExpr
		require
			.superNode inherits BinaryOpExpr
		body
			return .superNode to BinaryOpExpr

	def bindImp as INode is override
		base.bindImp()
		assert .didBindImp, this
		.postBindImpAssertType()
		return this

	def postBindImpAssertType
		"""
		This is broken out because in rare cases, it doesn't apply. (Those classes override this to
		do nothing.)
		"""
		if not .hasError
			assert .type, this

	def _bindImp is override
# TODO:
#		ensure
#			.type  # CC: should really be the ensure of Expr
		body
			base._bindImp()
			if _type is nil and .getType.name=='Expr'  # CC: cannot say ... and .getType is Expr
				# TODO: this happens with formatted strings, but why?
				# I mean, why does an Expr get created in the first place? Could put an assert in the constructor to trap it.
				_type = .compiler.passThroughType

	def _isSequence(type as IType) as bool
		# TODO: check for ISliceable which would have a getSlice()
		if type.isDescendantOf(.compiler.libraryType('System', 'String'))
			return true
		# if type.isDescendantOf(.compiler.libraryType('System', 'Array'))
		if type inherits ArrayType
			return true
		if type.isDescendantOf(.compiler.libraryType('System', 'Collections', 'IList'))
			return true
		# TODO: is ArrayList redundant with IList above? I think so.
		if type.isDescendantOf(.compiler.libraryType('System', 'Collections', 'ArrayList'))
			return true
		genericList = .compiler.libraryType('System', 'Collections', 'Generic', 'List<of>')
		if type.isDescendantOf(genericList)
			return true
		if type inherits Box
			if type.genericTypeDef is genericList
				return true
		genericIList = .compiler.libraryType('System', 'Collections', 'Generic', 'IList<of>')
		if type.isDescendantOf(genericIList)
			return true
		if type inherits Box
			if type.genericTypeDef is genericIList
				return true
		if type.isDynamic
			return true
		return false

	## Code gen

	def writeSharpDefInContext(sw as SharpWriter)
		.writeSharpDefInContext(sw, true)

	def writeSharpDefInContext(sw as SharpWriter, parens as bool)
		"""
		When an expression is used where a particular type is expected, such as:
			# assignment
			x = y
			# argument passing
			obj.foo(x, y)
			obj[x, y]
		it may need C# typecasting--particularly if it is dynamic typed expression.
		This method relies on having had its .contextType set beforehand.
		This method should be invoked instead of `writeSharpDef` in any situation where .contextType was set.
		"""
		type = .type
		cast = _contextType and type.isDynamic
		if cast
			if parens
				sw.write('(')
			sw.write('([_contextType.sharpRef])(')
		.writeSharpDef(sw)
		if cast
			sw.write(')')
			if parens
				sw.write(')')

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		.writeSharpDef(sw, true)

	def writeSharpDef(sw as SharpWriter, parens as bool)
		pass

	def writeSharpStmt(sw as SharpWriter) is override
		assert .didBindImp
		sw.node(this)
		.writeSharpSetLine(sw)
		.writeSharpDef(sw, false)
		sw.write(';\n')

	def writeSharpBreakdown(sw as SharpWriter)
		sw.write(r'new object[] { 0')
		.writeSharpBreakdownItems(sw)
		sw.write('}, ')

	get willWriteSharpBreakdownItems as bool
		return true

	def writeSharpBreakdownItems(sw as SharpWriter)
		if .willWriteSharpBreakdownItems
			src = Utils.csStringLitFor(.toCobraSource)
			sw.write(', [src], ')
			.writeSharpDefForBreakdown(sw)

	def writeSharpDefForBreakdown(sw as SharpWriter)
		.writeSharpDef(sw)


class NameExpr
	inherits Expr
	"""
	The base class for IdentifierExpr and AsExpr.
	"""
	# TODO: is abstract

	var _name as String
	var _definition as INamedNode?
		"""
		In practice, definitions include:
			* Class, Struct, Interface
			* NameSpace, EnumDecl
			* ClassVar, LocalVar, Param
		There may be others, but at least those have been observed in practice.
		"""

	def init(token as IToken)
		base.init(token)
		_name = token.text

	def addMinFields
		base.addMinFields()
		.addField('name', _name)

	def addRefFields
		base.addRefFields()
		.addField('definition', _definition)

	get definition from var

	get name from var

	def memberForName(name as String) as IMember? is override
		or require
			.definition
		body
			return _definition.typeForReceiver.memberForName(name)

	get asSharp as String
		return _definition.sharpName

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write(.asSharp)


class AsExpr
	inherits NameExpr
	"""
	i as int = 5
	The "i as int" is an AsExpr.
	"""

	var _asToken as IToken  # the identifier vs. the `as` keyword which is the main token
	var _typeNode as INode

	def init(token as IToken, nameToken as IToken, typeNode as INode)
		base.init(nameToken)
		_asToken = token
		_typeNode = typeNode

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addSubFields is override
		base.addSubFields()
		.addField('typeNode', _typeNode)

	def _bindImp is override
		base._bindImp()
		_typeNode.bindAll()
		_type = _typeNode.namedType
		assert _type, _typeNode
		# make the local var if necessary (usually is)
		definition = .compiler.findLocal(_name)
		if definition is nil
			newVar = LocalVar(_token, _type)
			newVar.bindAll()
			.compiler.codeMemberStack.peek().addLocal(newVar)
			_definition = newVar
		else
			if definition.type<>_type
				.throwError('Cannot redeclare "[.name]" as a different type. Earlier type is "[definition.type.name]".')
				# TODO: would be nice to point to earlier location. definition would need to carry source location info
			else
				_definition = definition

	def bindImp as INode
		base.bindImp
		# don't want to say isUsed=true if the AsExpr is the left hand side like in:
		#		x as int = 5
		# but if it is the right hand side like so:
		#		_x = x as int = 5
		# then it is, in fact, being used.
		if _definition and .superNode inherits BinaryOpExpr
			if .binarySuperNode.right is this
				# case: x = y as int
				_definition.isUsed = true
			else if .binarySuperNode.superNode inherits BinaryOpExpr and .binarySuperNode is .binarySuperNode.binarySuperNode.right
				# case: x = y as int = 5
				# recall that assign is right-to-left associative
				_definition.isUsed = true
		return this

	def afterStatementBindImp is override
		base.afterStatementBindImp()
		if not .type inherits NilableType
			if .type.isReference
				.throwError('Must initialize this non-nil object type, or change the type to nilable (suffix a ?).')

	def writeSharpStmt(sw as SharpWriter) is override
		# this happens for declarations like "i as int"
		sw.write('// [_name] as [_type.name]\n')


class CallExpr
	inherits Expr

	var _name as String
	var _args as List<of Expr>
	var _definition as INamedNode?
	var _isNew as bool  # "Exception('foo')" would be a CallExpr that isNew
	var _isCallOnSystemType as bool  # "t()" where t is of System.Type would be a CallExpr that isCallOnSystemType

	def init(token as IToken, name as String, args as List<of Expr>)
		base.init(token)
		_name = name
		_args = args
		_definition = nil

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	def addSubFields is override
		base.addSubFields()
		.addField('isNew', _isNew)
		.addField('isCallOnSystemType', _isCallOnSystemType)
		.addField('args', _args)

	get hasError as bool is override
		if base.hasError
			return true
		for arg in _args
			if arg.hasError
				return true
		return false

	get isCalling as bool is override
		return true

	get name from var

	get args from var

	get definition from var

	def _bindImp is override
		base._bindImp()

		num = 1
		for arg in _args
			try
				arg.bindImp()
			catch ne as NodeException
				ne.prefixMessage('For "[_name]" arg [num]: ')
				.compiler.recordError(ne)
			num += 1

		definition as INamedNode?
		type as IType?

		if _definition is nil  or  _type is nil
			handled = false
			if _superNode inherits DotExpr
				if this is _superNode.right
					checkName = _name
					while checkName.startsWith('_')
						checkName = checkName.substring(1)
					if _superNode.left.type inherits Box and checkName and Utils.startsNonLower(checkName)
						.throwError('Methods must start with lowercase letters (not counting underscores). The name is \"[_name]\".')
					# handle foo.bar() where this is the `bar()` part
					if not _superNode.left.didBindImp
						assert _superNode.left.hasError, _superNode.left
						# we get here for Cobra code like "obj.foo.bar(x)" where "foo" is not found
						_type = .compiler.passThroughType
						return
					possibleDefinition = _superNode.left.memberForName(_name)
					if possibleDefinition is nil
						lrt = _superNode.left.receiverType
						if lrt.isDynamic
							type = .compiler.dynamicType
						else if lrt is .compiler.passThroughType or lrt inherits PrimitiveType  # TODO: lame: bailing out on PrimitiveType so float.parse() will work. See Tests\150-basics-two\510-number-parse.cobra
							if _name=='toString'
								type = .compiler.libraryType('System', 'String')
							else
								type = .compiler.passThroughType
						else
							.throwError('Cannot find "[_name]" in [_superNode.left.receiverType.name].')
					else
						if not possibleDefinition.isCallable
							.throwError('Cannot call "[_name]" because it is a "[possibleDefinition.englishName]".')
						definition = possibleDefinition
						type = possibleDefinition.resultType
					handled = true
			if handled
				assert type
			else
				# handle instantiation such Car() or t() (where t is a System.Type)
				canBeMember = .compiler.canNameBeMember(_name)
				if canBeMember
					assert .compiler.boxStack
					definition = .compiler.symbolForName(_name, canBeMember, false) to passthrough
				else
					definition = .compiler.findLocal(_name)
				if definition is nil
					.throwError('Cannot find "[_name]".')
				_isCallOnSystemType = not definition inherits Box and not definition inherits Method and not definition inherits MemberOverload
			if definition
				if definition inherits IVar
					# such as having:
					#	t as Type
					#	...
					#	x = t()
					if definition.type.isDynamic or definition.type.isDescendantOf(.compiler.libraryType('System', 'Type'))
						type = .compiler.dynamicType
					else
						.throwError('Cannot call a variable of type [definition.type.name].')
				else if definition inherits Box
					if definition inherits Interface
						.throwError('Cannot instantiate an interface.')
					else if definition inherits Class or definition inherits Struct
						# constructing an instance of a class or struct
						type = definition
					else
						# not ever expected since the three Box types are covered above
						throw FallThroughException(definition)
				else if definition inherits BoxMember
					type = definition.resultType  # NOTE: used to have .namedType at the end
					if definition inherits MemberOverload
						pass  # TODO handle overloads (1)
					else
						args = _args
						hasVari = false
						for param in definition.params
							if param.type inherits VariType
								hasVari = true
						if hasVari
							# TODO handle variable number of args (4)
							pass
						else
							check = true
							if not definition.hasParams
								if args.count
									.throwError('The method "[definition.name]" is expecting 0 arguments, but [args.count] are being supplied in this call.')
							else
								paramsx = definition.params  # CC: rename paramsx to params
								if args.count <> paramsx.count
									if _name=='toString'  # TODO because many structs like Decimal have a toString() overload which cannot currently be expressed in SystemInterfaces.cobra
										check = false
									else
										.throwError('The method "[definition.name]" is expecting [paramsx.count] arguments, but [args.count] are being supplied in this call.')
								if check
									for i = 0 .. args.count
										arg = args[i]
										paramx = paramsx[i]  # CC: rename paramx to param
										if arg.hasError
											break
										assert arg.didBindImp, arg
										assert paramx.didBindInt, paramx
										if arg.canBeAssignedTo(paramx.type)
											arg.contextType = paramx.type
										else
		# TODO
		#									if paramx.type.__class__.__name__.startswith('GenericParam')
		#										# TODO support generic params (2)
		#										pass
		#									else
											if true
												if false
													print '<> arg = ' stop
													arg.writeDeepString()
													print '<> paramx = ' stop
													paramx.writeDeepString()
												.throwError('Argument [i+1] of method "[_name]" expects type [paramx.type.name], but the call is supplying type [arg.type.name].')
				else
					throw FallThroughException(definition)
			if type is nil
				type = .compiler.passThroughType
			_definition = definition
			_type = type
		_isNew = _definition inherits Box
		assert _type, 'this=[this], def=[_definition]'

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_name)
		sb.append('(')
		sep = ''
		for arg in _args
			sb.append(sep)
			sb.append(arg.toCobraSource)
			sep = ', '
		sb.append(')')
		return sb.toString

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		name = .name
		if _isCallOnSystemType
			defi = _definition
			what = if(defi inherits Class, 'typeof([_definition.name])', defi.sharpName)
			if (defi to IVar).type.isDynamic
				what = '(System.Type)' + what
			sw.write('Activator.CreateInstance([what]')
			sep = ','  # TODO: sep = ', '
			for arg in _args
				sw.write(sep)
				arg.writeSharpDefInContext(sw)
			sw.write(')')
			return
		if _isNew
			if parens
				sw.write('(')
			sw.write('new ')
		else
			if .superNode inherits DotExpr  # otherwise, code could be: _underscoredDoesNotRequireDot()
				name = Utils.capped(name)
		sw.write('[name](')
		sep = ''
		for arg in _args
			sw.write(sep)
			arg.writeSharpDefInContext(sw)
			sep = ', '
		sw.write(')')
		if _isNew and parens
			sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter) is override
		# leaving out the base call is intentional:
		# base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		for expr in _args
			expr.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class ForExpr
	inherits Expr

	var _nameExpr as NameExpr
	var _var as IVar?
	var _varNumber as int
	var _what as Expr
	var _whereExpr as Expr?
	var _getExpr as Expr

	def init(token as IToken, nameExpr as NameExpr, what as Expr, whereExpr as Expr?, getExpr as Expr)
		base.init(token)
		_nameExpr = nameExpr
		_what = what
		_whereExpr = whereExpr
		_getExpr = getExpr

	def addSubFields
		base.addSubFields
		.addField('nameExpr', _nameExpr)
		.addField('var', _var)
		.addField('what', _what)
		.addField('whereExpr', _whereExpr)
		.addField('getExpr', _getExpr)

	def _bindImp
		base._bindImp
		_what.bindImp()  # bind first because it may be needed for type inference
		if not _isSequence(_what.type to IType)  # to !
			.throwError('Cannot enumerate values of type "[_what.type.name]". You can enumerate IList<of>.') # TODO: strings, arrays, IList and IList<of>.')
		_var = .bindVar(_nameExpr)
		if _nameExpr.definition
			if _nameExpr.definition inherits IVar
				_var = _nameExpr.definition to IVar
			else
				.throwError('Expecting a variable not a [_nameExpr.definition.getType.name].')  # TODO: what's the best way to report what was found?
		else
			assert _nameExpr.hasError, _nameExpr
		_varNumber = .compiler.curBox.makeNextPrivateSerialNumber
		if _whereExpr
			_whereExpr.bindImp
			if _whereExpr.type is not .compiler.boolType
				_whereExpr = TruthExpr(_whereExpr).bindAll to TruthExpr  # CC: axe cast when have "as this"
		_getExpr.bindImp
		ilist = .compiler.libraryType('System', 'Collections', 'Generic', 'IList<of>') to Interface
		_type = ilist.constructedTypeFor([_getExpr.type])

	get inferredType as IType? is override
		assert _what.type
		return _what.type.innerType

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		# C#:  CobraImp.For(stuff, delegate(x as int) { return x*x })
		# C#:  CobraImp.For(stuff, delegate(x as int) { if (x<0) return x*x; })
		inType = _what.type.innerType
		outType = _getExpr.type
		sw.write('CobraImp.For<[inType.sharpRef],[outType.sharpRef]>(')
		_what.writeSharpDef(sw, false)
		sw.write(', ')
		helperName = '_lh_for_[_var.name]_[_varNumber]'
		if _whereExpr is nil
			sw.write('delegate([inType.sharpRef] [helperName]) {\n')
			sw.indent
			sw.write('[_var.sharpName] = [helperName];\n')
			sw.write('return ')
			_getExpr.writeSharpDef(sw, false)
			sw.write(';\n')
			sw.dedent
			sw.write('})')
		else
			outHelperName = helperName + '_out'
			sw.write('delegate([inType.sharpRef] [helperName], out [outType.sharpRef] [outHelperName]) {\n')
			sw.indent
			sw.write('[_var.sharpName] = [helperName];\n')
			sw.write('if (')
			_whereExpr.writeSharpDef(sw, false)
			sw.write(') {\n')
			sw.indent
			sw.write('[outHelperName] = ')
			_getExpr.writeSharpDef(sw, false)
			sw.write(';\n')
			sw.write('return true;\n')
			sw.dedent
			sw.write('} else {\n')
			sw.indent
			sw.write('[outHelperName] = [outType.csInit];\n')
			sw.write('return false;\n')
			sw.dedent
			sw.write('}\n')
			sw.dedent
			sw.write('})')


class IdentifierExpr
	inherits NameExpr

	def init(token as IToken, name as String, definition as INamedNode?)
		base.init(token)
		_name = name
		_definition = definition

	def setDefinition(value as INamedNode?)
		# cannot override definition with a set, because base does not do a set
		_definition = value

	get isCalling as bool is override
		assert _definition
		return _definition.isMethod

	get namedType as IType? is override
		# overridden to return the type this identifier represents in those cases when it does represent a type such an "int" or a class
		assert .didBindImp
		assert .type
		assert .compiler
		if .type.isDescendantOf(.compiler.typeType) or .type inherits Box
			assert .definition
			defi = .definition
			if defi inherits IType
				return defi
			else
				throw FallThroughException(defi)
		else
			return nil

	def _bindImp is override
		base._bindImp()
		if _definition is nil
			canBeMember = .compiler.canNameBeMember(_name)
			if canBeMember
				assert .compiler.boxStack
				_definition = .compiler.symbolForName(_name, canBeMember, false) to passthrough
			else
				_definition = .compiler.findLocal(_name)
			if _definition is nil and not canBeMember
				if _superNode inherits BinaryOpExpr
					if _superNode.right is this
						curBox = .compiler.boxStack.peek()
						definition = curBox.symbolForName(_name, true, true)
						if definition
							.throwError('You must refer to non-underscored members with a leading dot (.). Member name is "[_name]".')

			# TODO: The effect of using symbolForName() just above and the next 3 lines is that class members mask globals of the same name. This will become a problem when module-level functions are supported.
			#from Module import ClassMemberDecl
			#if compiler.opStack and compiler.opStack.peek()!='ASSIGN':  # don't interfere with type inference. tests\200-class-decls\508-properties-access.cobra
			#if isinstance(self.definition, ClassMemberDecl) and self.definition.requiresDotPrefix: # and not self.text.startswith('_'):
			#	self.error('You must refer to non-underscored members with a leading dot (.).')

			if _definition is nil and (not _superNode inherits BinaryOpExpr or .binarySuperNode.op<>'ASSIGN')
				.errorUnknownId(.name)
				throw FallThroughException()
		if _type is nil
			if _definition
				_type = _definition.typeForIdentifier
			else
				if .binarySuperNode and .binarySuperNode inherits AssignExpr and this is .binarySuperNode.left
					pass  # let the AssignExpr have its chance at type inference
				else
					.errorUnknownId(.name)
					throw FallThroughException()

	def bindImp as INode
		base.bindImp
		if _definition
			_definition.isUsed = true
		return this

	def errorUnknownId(name as String)  # TODO: see if 'name' parameter can be axed
		require name
		msg = 'Unknown identifier: "[name]".'
		if .compiler.unknownSuggestions.containsKey(name)
			sug = .compiler.unknownSuggestions[name]
		if sug and sug.length
			msg += ' Maybe you should try "[sug]".'
		.throwError(msg)

	def postBindImpAssertType is override
		pass

	def toCobraSource as String is override
		return _name

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if .superNode inherits DotExpr and .binarySuperNode.right is this
			assert false, 'does this happen?'  # TODO: if not, axe this portion
			sw.write(Utils.capped(_name))
		else
			# if this names a type and it's not dotted, then C# requires typeof()
			if _type inherits TypeType
				if .superNode is nil or .superNode inherits AssignExpr and .binarySuperNode.right is this and not .sharpName.startsWith('_lh')
					sw.write('typeof('+.sharpName+')')
					return
			sw.write(.sharpName)

	get sharpName as String
		assert .didBindImp, this
		assert .definition, this
		assert not .type inherits UnspecifiedType
		if .superNode
			if .superNode inherits DotExpr
				assert this is not (.superNode to DotExpr).right  # should be a CallExpr or MemberExpr instead  # CC: shouldn't need that cast
		defi = .definition
		if defi inherits Box and _type.isDescendantOf(.compiler.libraryType('System', 'Type'))  # TODO: is the "and ..." part even necessary?
			# C# often requires typeof(Foo) instead of just plain Foo
			if .superNode is nil or (.superNode inherits AssignExpr and (.superNode to AssignExpr).right is this)
				if not defi.sharpName.startsWith('_lh')  # TODO: I forget why this has to be guarded against... figure out and put a comment here
					return 'typeof(' + defi.sharpName + ')'
		return defi.sharpName

	def writeSharpStmt(sw as SharpWriter) is override
		assert .isCalling
		sw.write('[_name]();')

	get sharpAssignmentNames as List<of String>?
		require
			.didBindImp
			.definition
		body
			if _definition inherits IVar
				return (_definition to IVar).sharpAssignmentNames
			else
				return nil

	def writeSharpDefForBreakdown(sw as SharpWriter)
		sharpName = .sharpName
		if (.type inherits TypeType or .isKindOf(.compiler.libraryType('System', 'Type'))) and .definition inherits IType and 'typeof(' not in sharpName
			sw.write('typeof([.sharpName])')
		else
			base.writeSharpDefForBreakdown(sw)


class IfExpr
	inherits Expr

	var _cond as Expr
	var _tpart as Expr
	var _fpart as Expr

	def init(token as IToken, cond as Expr, tpart as Expr, fpart as Expr)
		base.init(token)
		_cond = cond
		_tpart = tpart
		_fpart = fpart

	def addSubFields is override
		base.addSubFields()
		.addField('cond', _cond)
		.addField('tpart', _tpart)
		.addField('fpart', _fpart)

	get hasError as bool is override
		if base.hasError
			return true
		if _cond.hasError
			return true
		if _tpart.hasError
			return true
		if _fpart.hasError
			return true
		return false

	def _bindImp is override
		base._bindImp()
		tpart = _tpart
		fpart = _fpart
		hadError = false
		try
			_cond.bindImp()
		catch ne as NodeException
			.compiler.recordError(ne)
			hadError = true
		if not hadError and not _cond.type.isDescendantOf(.compiler.boolType)
			_cond = TruthExpr(_cond).bindAll() to TruthExpr  # CC: axe cast when "as this"
		try
			_tpart.bindImp()
		catch ne as NodeException
			.compiler.recordError(ne)
			hadError = true
		try
			_fpart.bindImp()
		catch ne as NodeException
			.compiler.recordError(ne)
			hadError = true
		if hadError
			_type = .compiler.passThroughType
			return
		assert tpart.type
		assert fpart.type
		_type = tpart.type.greatestCommonDenominatorWith(fpart.type to IType)  # CC: to !

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write('(')
		_cond.writeSharpDef(sw)
		sw.write('?')
		_tpart.writeSharpDef(sw)
		sw.write(':')
		_fpart.writeSharpDef(sw)
		sw.write(')')

	def toCobraSource as String is override
		return 'if([_cond.toCobraSource], [_tpart.toCobraSource], [_fpart.toCobraSource])'

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)

		sw.write(', +1') # indent

		_cond.writeSharpBreakdownItems(sw)
		# only one of the target expressions is actually evaluated

		# tpart:
		src = Utils.csStringLitFor(_tpart.toCobraSource)
		sw.write(', [src], new CobraDirectString(')
		_cond.writeSharpDefForBreakdown(sw)
		sw.write(' ? CobraCore.ToTechString(')
		_tpart.writeSharpDefForBreakdown(sw)
		sw.write(') : "(not-evaluated)")')

		# fpart:
		src = Utils.csStringLitFor(_fpart.toCobraSource)
		sw.write(', [src], new CobraDirectString(')
		_cond.writeSharpDefForBreakdown(sw)
		sw.write(' ? "(not-evaluated)" : CobraCore.ToTechString(')
		_fpart.writeSharpDefForBreakdown(sw)
		sw.write('))')

		sw.write(', -1') # dedent


class IndexExpr
	inherits Expr

	var _target as Expr
	var _args as List<of Expr>

	def init(token as IToken, target as Expr, args as List<of Expr>)
		base.init(token)
		_target = target
		_args = args

	def addSubFields is override
		base.addSubFields()
		.addField('target', _target)
		.addField('args', _args)

	get target from var

	get args from var

	get hasError as bool is override
		if base.hasError
			return true
		if _target.hasError
			return true
		for arg in _args
			if arg.hasError
				return true
		return false

	def _bindImp is override
		base._bindImp()
		_target.bindImp()
		for arg in _args
			try
				arg.bindImp()
			catch ne as NodeException
				.compiler.recordError(ne)
		if _type is nil
			if _target.isKindOf(.compiler.libraryType('System', 'Type'))
				if _target inherits IdentifierExpr
					_type = ArrayType(_target.definition)
					return
			# CC: use a list comprehension to get the types
			# _type = _target.type.indexType(for arg in _args get arg.type)
			argTypes = List<of IType>()
			for arg in _args
				argTypes.add(arg.type to IType)  # CC: to !
			_type = _target.type.indexType(argTypes)
			if _type is nil
				name = ns'[]'
				.throwError('Cannot find a definition for "[name]" in "[_target.type.name]".')
			# TODO: need to lookup the member and (1) check type compatibility and (2) set context type for each arg

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_target.toCobraSource)
		sb.append(r'[')
		sep = ''
		for arg in _args
			sb.append(sep)
			sb.append(arg.toCobraSource)
			sep = ', '
		sb.append(']')
		return sb.toString

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _target.type.isDynamic
			sw.write('CobraImp.GetIndexerValue(')
			_target.writeSharpDef(sw, false)
			for expr in _args
				sw.write(', ')
				expr.writeSharpDef(sw, false)
			sw.write(')')
			return
		if parens
			sw.write('(')
		if _target inherits IdentifierExpr
			if _target.isKindOf(.compiler.libraryType('System', 'Type'))
				# here we're favoring "Foo[]" being an array type rather than a shared indexer
				sw.write(_target.name)
				handled = true
		if not handled
			_target.writeSharpDef(sw)
		sw.write(r'[')
		sep = ''
		for expr in _args
			sw.write(sep)
			expr.writeSharpDefInContext(sw)
			sep = ', '
		sw.write(']')
		if parens
			sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		_target.writeSharpBreakdownItems(sw)
		for expr in _args
			expr.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class IsNilExpr
	inherits Expr

	var _expr as Expr

	def init(token as IToken, expr as Expr)
		base.init(token)
		_expr = expr

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		_type = .compiler.boolType

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		sw.write('(')
		_expr.writeSharpDef(sw)
		sw.write(')')
		sw.write('==null')
		if parens
			sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		_expr.writeSharpBreakdownItems(sw)


class IsNotNilExpr
	inherits Expr

	var _expr as Expr

	def init(token as IToken, expr as Expr)
		base.init(token)
		_expr = expr

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		_type = .compiler.boolType

	def toCobraSource as String is override
		return '[_expr.toCobraSource] is not nil'

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		sw.write('(')
		_expr.writeSharpDef(sw)
		sw.write(')')
		sw.write('!=null')
		if parens
			sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		_expr.writeSharpBreakdownItems(sw)


class MemberExpr
	inherits Expr
	"""
	Example members are fields and properties and methods without arguments.
	"""

	var _name as String
	var _definition as IMember?

	def init(token as IToken, name as String)
		base.init(token)
		_name = name

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	get definition from var

	get isCalling as bool is override
		assert _definition
		return _definition.isMethod

	get name from var

	def _bindImp is override
		base._bindImp()
		assert .superNode inherits BinaryOpExpr
		assert .binarySuperNode.op == 'DOT'
		assert .binarySuperNode.right is this
		if _definition is nil or _type is nil
			if not .binarySuperNode.left.didBindImp
				assert .binarySuperNode.left.hasError, .binarySuperNode.left
				# we get here for Cobra code like "obj.foo.bar" where "foo" is not found
				_type = .compiler.passThroughType
				return
			_definition = .binarySuperNode.left.memberForName(_name)
			if _definition is nil
				if .binarySuperNode.left.receiverType is .compiler.passThroughType
					_type = .compiler.passThroughType
					return
				if .binarySuperNode.left.receiverType.isDynamic
					_type = .compiler.dynamicType
					return
				if _name=='length'
					# TODO get rid of this total hack to support the vari type (and possibly arrays in general)
					_type = .compiler.intType
					.binarySuperNode.type = .type
					return
				if _name=='toString'
					_type = .compiler.libraryType('System', 'String')
					.binarySuperNode.type = .type
					return
				if Utils.isCapped(_name)
					sugg = 'If the name is essentially correct, try the lowercase version ("[Utils.uncapped(_name)]") instead.'
				else
					sugg = ''
				# TODO: change .token.text below to .toCobraSource
# DELME				assert false
				.throwError('Cannot find a definition for "[_name]" in "[.binarySuperNode.left.token.text]" whose type is "[.binarySuperNode.left.receiverType.name]". [sugg]')
			assert _definition
			if _definition inherits IType
				effectiveType as IType = .compiler.typeType  # namespace, class, interface
				receiverType as IType? = _definition to IType  # TODO: should not need "as IType". Type inference is not respecting the if-inherits stack
			else
				effectiveType = _definition.resultType
				receiverType = nil
			assert effectiveType
			_type = effectiveType
			_type.bindInt()
			# TODO: there should be a subclass of BinaryOpExpr called DotExpr and it should do the following work and maybe even the work above.
			# TODO: _receiverType = receiverType
			.binarySuperNode.definition = _definition  # TODO: is this needed?
			.binarySuperNode.type = .type  # the type of foo.bar is what bar returns. A MemberExpr is the "bar" part.
			.binarySuperNode.setReceiverType(receiverType)
		assert _type
		_type.bindInt()

	def toCobraSource as String is override
		return _name

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		assert .superNode inherits DotExpr
		sw.write(Utils.capped(_name))
		if _definition and _definition.isMethod or _name=='toString'
			sw.write('()')

	def writeSharpBreakdownItems(sw as SharpWriter) is override
		pass


class OldExpr
	inherits Expr

	var _expr as Expr
	var _sharpVarName as String?

	def init(token as IToken, expr as Expr)
		base.init(token)
		_expr = expr

	pro sharpVarName from var

	get name as String
		return 'old'

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def addSubFields is override
		base.addSubFields()
		.addField('expr', _expr)

	def _bindImp is override
		base._bindImp()
		curCodeMember = .compiler.codeMemberStack.peek()
		assert curCodeMember
		curCodeMember.addOldExpr(this)  # will set the sharpVarName
		_expr.bindImp()
		_type = _expr.type
		assert _type

	def writeSharpAssignment(sw as SharpWriter)
		require
			.didBindImp
			.sharpVarName
			.type
		body
			sw.write('[.type.sharpRef] [_sharpVarName] = ')
			_expr.writeSharpDef(sw)
			sw.write(';\n')

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		assert _sharpVarName
		# this gets called when generating the `ensure` code
		sw.write(_sharpVarName)


class PostCallExpr
	inherits Expr
	"""
	Covers cases like:
		obj[i]('x')
		String[](10)
	For "bar.foo('x')" that's a binary dot expression with a CallExpr on the right hand side.
	For "Car()" or "someType()" that's also a CallExpr.
	"""

	var _expr as Expr
	var _args as List<of Expr>

	def init(token as IToken, expr as Expr, args as List<of Expr>)
		base.init(token)
		_expr = expr
		_args = args

	def addSubFields is override
		base.addSubFields()
		.addField('expr', _expr)
		.addField('args', _args)

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		for arg in _args
			if arg.hasError
				return true
		return false

	def _bindImp is override
		base._bindImp()
		for arg in _args
			try
				arg.bindImp()
			catch ne as NodeException
				.compiler.recordError(ne)
		_expr.bindImp()
		if _expr inherits TypeExpr
			# instantiation
			assert _expr.containedType
			_type = _expr.containedType
		else if _expr inherits IndexExpr
			# could be array instantiation or calling the result of stuff[i] which could be System.Type, a delegate or what-have-you
			if _expr.target.isKindOf(.compiler.libraryType('System', 'Type'))
				_type = _expr.target.namedType
				assert _type
			else
				assert false, 'what is this? _expr=[_expr]'
		else
			# one example where this happened: x to SomeType()
			# which yielded: PostCallExpr(expr=ToExpr(...))
			# TODO: can probably make this an error now
			assert false, 'what is this? _expr=[_expr]'

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_expr.toCobraSource)
		sb.append('(')
		sep = ''
		for arg in _args
			sb.append(sep)
			sb.append(arg.toCobraSource)
			sep = ', '
		sb.append(')')
		return sb.toString

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		isArrayCreation = false
		if _expr inherits TypeExpr
			sw.write('new ')  # TODO: move down?
			at = _expr.containedType
			if at inherits ArrayType
				# arrays are a very different case
				# example: int[](10)
				sw.write(at.theWrappedType.sharpRef)
				isArrayCreation = true
		if not isArrayCreation  # CC: combine next if when if-inherits gets smarter
			if _expr inherits IndexExpr
				subExpr = _expr.target
				if subExpr.isKindOf(.compiler.libraryType('System', 'Type'))
					# example: String[](10)
					sw.write('new ')
					if subExpr inherits IdentifierExpr
						# special case to avoid IdentifierExpr from generating: typeof(Foo)
						sw.write(subExpr.name)
					else
						subExpr.writeSharpDef(sw, false)
					isArrayCreation = true
		if not isArrayCreation
			_expr.writeSharpDef(sw)
		sw.write(if(isArrayCreation, r'[', '('))
		sep = ''
		for arg in _args
			sw.write(sep)
			arg.writeSharpDef(sw, false)
			sep = ','
		sw.write(if(isArrayCreation, r']', ')'))
		if parens
			sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		_expr.writeSharpBreakdownItems(sw)
		for expr in _args
			expr.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class SharpExpr
	inherits Expr

	var _expr as StringLit

	def init(token as IToken, expr as Expr)
		base.init(token)
		if expr inherits StringLit  # TODO:? make this an arg type
			_expr = expr
		else
			assert false, expr

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def _bindImp is override
		base._bindImp()
		_type = .compiler.passThroughType
		_expr.bindImp()

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		sw.write(_expr.token.value)
		if parens
			sw.write(')')


class SliceExpr
	inherits Expr
	"""
	Just like Python slices.
	"""

	var _target as Expr
	var _start as Expr?
	var _stop as Expr?
	var _step as Expr?

	def init(token as IToken, target as Expr, start as Expr?, stopp as Expr?, stepp as Expr?)
		base.init(token)
		_target = target
		_start = start
		_stop = stopp
		_step = stepp

	def addSubFields
		base.addSubFields
		.addField('target', _target)
		.addField('start', _start)
		.addField('stop', _stop)
		.addField('step', _step)

	get hasError as bool is override
		if base.hasError
			return true
		if _target.hasError
			return true
		if _start and _start.hasError
			return true
		if _stop and _stop.hasError
			return true
		if _step and _step.hasError
			return true
		return false

	def _bindImp
		base._bindImp
		intType = .compiler.intType
		try
			_target.bindImp
		catch ne as NodeException
			.compiler.recordError(ne)
		success
			if not _isSequence(_target.type to IType)  # to !
				.throwError('Cannot slice values of type "[_target.type.name]". You can slice strings, arrays, IList and IList<of>.')
		if _start
			try
				_start.bindImp
			catch ne as NodeException
				.compiler.recordError(ne)
			success
				if _start.type.isDynamic
					_start.contextType = intType
				else if not _start.isKindOf(intType)
					_start.recordError('The start index of the slice is type "[_start.type.name]", but should be "int".')
		if _stop
			try
				_stop.bindImp
			catch ne as NodeException
				.compiler.recordError(ne)
			success
				if _stop.type.isDynamic
					_stop.contextType = intType
				else if not _stop.isKindOf(intType)
					_stop.recordError('The stop index of the slice is type "[_stop.type.name]", but should be "int".')
		if _step
			try
				_step.bindImp
			catch ne as NodeException
				.compiler.recordError(ne)
			success
				if _step.type.isDynamic
					_step.contextType = intType
				else if not _step.isKindOf(intType)
					_step.recordError('The step of the slice is type "[_step.type.name]", but should be "int".')
		if _target.hasError
			_type = .compiler.passThroughType
		else
			_type = _target.type

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_target.toCobraSource)
		sb.append(r'[')
		if _start
			sb.append(_start.toCobraSource)
		sb.append(':')
		if _stop
			sb.append(_stop.toCobraSource)
		if _step
			sb.append(':')
			sb.append(_step.toCobraSource)
		sb.append(']')
		return sb.toString

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write('CobraImp.GetSlice(')
		isArray = _target.type inherits ArrayType
		if isArray
			sw.write('(System.Array)(')  # or C# can't disambiguate the GetSlice() overloads
		_target.writeSharpDef(sw, false)
		if isArray
			sw.write(')')
		sw.write(',')
		if _start is nil
			sw.write('null')
		else
			_start.writeSharpDefInContext(sw, false)
		sw.write(',')
		if _stop is nil
			sw.write('null')
		else
			_stop.writeSharpDefInContext(sw, false)
		sw.write(',')
		if _step is nil
			sw.write('null')
		else
			_step.writeSharpDefInContext(sw, false)
		sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		_target.writeSharpBreakdownItems(sw)
		if _start
			_start.writeSharpBreakdownItems(sw)
		if _stop
			_stop.writeSharpBreakdownItems(sw)
		if _step
			_step.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class TruthExpr
	inherits Expr
	"""
	A truth expr wraps an expression such that it can be used where a bool is expected in .NET/C#.
	For example, if passed an integer typed expression, the truth expression will wrap it with a
	comparison 0!=expr.
	"""

	var _useRuntimeService as bool
	var _expr as Expr
	var _origExpr as Expr

	def init(expr as Expr)
		base.init(expr.token)
		_useRuntimeService = false
		_origExpr = _expr = expr

	def addSubFields is override
		base.addSubFields()
		.addField('useRuntimeService', _useRuntimeService)
		.addField('expr', _expr)

	get expr from var

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		if _expr.type is not .compiler.boolType
			if _expr.isKindOf(.compiler.passThroughType)
				_useRuntimeService = true
			else if _expr.type inherits NumberType  # TODO: should this be: if _expr.isKindOf(.compiler.numberType)
				_expr = CompareExpr(_expr.token, 'NE', IntegerLit(_expr.token, 0), _expr)
			else if $sharp('_expr is NilLiteral')
				_expr = BoolLit(_expr.token, false)
			else
				_useRuntimeService = true
			_expr.bindImp()
		_type = .compiler.boolType

	def toCobraSource as String is override
		return _origExpr.toCobraSource

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _useRuntimeService
			sw.write('CobraImp.IsTrue(')
			_expr.writeSharpDef(sw, false)
			sw.write(')')
		else
			_expr.writeSharpDef(sw, parens)

	def writeSharpBreakdownItems(sw as SharpWriter) is override
		# leaving out the base class is intentional:
		# base.writeSharpBreakdownItems(sw, isFirstExpr)
		_expr.writeSharpBreakdownItems(sw)


class TypeExpr
	inherits Expr

	var _typeNode as ISyntaxNode?
	var _containedType as IType?

	def init(typeNode as ISyntaxNode)
		base.init(typeNode.token)
		_typeNode = typeNode

	def init(token as IToken, type as IType)
		base.init(token)
		_containedType = type
		_receiverType = type

	get containedType from var

	get namedType as IType? is override
		assert .didBindImp
		assert _containedType
		return _containedType

	def addRefFields is override
		base.addRefFields()
		.addField('containedType', _containedType)

	def addSubFields is override
		base.addSubFields()
		.addField('typeNode', _typeNode)

	def toCobraSource as String is override
		assert _containedType
		return _containedType.name

	def _bindImp is override
		base._bindImp()
		if _typeNode
			_typeNode.bindImp()
			t = _typeNode.namedType
			if t is nil
				assert false, 'when does this happen?'
			if t  # CC: use 'else'
				_containedType = t
				_receiverType = t
		_type = .compiler.typeType

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write(_containedType.sharpRef)

	def writeSharpDefForBreakdown(sw as SharpWriter) is override
		sw.write('typeof(')
		.writeSharpDef(sw)
		sw.write(')')


class UnaryOpExpr
	inherits Expr

	var _op as String
	var _expr as Expr

	def init(token as IToken, op as String, expr as Expr)
		require op in ['MINUS', 'PLUS', 'NOT']
		base.init(token)
		_op = op
		_expr = expr

	def addMinFields
		base.addMinFields
		.addField('op', _op)

	def addSubFields
		base.addSubFields
		.addField('expr', _expr)

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	get op from var

	get expr from var

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		if _type is nil
			_type = _expr.type
		branch _op
			on 'MINUS'
				_type = _expr.type
			on 'PLUS'
				_type = _expr.type
			on 'NOT'
				if _expr.type is not .compiler.boolType
					_expr = TruthExpr(_expr).bindAll() to TruthExpr  # CC: axe when "as this"
					_type = .compiler.boolType
			# TODO: handle DOT?
			else
				throw FallThroughException(_op)

	def toCobraSource as String is override
		branch _op
			on 'MINUS': op = '-'
			on 'PLUS': op = '+'
			on 'NOT': op = 'not '
			else: throw FallThroughException(_op)
		return op + _expr.toCobraSource

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _op == 'PLUS'
			if parens
				sw.write('(')
			_expr.writeSharpDef(sw, false)
			if parens
				sw.write(')')
			return
		if _expr.type.isDynamic
			specs = OperatorSpecs.unaryOpSpecsByCobraText
			assert specs.containsKey(.token.text)
			spec = specs[.token.text]
			opText = Utils.csStringLitFor(spec.opMethodName)
			sw.write('CobraImp.DynamicOp([opText], ')
			_expr.writeSharpDef(sw, false)
			sw.write(')')
			return
		if parens
			sw.write('(')
		branch _op
			on 'MINUS'
				sw.write('-')
			on 'NOT'
				sw.write('!')
			else
				throw FallThroughException(_op)
		_expr.writeSharpDef(sw)
		if parens
			sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		_expr.writeSharpBreakdownItems(sw)
		sw.write(', -1')


##
## Literals
##

class Literal
	inherits Expr

	def init(token as IToken)
		base.init(token)

	get asSharp as String
		return ''

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write(.asSharp)


class AtomicLiteral
	inherits Literal

	var _text as String

	def init(token as IToken)
		base.init(token)
		_text = token.text

	def bindImp as INode is override
		base.bindImp()
		.checkType()
		return this

	def checkType
		assert _type, this

	def _bindImp is override
		base._bindImp()

	def toCobraSource as String is override
		return _text

	get willWriteSharpBreakdownItems as bool is override
		return false


class BoolLit
	inherits AtomicLiteral

	var _value as bool

	def init(token as IToken)
		require token.text in ['true', 'false']
		base.init(token)
		_value = token.text=='true'

	def init(token as IToken, value as bool)
		base.init(token)
		_value = value

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType

	get asSharp as String is override
		return if(_value, 'true', 'false')


class CharLit
	inherits AtomicLiteral

	var _value as String  # TODO: should probably be char

	def init(token as IToken)
		require
			token.which in ['CHAR_LIT_SINGLE', 'CHAR_LIT_DOUBLE']
			token.value inherits String
		body
			base.init(token)
			_value = token.value to String

	def _bindImp is override
		base._bindImp()
		_type = .compiler.charType

	get asSharp as String is override
		return "'" + _value.toString + "'"


class DecimalLit
	inherits AtomicLiteral

	var _value as decimal

	def init(token as IToken)
		require token.value inherits decimal
		base.init(token)
		_value = token.value to decimal

	def _bindImp is override
		base._bindImp()
		_type = .compiler.decimalType

	get asSharp as String is override
		return _value.toString + 'm'


class FloatLit
	inherits AtomicLiteral

	var _value as float

	def init(token as IToken)
		require token.value inherits float
		base.init(token)
		_value = token.value to float

	def _bindImp is override
		base._bindImp()
		_type = .compiler.floatType

	get asSharp as String is override
		s = _value.toString
		if s.indexOf('.')==-1
			s += '.0'
		return s


class IntegerLit
	inherits AtomicLiteral

	var _value as int

	def init(token as IToken)
		require token.value inherits int
		base.init(token)
		_value = token.value to int

	def init(token as IToken, value as int)
		base.init(token)
		_value = value

	def _bindImp is override
		base._bindImp()
		_type = .compiler.intType

	get asSharp as String is override
		return _value.toString


class NilLiteral
	inherits AtomicLiteral

	def init(token as IToken)
		base.init(token)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.nilType

	get asSharp as String is override
		return 'null'


class StringLit
	inherits AtomicLiteral

	var _string as String  # String contents (with no surrounding quotes or escaping)

	def init(token as IToken)
		require token.which.startsWith('STRING')
		base.init(token as IToken)
		_string = token.value to String

	get string from var

	def _bindInt is override
		if not _type
			_type = .compiler.libraryType('System', 'String')
		base._bindInt()

	def _bindImp is override
		if not _type
			_type = .compiler.libraryType('System', 'String')
		base._bindImp()

	def toCobraSource as String is override
		return .token.text

	get asSharp as String is override
		return Utils.csStringLitFor(_string)


class StringSubstLit
	inherits Literal

	var _items as List<of Expr>

	def init(items as List<of Expr>)
		require items
		base.init(items[0].token)
		if true
			_items = items
		else
			# TODO: the efficient, but not debugged case
			# CC: potential
			# _items = for item in items if not item inherits StringLit or item.string get item
			_items = List<of Expr>()
			for item in _items
				if item inherits StringLit and not (item to StringLit).string
					continue
				_items.add(item)
			assert _items

	def addSubFields is override
		base.addSubFields()
		.addField('items', _items)

	get hasError as bool is override
		if base.hasError
			return true
		for item in _items
			if item.hasError
				return true
		return false

	def toCobraSource as String is override
		sb = StringBuilder()
		for item in _items
			if item inherits StringLit
				sb.append(item.token.text)
			else
				sb.append(item.toCobraSource)
		return sb.toString

	def _bindImp is override
		base._bindImp()
		for item in _items
			try
				item.bindImp()
			catch ne as NodeException
				.compiler.recordError(ne)
		if not _type
			_type = .compiler.libraryType('System', 'String')

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _items.count>1
			sw.write('CobraImp.MakeString(')
		sep = ''
		for item in _items
			sw.write(sep)
			if item inherits StringLit
				item.writeSharpDef(sw, true)  # CC: axe the "true" when the bug about overload groups crossing inheritance is fixed
			else if item inherits FormattedExpr
				sw.write('CobraImp.ToString(')
				item.expr.writeSharpDef(sw)
				sw.write(',')
				sw.write(Utils.csStringLitFor(item.format))
				sw.write(')')
			else if item inherits Expr
				sw.write('CobraImp.ToString(')
				item.writeSharpDef(sw, false)
				sw.write(')')
			else
				throw FallThroughException(item)
			sep = ','
		if _items.count>1
			sw.write(')')


class FormattedExpr
	inherits Expr
	"""
	This is used exclusively for string substitutions that have formatting:
		'[i:N]'
	"""

	var _expr as Expr
	var _format as String

	def init(expr as Expr, format as String)
		base.init(expr.token)
		_expr = expr
		_format = format

	get expr from var

	get format from var

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def toCobraSource as String is override
		return '[_expr.toCobraSource]:[_format]'

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		_type = .compiler.libraryType('System', 'String')


class BaseLit
	inherits AtomicLiteral

	def init(token as IToken, box as Box)
		base.init(token)
		_type = box

	def checkType is override
		pass

	def memberForName(name as String) as IMember? is override
		assert .didBindImp
		assert _type
		t = .receiverType
		if t.superType
			t = t.superType
		#return t.symbolForName(name, true, true)
		return t.memberForName(name)

	get asSharp as String is override
		return 'base'


class ThisLit
	inherits AtomicLiteral

	# TODO: somewhere it has to be error checked that you're not assigning to
	# "this" (unless C# allows that which I doubt)

	def init(token as IToken, box as Box)
		base.init(token)
		_type = box

	get asSharp as String is override
		return 'this'

	def toCobraSource as String is override
		return 'this'


class VarLit
	inherits AtomicLiteral

	var _propertyMember as ProperDexerXetter?
	var _name as String
	var _var as IVar?

	def init(token as IToken, propertyMember as ProperDexerXetter)
		base.init(token)
		_propertyMember = propertyMember
		_name = '_'+propertyMember.parent.name

	def _bindImp is override
		possible = _propertyMember.parent.box.symbolForName(_name, true, true)
		if possible is nil
			.throwError('Cannot find a class variable named "[_name]".')
		else if possible inherits IVar
			_var = possible
		else
			assert false, possible
		_type = _var.type
		_propertyMember = nil  # don't need this reference anymore
		base._bindImp()

	get asSharp as String is override
		return _name


class CompositeLiteral
	inherits Literal

	def init(token as IToken)
		base.init(token)


class SequenceLit
	inherits CompositeLiteral
	# CC: mark abstract

	var _exprs as List<of Expr>

	def init(token as IToken, exprs as List<of Expr>)
		base.init(token)
		_exprs = exprs

	def addSubFields is override
		base.addSubFields()
		.addField('exprs', _exprs)

	get hasError as bool is override
		if base.hasError
			return true
		for expr in _exprs
			if expr.hasError
				return true
		return false

	def _bindImp is override
		base._bindImp()
		hadError = false
		for expr in _exprs
			try
				expr.bindImp()
			catch ne as NodeException
				.compiler.recordError(ne)
				hadError = true
		if hadError
			return
		if _type is nil
			exprs = _exprs
			if exprs.count==0
				type = .compiler.dynamicType to IType
			else
				type = exprs[0].type to IType
				i = 1
				while i<exprs.count
					exprs[i].bindImp()
					type = exprs[i].type.greatestCommonDenominatorWith(type)
					i += 1
				# TODO: get rid of this hack:
				if type.getType.name=='CobraType'
					type = .compiler.libraryType('System', 'Object')
			_type = _makeTypeWith(type)
			_type.bindAll()

	def _makeTypeWith(type as IType) as IType  # CC: make abstract
		return nil to passthrough

	get openingBracket as String # CC: is abstract
		return ''

	def toCobraSource as String is override
		sb = StringBuilder(.openingBracket)
		sep = ''
		for expr in _exprs
			sb.append(sep)
			sb.append(expr.toCobraSource)
			sep = ', '
		sb.append(']')
		return sb.toString

	def writeSharpBreakdownItems(sw as SharpWriter) is override  # CC: axe is override
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		for expr in _exprs
			expr.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class ListLit
	inherits SequenceLit

	# CC: should just inherit this because no initializers are defined
	def init(token as IToken, exprs as List<of Expr>)
		base.init(token, exprs)

	def _makeTypeWith(type as IType) as IType is override
		return .compiler.libraryType('System', 'Collections', 'Generic', 'List<of>').constructedTypeFor([type])

	get openingBracket as String is override
		return r'['

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		innerType = (_type to Box).params[0]
		sw.write('CobraImp.MakeList<[innerType.sharpRef]>(typeof([_type.sharpRef])')
		if _exprs.count
			sw.write(', ')
			sep = ''
			for expr in _exprs
				sw.write(sep)
				expr.writeSharpDef(sw, false)
				sep = ', '
		sw.write(')')


class ArrayLit
	inherits SequenceLit

	# CC: should just inherit this because no initializers are defined
	def init(token as IToken, exprs as List<of Expr>)
		base.init(token, exprs)

	def _makeTypeWith(type as IType) as IType is override
		return ArrayType(type)

	get openingBracket as String is override
		return r'@['

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write('new [_type.sharpRef] { ')
		if _exprs.count
			sep = ''
			for expr in _exprs
				sw.write(sep)
				expr.writeSharpDef(sw, false)
				sep = ', '
		sw.write(' }')


class DictLit
	inherits CompositeLiteral

	var _entries as List<of List<of Expr>>

	def init(token as IToken, entries as List<of List<of Expr>>)
		base.init(token)
		_entries = entries

	def addSubFields is override
		base.addSubFields()
		.addField('_entries', _entries)

	get hasError as bool is override
		if base.hasError
			return true
		for entry in _entries
			for expr in entry
				if expr.hasError
					return true
		return false

	def _bindImp is override
		base._bindImp()
		hadError = false
		for entry in _entries
			try
				entry[0].bindImp()
			catch ne as NodeException
				.compiler.recordError(ne)
				hadError = true
			try
				entry[1].bindImp()
			catch ne as NodeException
				.compiler.recordError(ne)
				hadError = true
		if hadError
			return
		if .type is nil
			entries = _entries
			if _entries.count==0
				keyType = valueType = .compiler.dynamicType to IType
			else
				keyType   = entries[0][0].type to IType  # CC: to !
				valueType = entries[0][1].type to IType  # CC: to !
				i = 1
				while i<entries.count
					keyType   = entries[i][0].type.greatestCommonDenominatorWith(keyType)
					valueType = entries[i][1].type.greatestCommonDenominatorWith(valueType)
					i += 1
				# TODO: get rid of this hack
				# if keyType is troot: keyType = compiler.typeForName('Object')
				# if valueType is troot: valueType = compiler.typeForName('Object')
			_type = .compiler.libraryType('System', 'Collections', 'Generic', 'Dictionary<of,>').constructedTypeFor([keyType, valueType])
			_type.bindAll()

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		assert (_type to Box).params.count==2
		keyType   = (_type to Box).params[0]
		valueType = (_type to Box).params[1]
		sw.write('CobraImp.MakeDict<[keyType.sharpRef],[valueType.sharpRef]>(typeof([_type.sharpRef])')
		if _entries.count
			sw.write(', ')
			sep = ''
			for entry in _entries
				sw.write(sep)
				entry[0].writeSharpDef(sw)
				sw.write(',')
				entry[1].writeSharpDef(sw)
				sep = ', '
		sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter) is override  # CC: axe is override
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		for entry in _entries
			# CC: keyExpr, valueExpr = entry
			keyExpr = entry[0]
			valueExpr = entry[1]
			keyExpr.writeSharpBreakdownItems(sw)
			valueExpr.writeSharpBreakdownItems(sw)
		sw.write(', -1')
