class Expr
	inherits Stmt

	var _type as IType?
	var _receiverType as IType?
		"""
		The type for receiving messages which can be different than the
		_type in a static situation such as `ChessPiece.Color` (where
		Color is an enum). The type of that expression, if assigned to a
		local var, is Type. But if accessed with a further dot
		(`ChessPiece.Color.Black`), then the type is the Color
		enumeration itself--the receiverType.

		For a runtime access (ex: `user.name`) the two types are
		conceptually the same (ex: `String`) and _receiverType is left
		nil.

		_receiverType is used in memberForName() to look up members such
		as "Black".

		TODO: rename to _typeForMemberAccess
		"""

	def construct(token as IToken)
		base.construct(token)

	pro type from var

	get receiverType as IType?  # TODO: consider renaming to typeForReceiver.
		return _receiverType ? _type

	def toCobraSource as String
		return ''

	def isKindOf(type as IType) as bool
		require
			.type
			.compiler
		code
			if .type is .compiler.passThroughType
				return true
			return .type.isDescendantOf(type)

	def memberForName(name as String) as IMember?
		require
			.didBindImp
			.type
		code
			t = _receiverType ? _type
			container = t to? IContainer
			if container!
				return container.declForName(name)
			else
				return nil

	get binarySuperNode as BinaryOpExpr
		require
			.superNode
			.superNode inherits BinaryOpExpr
		code
			return .superNode to BinaryOpExpr


class AsExpr
	inherits Expr
	"""
	i as int = 5
	The "i as int" is an AsExpr.
	"""

	var _name as String
	var _nameToken as IToken  # the identifier vs. the `as` keyword which is the main token
	var _typeNode as INode
	var _definition as INode?

	def construct(token as IToken, nameToken as IToken, typeNode as INode)
		base.construct(token)
		_nameToken = nameToken
		_name = nameToken.text
		_typeNode = typeNode

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addSubFields is override
		base.addSubFields()
		.addField('typeNode', _typeNode)
		.addField('definition', _definition)

	def _bindImp is override
		base._bindImp()
		_typeNode.bindAll()
		_type = _typeNode.namedType
		assert _type, _typeNode
		_type.bindAll()  # TODO: is this needed? try commenting out after whole test suite passes
		# make the local var if necessary (usually is)
		definition = .compiler.findLocal(_name)
		if definition is nil
			newVar = LocalVar(_nameToken, _type)
			newVar.bindAll()
			.compiler.codeMemberStack.peek().addLocal(newVar)
			_definition = newVar
		# TODO: check for redefinitions that are invalid by comparing .type with definition.type

# TODO:
#	def afterStatementBindImp
#		base.afterStatementBindImp()
#		if not inherits(.type, NilableType)
#			if not inherits(.type, PrimitiveType)
#				.error('Must initialize this non-nil object type, or change the type to nilable (suffix a ?).')

	get asCS as String
		return _name

	def genCS(sw as IndentedWriter, genParams as bool)
		sw.write(.asCS)

#	def genCSStatement(out)
#		# this happens for declarations like "i as int"
#		out.write('// ')
#		.genCS(out)
#		out.write(';\n')


class CallExpr
	inherits Expr

	var _name as String
	var _args as List<of Expr>
	var _definition as ClassMember?

	def construct(token as IToken, name as String, args as List<of Expr>)
		base.construct(token)
		_name = name
		_args = args
		_definition = nil

	def _bindImp is override
		base._bindImp()

		for arg in _args
			arg.bindImp()

		definition as ClassMember?
		type as IType?

		if _definition is nil  or  _type is nil
			if _superNode inherits BinaryOpExpr
				if _superNode.op=='DOT' and this is _superNode.right
					# handle foo.bar() where this is the `bar()` part
					possibleDefinition = _superNode.left.memberForName(_name)
					if possibleDefinition is nil
						type = .compiler.passThroughType
					else
						if not possibleDefinition inherits ClassMember
							assert not possibleDefinition.isCallable
							_error('Cannot call "[_name]" because it is a "[possibleDefinition.englishName]".')
						definition = possibleDefinition to ClassMember
						type = definition.resultType
			if definition is nil
				# TODO this needs to be an error in the long term
				type = .compiler.passThroughType
			else
				if definition inherits ClassMember
					type = definition.resultType  # NOTE: used to have .namedType at the end
					if definition inherits MemberOverload
						pass  # TODO handle overloads (1)
					else
						args = _args
						if definition.hasVariParams
							# TODO handle variable number of args (4)
							pass
						else
							check = true
							if not definition.hasParams
								if args.count
									_error('The method "[definition.name]" is expecting 0 arguments, but [args.count] are being supplied in this call.')
							else
								paramsx = definition.params  # CC: rename paramsx to params
								if args.count<>paramsx.count
									if _name=='toString'  # TODO because many structs like Decimal have a toString() overload which cannot currently be expressed in SystemInterfaces.cobra
										check = false
									else
										_error('The method is expecting [paramsx.count] arguments, but [args.count] are being supplied in this call.')
								if check
									for i = 0 .. args.count
										arg = args[i]
										paramx = paramsx[i]  # CC: rename paramx to param
										assert arg.didBindImp
										assert paramx.didBindInt
										if not arg.type.isAssignableTo(paramx.type)
		# TODO
		#									if paramx.type.__class__.__name__.startswith('GenericParam')
		#										# TODO support generic params (2)
		#										pass
		#									else
											if true
												_error('Argument [i+1] of method "[_name]" expects type [paramx.type.name], but the call is supplying type [arg.type.name].')
				else
					assert false, definition

			_definition = definition
			_type = type

		assert _type, 'this=[this], def=[_definition]'
		_type.bindImp()

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_name)
		sb.append('(')
		sep = ''
		for arg in _args
			sb.append(sep)
			sb.append(arg.toCobraSource())
			sep = ', '
		sb.append(')')
		return sb.toString()

#	def genCS(out, genParens=false)
#		if .isNew
#			if genParens
#				out.write('(')
#			out.write('new ')
#		name = .isDotted and capped(.name) or .name
#		out.write('%s(' % name)
#		genCSBinaryOpStack.push('(')  # on order to make .isDotted false for the args inside the call
#		try
#			sep = ''
#			for arg in .args
#				out.write(sep)
#				arg.genCS(out)
#				sep = ', '
#			out.write(')')
#		finally
#			genCSBinaryOpStack.pop()
#		if .isNew
#			if genParens
#				out.write(')')


class IdentifierExpr
	inherits Expr

	var _text as String
	var _definition as INamedNode?

	def construct(token as IToken, text as String, definition as INamedNode?)
		base.construct(token)
		_text = text
		_definition = definition

	def addSubFields is override
		base.addSubFields()
		.addField('definition', _definition)

	get definition from var

	def memberForName(name as String) as IMember? is override
		require
			.didBindImp
			.definition
		code
			return _definition.typeForReceiver.memberForName(name)

	def _bindImp is override
		base._bindImp()
		if _definition is nil
			canBeMember = _text.startsWith('_') or Utils.isCapped(_text)  # isCapped could be an enum or, in the future, a nested class
			if canBeMember
				_definition = .compiler.symbolForName(_text, canBeMember, false) to passthrough
			else
				_definition = .compiler.findLocal(_text)
			if _definition is nil and not canBeMember
				if _superNode inherits BinaryOpExpr
					if _superNode.right is this
						curBox = .compiler.boxStack.peek()  # TODO: would like to use compiler.curClass except that could be an interface or struct. compiler.curCompositeType
						definition = curBox.symbolForName(_text, true, true)
						if definition is not nil
							_error('You must refer to non-underscored members with a leading dot (.). Member name is "[_text]".')

			# TODO: The effect of using symbolForName() just above and the next 3 lines is that class members mask globals of the same name. This will become a problem when module-level functions are supported.
			#from Module import ClassMemberDecl
			#if compiler.opStack and compiler.opStack.peek()!='ASSIGN':  # don't interfere with type inference. tests\200-class-decls\508-properties-access.cobra
			#if isinstance(self.definition, ClassMemberDecl) and self.definition.requiresDotPrefix: # and not self.text.startswith('_'):
			#	self.error('You must refer to non-underscored members with a leading dot (.).')

			if _definition is nil and (not _superNode inherits BinaryOpExpr or .binarySuperNode.op<>'ASSIGN')
				msg = 'Unknown identifier: "[_text]".'
				sug = .compiler.suggestionFor(_text)
				if sug
					msg += ' Maybe you should try "[sug]".'
				_error(msg)
		if _type is nil
			_resolveType()

	def _resolveType
		require _definition
		if _definition
			_type = _definition.typeForIdentifier
# TODO: axe or enable
#		else
#			if compiler.opStack and compiler.opStack.peek()=='ASSIGN':
#				pass
#			else:
#				compiler.errorUnknownId(self.text)


class IndexExpr
	inherits Expr

	# TODO

	def construct(token as IToken, target as Expr, exprs as List<of Expr>)
		base.construct(token)


class IsNilExpr
	inherits Expr

	def construct(token as IToken, expr as Expr)
		base.construct(token)


class IsNotNilExpr
	inherits Expr

	def construct(token as IToken, expr as Expr)
		base.construct(token)


class MemberExpr
	inherits Expr
	"""
	Example members are fields and properties.
	"""

	var _name as String
	var _definition as IMember?

	def construct(token as IToken, name as String)
		base.construct(token)
		_name = name

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	def _bindImp is override
		require
			.superNode inherits BinaryOpExpr
			.binarySuperNode.op == 'DOT'
			.binarySuperNode.right is this
		ensure
			true or .type  # TODO: get rid of true @@@@@ # CC: should really be the ensure of Expr
		code
			base._bindImp()
			if _definition is nil or _type is nil
				_definition = .binarySuperNode.left.memberForName(_name)
				if _definition is nil
					if .binarySuperNode.left.receiverType is .compiler.passThroughType
						_type = .compiler.passThroughType
						return
					if _name=='length'
						# TODO get rid of this total hack to support the vari type (and possibly arrays in general)
						_type = .compiler.intType
						.binarySuperNode.type = .type
						return
					if Utils.isCapped(_name)
						sugg = 'If the name is essentially correct, try the lowercase version ("[Utils.uncapped(_name)]") instead.'
					else
						sugg = ''
					_error('Cannot find a definition for "[_name]" in "[.binarySuperNode.left.token.text]" whose type is "[.binarySuperNode.left.receiverType.name]". [sugg]')
				assert _definition
				if _definition inherits IType
					assert false, 'TODO: handle foo.sometype'
					# TODO:
					# effectiveType = .compiler.typeType  # namespace, class, interface
					receiverType as IType? = _definition to IType  # TODO: should not need "as IType". Type inference is not respecting the if-inherits stack
				else
					effectiveType = _definition.resultType
					receiverType = nil
				# TODO:
				#else
				#	throw FallThroughException(_definition)
				assert effectiveType
				_type = effectiveType
				# TODO: _receiverType = receiverType
				.binarySuperNode.definition = _definition  # TODO: is this needed?
				.binarySuperNode.type = .type  # the type of foo.bar is what bar returns. A MemberExpr is the "bar" part.
				# TODO: .binarySuperNode.receiverType = _receiverType  # TODO: what is this used for?
			assert _type
			_type.bindImp()

	def toCobraSource as String is override
		return _name

# TODO
#	def genCS(out)
#		name = .isDotted and Utils.capped(_name) or _name
#		out.write(name)


class OldExpr
	inherits Expr

	def construct(token as IToken, expr as Expr)
		base.construct(token)

class TruthExpr
	inherits Expr
	"""
	A truth expr wraps an expression such that it can be used where a bool is expected in .NET/C#.
	For example, if passed an integer typed expression, the truth expression will wrap it with a
	comparison 0!=expr.
	"""

	var _useRuntimeService as bool
	var _expr as Expr

	def construct(expr as Expr)
		base.construct(expr.token)
		_useRuntimeService = false
		_expr = expr

#	def addSubFields
#		Expr.addSubFields
#		.addSubField('useRuntimeService', .useRuntimeService)
#		.addSubField('expr', .expr)

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		if _expr.type is not .compiler.boolType
# TODO
#			if _expr.isKindOf(tpassthrough)
#				_useRuntimeService = true
#			else if _expr.isKindOf(compiler.numberType)
#				_expr = BinaryOpExpr(nil, 'NE', IntegerLit(0), .expr)
#				_expr.bindImp(compiler)
#			else if _expr NilLiteral)
#				.expr = lfalse
#			else
			if true
				_useRuntimeService = true

	def toCobraSource as String is override
		return _expr.toCobraSource()

#	get asCS as String is override
#		require .didBindImp
#		return _expr.asCS

#	def genCS(out, genParens=true)
#		if .useRuntimeService
#			out.write('CobraImp.IsTrue(')
#			.expr.genCS(out)
#			out.write(')')
#		else
#			.expr.genCS(out, genParens=genParens)


class TypeExpr
	inherits Expr

	var _containedType as IType

	def construct(token as IToken, type as IType)
		base.construct(token)
		_containedType = type
		_receiverType = type

	def _bindImp is override
		base._bindImp()
		_type = .compiler.typeType


class UnaryOpExpr
	inherits Expr

	def construct(token as IToken, op as String, expr as Expr)
		base.construct(token)


##
## Literals
##

class Literal
	inherits Expr

	def construct(token as IToken)
		base.construct(token)

	get asCS as String
		return ''


# TODO:
#	def genCS(self, out, genParens=true):
#		out.write(.asCS())


class AtomicLiteral
	inherits Literal

	var _text as String

	def construct(token as IToken)
		base.construct(token)
		_text = token.text

	def bindImp as INode is override
		base.bindImp()
		assert _type, this
		return this

	def _bindImp is override
		base._bindImp()

	def toCobraSource as String is override
		return _text


class BoolLiteral
	inherits AtomicLiteral

	var _value as bool

	def construct(token as IToken)
		require token.text in ['true', 'false']
		base.construct(token)
		_value = token.text=='true'

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType

	get asCS as String is override
		return if(_value, 'true', 'false')


class CharLit
	inherits AtomicLiteral

	var _value as String  # TODO: should probably be char

	def construct(token as IToken)
		require
			token.which in ['CHAR_LIT_SINGLE', 'CHAR_LIT_DOUBLE']
			token.value inherits String
		code
			base.construct(token)
			_value = token.value to String

	def _bindImp is override
		base._bindImp()
		_type = .compiler.charType

	get asCS as String is override
		return "'" + _value.toString() + "'"


class DecimalLit
	inherits AtomicLiteral

	var _value as decimal

	def construct(token as IToken)
		require token.value inherits decimal
		base.construct(token)
		_value = token.value to decimal

	def _bindImp is override
		base._bindImp()
		_type = .compiler.decimalType

	get asCS as String is override
		return _value.toString()


class FloatLit
	inherits AtomicLiteral

	var _value as float

	def construct(token as IToken)
		require token.value inherits float
		base.construct(token)
		_value = token.value to float

	def _bindImp is override
		base._bindImp()
		_type = .compiler.floatType

	get asCS as String is override
		return _value.toString()


class IntegerLit
	inherits AtomicLiteral

	var _value as int

	def construct(token as IToken)
		require token.value inherits int
		base.construct(token)
		_value = token.value to int

	def _bindImp is override
		base._bindImp()
		_type = .compiler.intType

	get asCS as String is override
		return _value.toString()


class NilLiteral
	inherits AtomicLiteral

	def construct(token as IToken)
		base.construct(token)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.nilType


class StringLit
	inherits AtomicLiteral

	def construct(token as IToken)
		require token.which.startsWith('STRING')
		base.construct(token as IToken)
		# AXE? .text = token.value

	def _bindInt is override
		if not _type
			_type = .compiler.libraryType('System', 'String')
		base._bindInt()

	def _bindImp is override
		if not _type
			_type = .compiler.libraryType('System', 'String')
		base._bindImp()

#	def toCobraSource(self)
#		return .token.text

#	def asCS(self)
#		.assertType()
#		return .csStringLitFor(.text)


class StringSubstLit
	inherits Literal

	var _items as List<of Expr>

	def construct(items as List<of Expr>)
		require items
		base.construct(items[0].token)
		_items = items

	def _bindImp is override
		base._bindImp()
		for item in _items
			item.bindImp()
		if not _type
			_type = .compiler.libraryType('System', 'String')

# TODO:
#	def genCS(out, genParens=false)
#		out.write('CobraImp.MakeString(')
#		sep = ''
#		for item in _items
#			out.write(sep)
#			if inherits(item, str)
#				out.write(_csStringLitFor(item))
#			else if inherits(item, FormattedExpr)
#				out.write('CobraImp.ToString(')
#				item.expr.genCS(out)
#				out.write(',')
#				out.write(_csStringLitFor(item.format))
#				out.write(')')
#			else if inherits(item, Expr)
#				out.write('CobraImp.ToString(')
#				item.genCS(out)
#				out.write(')')
#			else
#				assert 0, item
#			sep = ','
#		out.write(')')

class FormattedExpr
	inherits Expr
	"""
	This is used exclusively for string substitutions that have formatting:
		'[i:N]'
	"""

	var _expr as Expr
	var _format as String

	def construct(expr as Expr, format as String)
		base.construct(expr.token)
		_expr = expr
		_format = format

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()


class BaseLit
	inherits AtomicLiteral

	# TODO:

	def construct(token as IToken, box as Box)
		base.construct(token)

# TODO:
#	def genCS(self, out, genParens=false):
#		out.write('base')

	def memberForName(name as String) as IMember? is override
		assert .didBindImp
		assert _type
		assert false, 'TODO'
#		t = .receiverType and .receiverType or .type
#		try:
#			t = t.superType
#		except:
#			pass
#		return t.symbolForName(name, true)
		return nil


class ThisLit
	inherits AtomicLiteral

	# TODO: somewhere it has to be error checked that you're not assigning to
	# "this" (unless C# allows that which I doubt)

	def construct(token as IToken, box as Box)
		base.construct(token)
		_type = box

#	def genCS(self, out, genParens=false):
#		out.write('this')
