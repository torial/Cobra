class Expr
	inherits Stmt

	var _type as IType?
	var _receiverType as IType?
		"""
		The type for receiving messages which can be different than the
		_type in a static situation such as `ChessPiece.Color` (where
		Color is an enum). The type of that expression, if assigned to a
		local var, is Type. But if accessed with a further dot
		(`ChessPiece.Color.Black`), then the type is the Color
		enumeration itself--the receiverType.

		For a runtime access (ex: `user.name`) the two types are
		conceptually the same (ex: `String`) and _receiverType is left
		nil.

		_receiverType is used in memberForName() to look up members such
		as "Black".

		TODO: rename to _typeForMemberAccess
		"""

	def init(token as IToken)
		base.init(token)

	def addRefFields is override
		base.addRefFields()
		.addField('type', _type)

	get hasError as bool
		return if(.recordedError, true, false)

	pro type from var

	get receiverType as IType?  # TODO: consider renaming to typeForReceiver.
		return _receiverType ? _type

	def canBeAssignedTo(type as IType) as bool
		require
			.didBindImp
			.type
		body
			return .type.isAssignableTo(type)

	def toCobraSource as String
		return ''

	def isKindOf(type as IType) as bool
		require
			.type
			.compiler
		body
			# TODO: try pulling this if-statement out, since passThroughType should return true for isDescendantOf()
			if .type is .compiler.passThroughType
				return true
			return .type.isDescendantOf(type)

	def memberForName(name as String) as IMember?
		require
			.didBindImp
			.type
		body
			t = _receiverType ? _type  # TODO: change to .receiverType
			# TODO: change code below to something like. if container inherits IContainer ...
			while true
				if t inherits QualifiedType  # TODO: another example of QualifiedType being a pain
					wt = t.theWrappedType
					if wt is nil
						t.bindInt()
						wt = t.theWrappedType
						assert wt
					$sharp('t = wt')
				else
					break
			container = t to? IContainer
			if container!
				return container.memberForName(name)
			else
				# TODO: at some point this might be an error to access a member of a nilable type, but not for now...
				if t inherits NilableType
					nt = t to NilableType
					container = nt.theWrappedType to? IContainer
					if container!
						return container.memberForName(name)
				return nil

	get binarySuperNode as BinaryOpExpr
		require
			.superNode
			.superNode inherits BinaryOpExpr
		body
			return .superNode to BinaryOpExpr

	def bindImp as INode is override
		base.bindImp()
		assert .didBindImp, this
		.postBindImpAssertType()
		return this

	def postBindImpAssertType
		"""
		This is broken out because in rare cases, it doesn't apply. (Those classes override this to
		do nothing.)
		"""
		if not .hasError
			assert .type, this

	def _bindImp is override
		base._bindImp()
		if _type is nil and .getType().name=='Expr'  # CC: cannot say ... and .getType() is Expr
			# TODO: this happens with formatted strings, but why?
			# I mean, why does an Expr get created in the first place? Could put an assert in the constructor to trap it.
			_type = .compiler.passThroughType

	## Code gen

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		.writeSharpDef(sw, true)

	def writeSharpDef(sw as SharpWriter, parens as bool)
		pass

	def writeSharpStmt(sw as SharpWriter) is override
		assert .didBindImp
		sw.node(this)
		.writeSharpSetLine(sw)
		.writeSharpDef(sw, false)
		sw.write(';\n')


class AsExpr
	inherits Expr
	"""
	i as int = 5
	The "i as int" is an AsExpr.
	"""

	var _name as String
	var _nameToken as IToken  # the identifier vs. the `as` keyword which is the main token
	var _typeNode as INode
	var _definition as INamedNode?

	def init(token as IToken, nameToken as IToken, typeNode as INode)
		base.init(token)
		_nameToken = nameToken
		_name = nameToken.text
		_typeNode = typeNode

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addSubFields is override
		base.addSubFields()
		.addField('typeNode', _typeNode)
		.addField('definition', _definition)

	get definition from var

	def _bindImp is override
		base._bindImp()
		_typeNode.bindAll()
		_type = _typeNode.namedType
		assert _type, _typeNode
		# make the local var if necessary (usually is)
		definition = .compiler.findLocal(_name)
		if definition is nil
			newVar = LocalVar(_nameToken, _type)
			newVar.bindAll()
			.compiler.codeMemberStack.peek().addLocal(newVar)
			_definition = newVar
		# TODO: check for redefinitions that are invalid by comparing .type with definition.type

	def afterStatementBindImp is override
		base.afterStatementBindImp()
		if not .type inherits NilableType
			if .type.isReference
				_error('Must initialize this non-nil object type, or change the type to nilable (suffix a ?).')

	get asSharp as String
		return _name

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write(.asSharp)

	def writeSharpStmt(sw as SharpWriter) is override
		# this happens for declarations like "i as int"
		sw.write('// [_name] as [_type.name]\n')


class CallExpr
	inherits Expr

	var _name as String
	var _args as List<of Expr>
	var _definition as INamedNode?
	var _isNew as bool  # "Exception('foo')" would be a CallExpr that isNew
	var _isCallOnSystemType as bool  # "t()" where t is of System.Type would be a CallExpr that isCallOnSystemType

	def init(token as IToken, name as String, args as List<of Expr>)
		base.init(token)
		_name = name
		_args = args
		_definition = nil

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	def addSubFields is override
		base.addSubFields()
		.addField('args', _args)

	get hasError as bool is override
		if base.hasError
			return true
		for arg in _args
			if arg.hasError
				return true
		return false

	get name from var

	get args from var

	get definition from var

	def _bindImp is override
		base._bindImp()

		num = 1
		for arg in _args
			try
				arg.bindImp()
			catch ne as NodeException
				ne.prefixMessage('"[_name]" arg [num]: ')
				if .compiler.recordErrorAndThrow(ne)
					throw
			num += 1

		definition as INamedNode?
		type as IType?

		if _definition is nil  or  _type is nil
			handled = false
			if _superNode inherits DotExpr
				if this is _superNode.right
					checkName = _name
					while checkName.startsWith('_')
						checkName = checkName.substring(1)
					if _superNode.left.type inherits Box and checkName and Utils.startsNonLower(checkName)
						_error('Methods must start with lowercase letters (not counting underscores). The name is \"[_name]\".')
					# handle foo.bar() where this is the `bar()` part
					possibleDefinition = _superNode.left.memberForName(_name)
					if possibleDefinition is nil
						if _superNode.left.receiverType is .compiler.passThroughType or _superNode.left.receiverType inherits PrimitiveType  # TODO: lame: bailing out on PrimitiveType so float.parse() will work. See Tests\150-basics-two\510-number-parse.cobra
							if _name=='toString'
								type = .compiler.libraryType('System', 'String')
							else
								type = .compiler.passThroughType
						else
							_error('Cannot find "[_name]" in [_superNode.left.receiverType.name].')
					else
						if not possibleDefinition.isCallable
							_error('Cannot call "[_name]" because it is a "[possibleDefinition.englishName]".')
						definition = possibleDefinition
						type = possibleDefinition.resultType
					handled = true
			if handled
				assert type is not nil
			else
				# handle instantiation such Car() or t() (where t is a System.Type)
				canBeMember = _name.startsWith('_') or Utils.isCapped(_name)
				if canBeMember
					assert .compiler.boxStack
					definition = .compiler.symbolForName(_name, canBeMember, false) to passthrough
				else
					definition = .compiler.findLocal(_name)
				if definition is nil
					_error('Cannot find "[_name]".')
				_isCallOnSystemType = not definition inherits Box and not definition inherits Method
			if definition is not nil
				if definition inherits IVar
					# such as having:
					#	t as Type
					#	...
					#	x = t()
					if definition.type.isDescendantOf(.compiler.libraryType('System', 'Type'))
						type = .compiler.libraryType('System', 'Object')  # TODO: should be dynamic type
					else
						_error('Cannot call a variable of type [definition.type.name].')
				else if definition inherits Box
					if definition inherits Interface
						_error('Cannot instantiate an interface.')
					else if definition inherits Class or definition inherits Struct
						# constructing an instance of a class or struct
						type = definition
					else
						# not ever expected since the three Box types are covered above
						throw FallThroughException(definition)
				else if definition inherits ClassMember
					type = definition.resultType  # NOTE: used to have .namedType at the end
					if definition inherits MemberOverload
						pass  # TODO handle overloads (1)
					else
						args = _args
						hasVari = false
						for param in definition.params
							if param.type inherits VariType
								hasVari = true
						if hasVari
							# TODO handle variable number of args (4)
							pass
						else
							check = true
							if not definition.hasParams
								if args.count
									_error('The method "[definition.name]" is expecting 0 arguments, but [args.count] are being supplied in this call.')
							else
								paramsx = definition.params  # CC: rename paramsx to params
								if args.count<>paramsx.count
									if _name=='toString'  # TODO because many structs like Decimal have a toString() overload which cannot currently be expressed in SystemInterfaces.cobra
										check = false
									else
										_error('The method "[definition.name]" is expecting [paramsx.count] arguments, but [args.count] are being supplied in this call.')
								if check
									for i = 0 .. args.count
										arg = args[i]
										paramx = paramsx[i]  # CC: rename paramx to param
										if arg.hasError
											break
										assert arg.didBindImp, arg
										assert paramx.didBindInt, paramx
										if not arg.canBeAssignedTo(paramx.type)
		# TODO
		#									if paramx.type.__class__.__name__.startswith('GenericParam')
		#										# TODO support generic params (2)
		#										pass
		#									else
											if true
												if false
													print '<> arg = ' stop
													arg.writeDeepString()
													print '<> paramx = ' stop
													paramx.writeDeepString()
												_error('Argument [i+1] of method "[_name]" expects type [paramx.type.name], but the call is supplying type [arg.type.name].')
				else
					throw FallThroughException(definition)
			if type is nil
				type = .compiler.passThroughType
			_definition = definition
			_type = type
		_isNew = _definition inherits Box
		assert _type, 'this=[this], def=[_definition]'

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_name)
		sb.append('(')
		sep = ''
		for arg in _args
			sb.append(sep)
			sb.append(arg.toCobraSource())
			sep = ', '
		sb.append(')')
		return sb.toString()

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		name = .name
		if _isCallOnSystemType
			defi = _definition
			what = if(defi inherits Class, 'typeof([_definition.name])', defi.sharpName)
			sw.write('Activator.CreateInstance([what]')
			sep = ','  # TODO: sep = ', '
			for arg in _args
				sw.write(sep)
				arg.writeSharpDef(sw, false)
			sw.write(')')
			return
		if _isNew
			if parens
				sw.write('(')
			sw.write('new ')
		else
			if .superNode inherits DotExpr  # otherwise, code could be: _underscoredDoesNotRequireDot()
				name = Utils.capped(name)
		sw.write('[name](')
		sep = ''
		for arg in _args
			sw.write(sep)
			arg.writeSharpDef(sw, false)
			sep = ', '
		sw.write(')')
		if _isNew and parens
			sw.write(')')


class IdentifierExpr
	inherits Expr

	var _text as String
	var _definition as INamedNode?
		"""
		In practice, definitions include:
			* Class, Struct, Interface
			* NameSpace, EnumDecl
			* ClassVar, LocalVar, Param
		There may be others, but at least those have been observed in practice.
		"""

	def init(token as IToken, text as String, definition as INamedNode?)
		base.init(token)
		_text = text
		_definition = definition

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	pro definition from var

	get text from var

	get namedType as IType? is override
		# overridden to return the type this identifier represents in those cases when it does represent a type such an "int" or a class
		assert .didBindImp
		assert .type
		assert .compiler
		if .type.isDescendantOf(.compiler.typeType) or .type inherits Box
			assert .definition
			defi = .definition
			if defi inherits IType
				return defi
			else
				throw FallThroughException(defi)
		else
			return nil

	def memberForName(name as String) as IMember? is override
		require
			.didBindImp
			.definition
		body
			return _definition.typeForReceiver.memberForName(name)

	def _bindImp is override
		base._bindImp()
		if _definition is nil
			canBeMember = _text.startsWith('_') or Utils.isCapped(_text)  # isCapped could be an enum or, in the future, a nested class
			if canBeMember
				assert .compiler.boxStack
				_definition = .compiler.symbolForName(_text, canBeMember, false) to passthrough
			else
				_definition = .compiler.findLocal(_text)
			if _definition is nil and not canBeMember
				if _superNode inherits BinaryOpExpr
					if _superNode.right is this
						curBox = .compiler.boxStack.peek()  # TODO: would like to use compiler.curClass except that could be an interface or struct. compiler.curCompositeType
						definition = curBox.symbolForName(_text, true, true)
						if definition is not nil
							_error('You must refer to non-underscored members with a leading dot (.). Member name is "[_text]".')

			# TODO: The effect of using symbolForName() just above and the next 3 lines is that class members mask globals of the same name. This will become a problem when module-level functions are supported.
			#from Module import ClassMemberDecl
			#if compiler.opStack and compiler.opStack.peek()!='ASSIGN':  # don't interfere with type inference. tests\200-class-decls\508-properties-access.cobra
			#if isinstance(self.definition, ClassMemberDecl) and self.definition.requiresDotPrefix: # and not self.text.startswith('_'):
			#	self.error('You must refer to non-underscored members with a leading dot (.).')

			if _definition is nil and (not _superNode inherits BinaryOpExpr or .binarySuperNode.op<>'ASSIGN')
				msg = 'Unknown identifier: "[_text]".'
				sug = .compiler.suggestionFor(_text)
				if sug
					msg += ' Maybe you should try "[sug]".'
				_error(msg)
		if _type is nil
			if _definition
				_type = _definition.typeForIdentifier
			else
				if .binarySuperNode and .binarySuperNode inherits AssignExpr and this is .binarySuperNode.left
					pass  # let the AssignExpr have its chance at type inference
				else
					.errorUnknownId(.text)

	def postBindImpAssertType is override
		pass

	def toCobraSource as String is override
		return _text

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if .superNode inherits DotExpr and .binarySuperNode.right is this
			assert false, 'does this happen?'  # TODO: if not, axe this portion
			sw.write(Utils.capped(_text))
		else
			# if this names a type and it's not dotted, then C# requires typeof()
			if _type inherits TypeType
				if .superNode is nil or .superNode inherits AssignExpr and .binarySuperNode.right is this and not .sharpName.startsWith('_lh')
					sw.write('typeof('+.sharpName+')')
					return
			sw.write(.sharpName)

	get sharpName as String
		assert .didBindImp, this
		assert .definition, this
		assert not .type inherits UnspecifiedType
		if .superNode
			if .superNode inherits DotExpr
				assert this is not (.superNode to DotExpr).right  # should be a CallExpr or MemberExpr instead  # CC: shouldn't need that cast
		defi = .definition
		if defi inherits Box and _type.isDescendantOf(.compiler.libraryType('System', 'Type'))  # TODO: is the "and ..." part even necessary?
			# C# often requires typeof(Foo) instead of just plain Foo
			if .superNode is nil or (.superNode inherits AssignExpr and (.superNode to AssignExpr).right is this)
				if not defi.sharpName.startsWith('_lh')  # TODO: I forget why this has to be guarded against... figure out and put a comment here
					return 'typeof(' + defi.sharpName + ')'
		return defi.sharpName

	def writeSharpStmt(sw as SharpWriter) is override
		assert false, 'not expecting to be called'

	get sharpAssignmentNames as List<of String>?
		require
			.didBindImp
			.definition
		body
			if _definition inherits IVar
				return (_definition to IVar).sharpAssignmentNames
			else
				return nil


class IfExpr
	inherits Expr

	var _cond as Expr
	var _tpart as Expr
	var _fpart as Expr

	def init(token as IToken, cond as Expr, tpart as Expr, fpart as Expr)
		base.init(token)
		_cond = cond
		_tpart = tpart
		_fpart = fpart

	def addSubFields is override
		base.addSubFields()
		.addField('cond', _cond)
		.addField('tpart', _tpart)
		.addField('fpart', _fpart)

	get hasError as bool is override
		if base.hasError
			return true
		if _cond.hasError
			return true
		if _tpart.hasError
			return true
		if _fpart.hasError
			return true
		return false

	def _bindImp is override
		base._bindImp()
		tpart = _tpart
		fpart = _fpart
		hadError = false
		try
			_cond.bindImp()
		catch ne as NodeException
			if .compiler.recordErrorAndThrow(ne)
				throw
			hadError = true
		if not hadError and not _cond.type.isDescendantOf(.compiler.boolType)
			_cond = TruthExpr(_cond).bindAll() to TruthExpr  # CC: axe cast when "as this"
		try
			_tpart.bindImp()
		catch ne as NodeException
			if .compiler.recordErrorAndThrow(ne)
				throw
			hadError = true
		try
			_fpart.bindImp()
		catch ne as NodeException
			if .compiler.recordErrorAndThrow(ne)
				throw
			hadError = true
		if hadError
			return
		# @@ TODO: use greatest common denominator between the 2 types. Right now if() expects that one inherits the other or one of them is nil.
		assert tpart.type
		assert fpart.type
		if tpart.isKindOf(fpart.type to IType)  # CC: change: to !
			_type = fpart.type
		else if fpart.isKindOf(tpart.type to IType)  # CC: change: to !
			_type = tpart.type
		else if fpart.isKindOf(.compiler.nilType)
			_type = .compiler.nilableType(tpart.type to IType)  # CC: change: to !
		else if tpart.isKindOf(.compiler.nilType)
			_type = .compiler.nilableType(fpart.type to IType)  # CC: change: to !
		else
			_error('The return expressions of the if() do not have compatible types. They are "[tpart.type.name]" and "[fpart.type.name]".')

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write('(')
		_cond.writeSharpDef(sw)
		sw.write('?')
		_tpart.writeSharpDef(sw)
		sw.write(':')
		_fpart.writeSharpDef(sw)
		sw.write(')')


class IndexExpr
	inherits Expr

	var _target as Expr
	var _args as List<of Expr>

	def init(token as IToken, target as Expr, args as List<of Expr>)
		base.init(token)
		_target = target
		_args = args

	def addSubFields is override
		base.addSubFields()
		.addField('target', _target)
		.addField('args', _args)

	get hasError as bool is override
		if base.hasError
			return true
		if _target.hasError
			return true
		for arg in _args
			if arg.hasError
				return true
		return false

	def _bindImp is override
		base._bindImp()
		_target.bindImp()
		for arg in _args
			try
				arg.bindImp()
			catch ne as NodeException
				if .compiler.recordErrorAndThrow(ne)
					throw
		if _type is nil
			# CC: use a list comprehension to get the types
			# _target.type.indexType(for arg in _args get arg.type)
			argTypes = List<of IType>()
			for arg in _args
				argTypes.add(arg.type to IType)  # CC: to !
			_type = _target.type.indexType(argTypes)
			if _type is nil
				_type = .compiler.passThroughType

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_target.toCobraSource())
		sb.append(r'[')
		sep = ''
		for arg in _args
			sb.append(sep)
			sb.append(arg.toCobraSource())
			sep = ', '
		sb.append(']')
		return sb.toString()

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		_target.writeSharpDef(sw)
		sw.write(r'[')
		sep = ''
		for expr in _args
			sw.write(sep)
			expr.writeSharpDef(sw)
			sep = ','
		sw.write(']')
		if parens
			sw.write(')')


class IsNilExpr
	inherits Expr

	var _expr as Expr

	def init(token as IToken, expr as Expr)
		base.init(token)
		_expr = expr

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		_type = .compiler.boolType

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		sw.write('(')
		_expr.writeSharpDef(sw)
		sw.write(')')
		sw.write('==null')
		if parens
			sw.write(')')


class IsNotNilExpr
	inherits Expr

	var _expr as Expr

	def init(token as IToken, expr as Expr)
		base.init(token)
		_expr = expr

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		_type = .compiler.boolType

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		sw.write('(')
		_expr.writeSharpDef(sw)
		sw.write(')')
		sw.write('!=null')
		if parens
			sw.write(')')


class MemberExpr
	inherits Expr
	"""
	Example members are fields and properties.
	"""

	var _name as String
	var _definition as IMember?

	def init(token as IToken, name as String)
		base.init(token)
		_name = name

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	get definition from var

	def _bindImp is override
		require
			.superNode inherits BinaryOpExpr
			.binarySuperNode.op == 'DOT'
			.binarySuperNode.right is this
		ensure
			true or .type  # TODO: get rid of true @@@@@ # CC: should really be the ensure of Expr
		body
			base._bindImp()
			if _definition is nil or _type is nil
				_definition = .binarySuperNode.left.memberForName(_name)
				if _definition is nil
					if .binarySuperNode.left.receiverType is .compiler.passThroughType
						_type = .compiler.passThroughType
						return
					if _name=='length'
						# TODO get rid of this total hack to support the vari type (and possibly arrays in general)
						_type = .compiler.intType
						.binarySuperNode.type = .type
						return
					if Utils.isCapped(_name)
						sugg = 'If the name is essentially correct, try the lowercase version ("[Utils.uncapped(_name)]") instead.'
					else
						sugg = ''
					_error('Cannot find a definition for "[_name]" in "[.binarySuperNode.left.token.text]" whose type is "[.binarySuperNode.left.receiverType.name]". [sugg]')
				assert _definition
				if _definition inherits IType
					effectiveType as IType = .compiler.typeType  # namespace, class, interface
					receiverType as IType? = _definition to IType  # TODO: should not need "as IType". Type inference is not respecting the if-inherits stack
				else
					effectiveType = _definition.resultType
					receiverType = nil
				assert effectiveType
				_type = effectiveType
				_type.bindInt()
				# TODO: there should be a subclass of BinaryOpExpr called DotExpr and it should do the following work and maybe even the work above.
				# TODO: _receiverType = receiverType
				.binarySuperNode.definition = _definition  # TODO: is this needed?
				.binarySuperNode.type = .type  # the type of foo.bar is what bar returns. A MemberExpr is the "bar" part.
				.binarySuperNode.setReceiverType(receiverType)
			assert _type
			_type.bindInt()

	def toCobraSource as String is override
		return _name

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		assert .superNode inherits DotExpr
		sw.write(Utils.capped(_name))


class OldExpr
	inherits Expr

	var _expr as Expr
	var _sharpVarName as String

	def init(token as IToken, expr as Expr)
		base.init(token)
		_expr = expr

	pro sharpVarName from var

	get name as String
		return 'old'

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def addSubFields is override
		base.addSubFields()
		.addField('expr', _expr)

	def _bindImp is override
		base._bindImp()
		curCodeMember = .compiler.codeMemberStack.peek()
		assert curCodeMember
		curCodeMember.addOldExpr(this)  # will set the sharpVarName
		_expr.bindImp()
		_type = _expr.type
		assert _type

	def writeSharpAssignment(sw as SharpWriter)
		require
			.didBindImp
			.sharpVarName
			.type
		body
			sw.write('[.type.sharpRef] [_sharpVarName] = ')
			_expr.writeSharpDef(sw)
			sw.write(';\n')

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		assert _sharpVarName
		# this gets called when generating the `ensure` code
		sw.write(_sharpVarName)


class PostCallExpr
	inherits Expr
	"""
	Covers cases like:
		obj[i]('x')
	For "bar.foo('x')" that's a binary dot expression with a CallExpr on the right hand side.
	For "Car()" or "someType()" that's also a CallExpr.
	"""

	var _expr as Expr
	var _args as List<of Expr>

	def init(token as IToken, expr as Expr, args as List<of Expr>)
		base.init(token)
		_expr = expr
		_args = args

	def addSubFields is override
		base.addSubFields()
		.addField('expr', _expr)
		.addField('args', _args)

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		for arg in _args
			if arg.hasError
				return true
		return false

	def _bindImp is override
		base._bindImp()
		for arg in _args
			try
				arg.bindImp()
			catch ne as NodeException
				if .compiler.recordErrorAndThrow(ne)
					throw
		_expr.bindImp()
		if _expr inherits TypeExpr
			assert _expr.containedType
			_type = _expr.containedType
		else
			assert false, 'what is this? _expr=[_expr]'

	def toCobraSource as String is override
		assert false, 'TODO'
		return ''
#		sb = []
#		sb.append(_expr.toCobraSource())
#		sb.append('(')
#		sep = ''
#		for arg in _args
#			sb.append(sep)
#			sb.append(arg.toCobraSource())
#			sep = ', '
#		sb.append(')')
#		return ''.join(sb)

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		#sw.write('(')
		if _expr inherits TypeExpr
			sw.write('new ')
		_expr.writeSharpDef(sw)
		#sw.write(')')
		sw.write('(')
		sep = ''
		for arg in _args
			sw.write(sep)
			arg.writeSharpDef(sw, false)
			sep = ','
		sw.write(')')
		if parens
			sw.write(')')


class SharpExpr
	inherits Expr

	var _expr as StringLit

	def init(token as IToken, expr as Expr)
		base.init(token)
		if expr inherits StringLit  # TODO:? make this an arg type
			_expr = expr
		else
			assert false, expr

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def _bindImp is override
		base._bindImp()
		_type = .compiler.passThroughType
		_expr.bindImp()

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		sw.write(_expr.token.value)
		if parens
			sw.write(')')


class TruthExpr
	inherits Expr
	"""
	A truth expr wraps an expression such that it can be used where a bool is expected in .NET/C#.
	For example, if passed an integer typed expression, the truth expression will wrap it with a
	comparison 0!=expr.
	"""

	var _useRuntimeService as bool
	var _expr as Expr

	def init(expr as Expr)
		base.init(expr.token)
		_useRuntimeService = false
		_expr = expr

	def addSubFields is override
		base.addSubFields()
		.addField('useRuntimeService', _useRuntimeService)
		.addField('expr', _expr)

	get expr from var

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		if _expr.type is not .compiler.boolType
			if _expr.isKindOf(.compiler.passThroughType)
				_useRuntimeService = true
			else if _expr.type inherits NumberType  # TODO: should this be: if _expr.isKindOf(.compiler.numberType)
				_expr = CompareExpr(_expr.token, 'NE', IntegerLit(_expr.token, 0), _expr)
			else if $sharp('_expr is NilLiteral')
				_expr = BoolLit(_expr.token, false)
			else
				_useRuntimeService = true
			_expr.bindImp()
		_type = .compiler.boolType

	def toCobraSource as String is override
		return _expr.toCobraSource()

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _useRuntimeService
			sw.write('CobraImp.IsTrue(')
			_expr.writeSharpDef(sw, false)
			sw.write(')')
		else
			_expr.writeSharpDef(sw, parens)


class TypeExpr
	inherits Expr

	var _typeNode as ISyntaxNode?
	var _containedType as IType?

	def init(typeNode as ISyntaxNode)
		base.init(typeNode.token)
		_typeNode = typeNode

	def init(token as IToken, type as IType)
		base.init(token)
		_containedType = type
		_receiverType = type

	get containedType from var

	get namedType as IType? is override
		assert .didBindImp
		assert _containedType
		return _containedType

	def addRefFields is override
		base.addRefFields()
		.addField('containedType', _containedType)

	def addSubFields is override
		base.addSubFields()
		.addField('typeNode', _typeNode)

	def _bindImp is override
		base._bindImp()
		if _typeNode is not nil
			_typeNode.bindImp()
			t = _typeNode.namedType
			if t is nil
				assert false, 'when does this happen?'
			if t is not nil
				_containedType = t
				_receiverType = t
		_type = .compiler.typeType

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		_containedType.writeSharpRef(sw)


class UnaryOpExpr
	inherits Expr

	var _op as String
	var _expr as Expr

	def init(token as IToken, op as String, expr as Expr)
		base.init(token)
		_op = op
		_expr = expr

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		if _type is nil
			_type = _expr.type
		branch _op
			on 'MINUS'
				_type = _expr.type
			on 'NOT'
				if _expr.type is not .compiler.boolType
					_expr = TruthExpr(_expr).bindAll() to TruthExpr  # CC: axe when "as this"
					_type = .compiler.boolType
			# TODO: handle DOT?
			else
				throw FallThroughException(_op)

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		branch _op
			on 'MINUS'
				sw.write('-')
			on 'NOT'
				sw.write('!')
			else
				throw FallThroughException(_op)
		_expr.writeSharpDef(sw)
		if parens
			sw.write(')')


##
## Literals
##

class Literal
	inherits Expr

	def init(token as IToken)
		base.init(token)

	get asSharp as String
		return ''

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write(.asSharp)


class AtomicLiteral
	inherits Literal

	var _text as String

	def init(token as IToken)
		base.init(token)
		_text = token.text

	def bindImp as INode is override
		base.bindImp()
		.checkType()
		return this

	def checkType
		assert _type, this

	def _bindImp is override
		base._bindImp()

	def toCobraSource as String is override
		return _text


class BoolLit
	inherits AtomicLiteral

	var _value as bool

	def init(token as IToken)
		require token.text in ['true', 'false']
		base.init(token)
		_value = token.text=='true'

	def init(token as IToken, value as bool)
		base.init(token)
		_value = value

	def _bindImp is override
		base._bindImp()
		_type = .compiler.boolType

	get asSharp as String is override
		return if(_value, 'true', 'false')


class CharLit
	inherits AtomicLiteral

	var _value as String  # TODO: should probably be char

	def init(token as IToken)
		require
			token.which in ['CHAR_LIT_SINGLE', 'CHAR_LIT_DOUBLE']
			token.value inherits String
		body
			base.init(token)
			_value = token.value to String

	def _bindImp is override
		base._bindImp()
		_type = .compiler.charType

	get asSharp as String is override
		return "'" + _value.toString() + "'"


class DecimalLit
	inherits AtomicLiteral

	var _value as decimal

	def init(token as IToken)
		require token.value inherits decimal
		base.init(token)
		_value = token.value to decimal

	def _bindImp is override
		base._bindImp()
		_type = .compiler.decimalType

	get asSharp as String is override
		return _value.toString() + 'm'


class FloatLit
	inherits AtomicLiteral

	var _value as float

	def init(token as IToken)
		require token.value inherits float
		base.init(token)
		_value = token.value to float

	def _bindImp is override
		base._bindImp()
		_type = .compiler.floatType

	get asSharp as String is override
		s = _value.toString()
		if s.indexOf('.')==-1
			s += '.0'
		return s


class IntegerLit
	inherits AtomicLiteral

	var _value as int

	def init(token as IToken)
		require token.value inherits int
		base.init(token)
		_value = token.value to int

	def init(token as IToken, value as int)
		base.init(token)
		_value = value

	def _bindImp is override
		base._bindImp()
		_type = .compiler.intType

	get asSharp as String is override
		return _value.toString()


class NilLiteral
	inherits AtomicLiteral

	def init(token as IToken)
		base.init(token)

	def _bindImp is override
		base._bindImp()
		_type = .compiler.nilType

	get asSharp as String is override
		return 'null'


class StringLit
	inherits AtomicLiteral

	var _string as String  # String contents (with no surrounding quotes or escaping)

	def init(token as IToken)
		require token.which.startsWith('STRING')
		base.init(token as IToken)
		_string = token.value to String

	get string from var

	def _bindInt is override
		if not _type
			_type = .compiler.libraryType('System', 'String')
		base._bindInt()

	def _bindImp is override
		if not _type
			_type = .compiler.libraryType('System', 'String')
		base._bindImp()

	def toCobraSource as String is override
		return .token.text

	get asSharp as String is override
		return Utils.csStringLitFor(_string)


class StringSubstLit
	inherits Literal

	var _items as List<of Expr>

	def init(items as List<of Expr>)
		require items
		base.init(items[0].token)
		if true
			_items = items
		else
			# TODO: the efficient, but not debugged case
			# CC: potential
			# _items = for item in items if not item inherits StringLit or item.string get item
			_items = List<of Expr>()
			for item in _items
				if item inherits StringLit and not (item to StringLit).string
					continue
				_items.add(item)
			assert _items

	def addSubFields is override
		base.addSubFields()
		.addField('items', _items)

	get hasError as bool is override
		if base.hasError
			return true
		for item in _items
			if item.hasError
				return true
		return false

	def _bindImp is override
		base._bindImp()
		for item in _items
			try
				item.bindImp()
			catch ne as NodeException
				if .compiler.recordErrorAndThrow(ne)
					throw
		if not _type
			_type = .compiler.libraryType('System', 'String')

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _items.count>1
			sw.write('CobraImp.MakeString(')
		sep = ''
		for item in _items
			sw.write(sep)
			if item inherits StringLit
				item.writeSharpDef(sw, true)  # CC: axe the "true" when the bug about overload groups crossing inheritance is fixed
			else if item inherits FormattedExpr
				sw.write('CobraImp.ToString(')
				item.expr.writeSharpDef(sw)
				sw.write(',')
				sw.write(Utils.csStringLitFor(item.format))
				sw.write(')')
			else if item inherits Expr
				sw.write('CobraImp.ToString(')
				item.writeSharpDef(sw, false)
				sw.write(')')
			else
				throw FallThroughException(item)
			sep = ','
		if _items.count>1
			sw.write(')')


class FormattedExpr
	inherits Expr
	"""
	This is used exclusively for string substitutions that have formatting:
		'[i:N]'
	"""

	var _expr as Expr
	var _format as String

	def init(expr as Expr, format as String)
		base.init(expr.token)
		_expr = expr
		_format = format

	get expr from var

	get format from var

	get hasError as bool is override
		if base.hasError
			return true
		if _expr.hasError
			return true
		return false

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		_type = .compiler.libraryType('System', 'String')


class BaseLit
	inherits AtomicLiteral

	def init(token as IToken, box as Box)
		base.init(token)
		_type = box

	def checkType is override
		pass

	def memberForName(name as String) as IMember? is override
		assert .didBindImp
		assert _type
		t = .receiverType
		if t.superType
			t = t.superType
		#return t.symbolForName(name, true, true)
		return t.memberForName(name)

	get asSharp as String is override
		return 'base'


class ThisLit
	inherits AtomicLiteral

	# TODO: somewhere it has to be error checked that you're not assigning to
	# "this" (unless C# allows that which I doubt)

	def init(token as IToken, box as Box)
		base.init(token)
		_type = box

	get asSharp as String is override
		return 'this'

	def toCobraSource as String is override
		return 'this'


class VarLit
	inherits AtomicLiteral

	var _propertyMember as ProperDexerXetter?
	var _name as String
	var _var as IVar

	def init(token as IToken, propertyMember as ProperDexerXetter)
		base.init(token)
		_propertyMember = propertyMember
		_name = '_'+propertyMember.parent.name

	def _bindImp is override
		possible = _propertyMember.parent.box.symbolForName(_name, true, true)
		if possible is nil
			_error('Cannot find a class variable named "[_name]".')
		else if possible inherits IVar
			_var = possible
		else
			assert false, possible
		_type = _var.type
		_propertyMember = nil  # don't need this reference anymore
		base._bindImp()

	get asSharp as String is override
		return _name


class CompositeLiteral
	inherits Literal

	def init(token as IToken)
		base.init(token)


class ListLit
	inherits CompositeLiteral

	var _exprs as List<of Expr>

	def init(token as IToken, exprs as List<of Expr>)
		base.init(token)
		_exprs = exprs

	def addSubFields is override
		base.addSubFields()
		.addField('exprs', _exprs)

	get hasError as bool is override
		if base.hasError
			return true
		for expr in _exprs
			if expr.hasError
				return true
		return false

	def _bindImp is override
		base._bindImp()
		hadError = false
		for expr in _exprs
			try
				expr.bindImp()
			catch ne as NodeException
				if .compiler.recordErrorAndThrow(ne)
					throw
				hadError = true
		if hadError
			return
		if _type is nil
			exprs = _exprs
			if exprs.count==0
				type = .compiler.libraryType('System', 'Object')
			else
				type = exprs[0].type to IType
				i = 1
				while i<exprs.count
					exprs[i].bindImp()
					type = exprs[i].type.greatestCommonDenominatorWith(type)
					i += 1
				# TODO: get rid of this hack:
				if type.getType().name=='CobraType'
					type = .compiler.libraryType('System', 'Object')
			_type = .compiler.libraryType('System', 'Collections', 'Generic', 'List<of>').constructedTypeFor([type])
			_type.bindAll()

# TODO
#	def toCobraSource(self):
#		sb = []
#		sb.append('[')
#		sep = ''
#		for expr in self.exprs:
#			sb.append(sep)
#			sb.append(expr.toCobraSource())
#			sep = ', '
#		sb.append(']')
#		return ''.join(sb)

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		innerType = (_type to Box).params[0]
		sw.write('CobraImp.MakeList<')
		innerType.writeSharpRef(sw)
		sw.write('>(typeof(')
		_type.writeSharpRef(sw)
		sw.write(')')
		if _exprs
			sw.write(', ')
			sep = ''
			for expr in _exprs
				sw.write(sep)
				expr.writeSharpDef(sw, false)
				sep = ', '
		sw.write(')')


class DictLit
	inherits CompositeLiteral

	var _entries as List<of List<of Expr> >  # CC: >>

	def init(token as IToken, entries as List<of List<of Expr> >)  # CC: >>
		base.init(token)
		_entries = entries

	def addSubFields is override
		base.addSubFields()
		.addField('_entries', _entries)

	get hasError as bool is override
		if base.hasError
			return true
		for entry in _entries
			for expr in entry
				if expr.hasError
					return true
		return false

	def _bindImp is override
		base._bindImp()
		hadError = false
		for entry in _entries
			try
				entry[0].bindImp()
			catch ne as NodeException
				if .compiler.recordErrorAndThrow(ne)
					throw
				hadError = true
			try
				entry[1].bindImp()
			catch ne as NodeException
				if .compiler.recordErrorAndThrow(ne)
					throw
				hadError = true
		if hadError
			return
		if .type is nil
			entries = _entries
			if _entries.count==0
				keyType = valueType = .compiler.libraryType('System', 'Object')
			else
				keyType   = entries[0][0].type to IType  # CC: to !
				valueType = entries[0][1].type to IType  # CC: to !
				i = 1
				while i<entries.count
					keyType   = entries[i][0].type.greatestCommonDenominatorWith(keyType)
					valueType = entries[i][1].type.greatestCommonDenominatorWith(valueType)
					i += 1
				# TODO: get rid of this hack
				# if keyType is troot: keyType = compiler.typeForName('Object')
				# if valueType is troot: valueType = compiler.typeForName('Object')
			_type = .compiler.libraryType('System', 'Collections', 'Generic', 'Dictionary<of,>').constructedTypeFor([keyType, valueType])
			_type.bindAll()

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		assert (_type to Box).params.count==2
		keyType   = (_type to Box).params[0]
		valueType = (_type to Box).params[1]
		sw.write('CobraImp.MakeDict<[keyType.sharpRef],[valueType.sharpRef]>(typeof([_type.sharpRef])')
		if _entries
			sw.write(', ')
			sep = ''
			for entry in _entries
				sw.write(sep)
				entry[0].writeSharpDef(sw)
				sw.write(',')
				entry[1].writeSharpDef(sw)
				sep = ', '
		sw.write(')')
