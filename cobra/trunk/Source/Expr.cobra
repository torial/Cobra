class Expr
	inherits Stmt

	var _type as IType?

	def construct(token as IToken)
		base.construct(token)
		pass

	get type from var

	def toCobraSource as String
		return ''

	def memberForName(name as String) as ClassMember?
		return nil


class AsExpr
	inherits Expr
	"""
	i as int = 5
	The "i as int" is an AsExpr.
	"""

	var _name as String
#	var _token as IToken  # the 'as' keyword
	var _nameToken as IToken  # the identifier
	var _typeNode as Node
	var _definition as Node?

	def construct(token as IToken, nameToken as IToken, typeNode as Node)
		base.construct(token)
		_nameToken = nameToken
		_name = nameToken.text
		_typeNode = typeNode

# TODO:
#	def __repr__
#		return 'AsExpr(%s, %r, %r, type=%r, definition=%r)' % (
#		.serialNum, .token, .name, .type, getattr('definition', '(none)'))

	def _bindImp is override
		base._bindImp()
		_typeNode.bindInt()
		_typeNode.bindImp()
		_type = _typeNode.namedType
		_type.bindImp()
		# make the local var if necessary (usually is)
# TODO:		definition = compiler.findLocal(.name)
		definition as LocalVar?
		if definition is nil
			definition = LocalVar(_nameToken, _type)
			definition.bindAll()
# TODO:			.compiler.nameStack.peek().pushName(definition)
			_definition = definition
		# TODO: check for redefinitions that are invalid by comparing .type with definition.type

# TODO:
#	def afterStatementBindImp
#		base.afterStatementBindImp()
#		if not inherits(.type, NilableType)
#			if not inherits(.type, PrimitiveType)
#				.error('Must initialize this non-nil object type, or change the type to nilable (suffix a ?).')

	get asCS as String
		return _name

	def genCS(sw as IndentedWriter, genParams as bool)
		sw.write(.asCS)

#	def genCSStatement(out)
#		# this happens for declarations like "i as int"
#		out.write('// ')
#		.genCS(out)
#		out.write(';\n')


class CallExpr
	inherits Expr

	var _name as String
	var _args as List<of Expr>
	var _definition as ClassMember?

	def construct(token as IToken, name as String, args as List<of Expr>)
		base.construct(token)
		_name = name
		_args = args
		_definition = nil

	def _bindImp is override
		base._bindImp()

		for arg in _args
			arg.bindImp()

		type as IType?

		if _definition is nil  or  _type is nil
			if _superNode inherits BinaryOpExpr
				if _superNode.op=='DOT' and this is _superNode.right
					# handle foo.bar() where this is the `bar()` part
					definition = _superNode.left.memberForName(_name)
					if definition is nil
						type = .compiler.passThroughType
					else
						if not definition.isCallable
							_error('Cannot call "[_name]" because it is a "[definition.englishName]".')
						type = definition.resultType
			if definition is nil
				# TODO this needs to be an error in the long term
				type = .compiler.passThroughType
			else
				type = definition.resultType  # NOTE: used to have .namedType at the end
				if definition inherits MemberOverload
					pass  # TODO handle overloads (1)
				else
					args = _args
					if definition.hasVariParams
						# TODO handle variable number of args (4)
						pass
					else
						check = true
						if not definition.hasParams
							if args.count
								_error('The method is expecting 0 arguments, but [args.count] are being supplied in this call.')
						else
							paramsx = definition.params  # CC: rename paramsx to params
							if args.count<>paramsx.count
								if _name=='toString'  # TODO because many structs like Decimal have a toString() overload which cannot currently be expressed in SystemInterfaces.cobra
									check = false
								else
									_error('The method is expecting [paramsx.count] arguments, but [args.count] are being supplied in this call.')
							if check
								for i = 0 .. args.count
									arg = args[i]
									paramx = paramsx[i]  # CC: rename paramx to param
									assert arg.didBindImp
									assert paramx.didBindInt
									if not arg.type.isAssignableTo(paramx.type)
	# TODO
	#									if paramx.type.__class__.__name__.startswith('GenericParam')
	#										# TODO support generic params (2)
	#										pass
	#									else
										if true
											_error('Argument [i+1] of method "[_name]" expects type [paramx.type.name], but the call is supplying type [arg.type.name].')

			_definition = definition
			_type = type

		assert _type, 'this=[this], def=[_definition]'
		_type.bindImp()

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_name)
		sb.append('(')
		sep = ''
		for arg in _args
			sb.append(sep)
			sb.append(arg.toCobraSource())
			sep = ', '
		sb.append(')')
		return sb.toString()

#	def genCS(out, genParens=false)
#		if .isNew
#			if genParens
#				out.write('(')
#			out.write('new ')
#		name = .isDotted and capped(.name) or .name
#		out.write('%s(' % name)
#		genCSBinaryOpStack.push('(')  # on order to make .isDotted false for the args inside the call
#		try
#			sep = ''
#			for arg in .args
#				out.write(sep)
#				arg.genCS(out)
#				sep = ', '
#			out.write(')')
#		finally
#			genCSBinaryOpStack.pop()
#		if .isNew
#			if genParens
#				out.write(')')


class BinaryOpExpr
	inherits Expr

	var _op as String
	var _left as Expr
	var _right as Expr

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken)
		_op = op
		_left = left
		_left.superNode = this
		_right = right
		_right.superNode = this

	get op from var

	get left from var

	get right from var


class IdentifierExpr
	inherits Expr

	var _text as String
	var _definition as Node?

	def construct(token as IToken, text as String, definition as Node?)
		base.construct(token)
		_text = text
		_definition = definition
# TODO:
#		if definition is nil:
#			.type = nil
#		else:
#			.type = ._resolveType()


class IndexExpr
	inherits Expr

	# TODO

	def construct(token as IToken, target as Expr, exprs as List<of Expr>)
		base.construct(token)


class IsNilExpr
	inherits Expr

	def construct(token as IToken, expr as Expr)
		base.construct(token)


class IsNotNilExpr
	inherits Expr

	def construct(token as IToken, expr as Expr)
		base.construct(token)


class OldExpr
	inherits Expr

	def construct(token as IToken, expr as Expr)
		base.construct(token)

class TruthExpr
	inherits Expr
	"""
	A truth expr wraps an expression such that it can be used where a bool is expected in .NET/C#.
	For example, if passed an integer typed expression, the truth expression will wrap it with a
	comparison 0!=expr.
	"""

	var _useRuntimeService as bool
	var _expr as Expr

	def construct(expr as Expr)
		base.construct(expr.token)
		_useRuntimeService = false
		_expr = expr

#	def addSubFields
#		Expr.addSubFields
#		.addSubField('useRuntimeService', .useRuntimeService)
#		.addSubField('expr', .expr)

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		if _expr.type is not .compiler.boolType
# TODO
#			if _expr.isKindOf(tpassthrough)
#				_useRuntimeService = true
#			else if _expr.isKindOf(compiler.numberType)
#				_expr = BinaryOpExpr(nil, 'NE', IntegerLit(0), .expr)
#				_expr.bindImp(compiler)
#			else if _expr NilLiteral)
#				.expr = lfalse
#			else
			if true
				_useRuntimeService = true

	def toCobraSource as String is override
		return _expr.toCobraSource()

#	get asCS as String is override
#		require .didBindImp
#		return _expr.asCS

#	def genCS(out, genParens=true)
#		if .useRuntimeService
#			out.write('CobraImp.IsTrue(')
#			.expr.genCS(out)
#			out.write(')')
#		else
#			.expr.genCS(out, genParens=genParens)


class UnaryOpExpr
	inherits Expr

	def construct(token as IToken, op as String, expr as Expr)
		base.construct(token)


##
## Literals
##

class Literal
	inherits Expr

	def construct(token as IToken)
		base.construct(token)

	get asCS as String
		return ''


# TODO:
#	def genCS(self, out, genParens=true):
#		out.write(.asCS())


class AtomicLiteral
	inherits Literal

	var _text as String

	def construct(token as IToken)
		base.construct(token)
		_text = token.text

	def _bindImp is override
		base._bindImp()
		assert _type, this
		_type.bindImp()

	def toCobraSource as String is override
		return _text


class BoolLiteral
	inherits AtomicLiteral

	var _value as bool

	def construct(token as IToken)
		require token.text in ['true', 'false']
		base.construct(token)
		_value = token.text=='true'

	def _bindImp is override
		_type = .compiler.typeForName('bool')
		base._bindImp()

	get asCS as String is override
		return if(_value, 'true', 'false')


class IntegerLit
	inherits AtomicLiteral

	var _value as int

	def construct(token as IToken)
		require token.value inherits int
		base.construct(token)
		_value = token.value to int

	get asCS as String is override
		return _value.toString()


class NilLiteral
	inherits AtomicLiteral

	def construct(token as IToken)
		base.construct(token)

	def _bindImp is override
		_type = .compiler.typeForName('nil')
		base._bindImp()



class StringLit
	inherits AtomicLiteral

	def construct(token as IToken)
		require token.which.startsWith('STRING')
		base.construct(token as IToken)
		# AXE? .text = token.value

	def _bindInt
		if not _type
			_type = .compiler.typeForName('String')
		base._bindInt()

	def _bindImp
		if not _type
			_type = .compiler.typeForName('String')
		base._bindImp()

#	def toCobraSource(self)
#		return .token.text

#	def asCS(self)
#		.assertType()
#		return .csStringLitFor(.text)


class BaseLit
	inherits AtomicLiteral

	# TODO:

	def construct(token as IToken, box as Box)
		base.construct(token)

# TODO:
#	def genCS(self, out, genParens=false):
#		out.write('base')

	def memberForName(name as String) as ClassMember? is override
		assert .didBindImp
		assert _type
		assert false, 'TODO'
#		t = .receiverType and .receiverType or .type
#		try:
#			t = t.superType
#		except:
#			pass
#		return t.symbolForName(name, true)
		return nil


class ThisLit
	inherits AtomicLiteral

	# TODO: somewhere it has to be error checked that you're not assigning to
	# "this" (unless C# allows that)

	def construct(token as IToken, box as Box)
		base.construct(token)
# TODO:		_type = theClass

# TODO
#	def genCS(self, out, genParens=false):
#		out.write('this')
