class Expr
	inherits Stmt

	var _type as IType?
	var _receiverType as IType?
		"""
		The type for receiving messages which can be different than the
		_type in a static situation such as `ChessPiece.Color` (where
		Color is an enum). The type of that expression, if assigned to a
		local var, is Type. But if accessed with a further dot
		(`ChessPiece.Color.Black`), then the type is the Color
		enumeration itself--the receiverType.

		For a runtime access (ex: `user.name`) the two types are
		conceptually the same (ex: `String`) and _receiverType is left
		nil.

		_receiverType is used in memberForName() to look up members such
		as "Black".

		TODO: rename to _typeForMemberAccess
		"""

	def construct(token as IToken)
		base.construct(token)
		pass

	pro type from var

	def toCobraSource as String
		return ''

	def memberForName(name as String) as IMember?
		require
			.didBindImp
			.type
		code
			t = _receiverType ? _type
			container = t to? IContainer
			if container!
				return container.declForName(name)
			else
				return nil


class AsExpr
	inherits Expr
	"""
	i as int = 5
	The "i as int" is an AsExpr.
	"""

	var _name as String
#	var _token as IToken  # the 'as' keyword
	var _nameToken as IToken  # the identifier
	var _typeNode as INode
	var _definition as INode?

	def construct(token as IToken, nameToken as IToken, typeNode as INode)
		base.construct(token)
		_nameToken = nameToken
		_name = nameToken.text
		_typeNode = typeNode

# TODO:
#	def __repr__
#		return 'AsExpr(%s, %r, %r, type=%r, definition=%r)' % (
#		.serialNum, .token, .name, .type, getattr('definition', '(none)'))

	def _bindImp is override
		base._bindImp()
		_typeNode.bindInt()
		_typeNode.bindImp()
		_type = _typeNode.namedType
		_type.bindImp()
		# make the local var if necessary (usually is)
# TODO:		definition = compiler.findLocal(.name)
		definition as LocalVar?
		if definition is nil
			definition = LocalVar(_nameToken, _type)
			definition.bindAll()
# TODO:			.compiler.nameStack.peek().pushName(definition)
			_definition = definition
		# TODO: check for redefinitions that are invalid by comparing .type with definition.type

# TODO:
#	def afterStatementBindImp
#		base.afterStatementBindImp()
#		if not inherits(.type, NilableType)
#			if not inherits(.type, PrimitiveType)
#				.error('Must initialize this non-nil object type, or change the type to nilable (suffix a ?).')

	get asCS as String
		return _name

	def genCS(sw as IndentedWriter, genParams as bool)
		sw.write(.asCS)

#	def genCSStatement(out)
#		# this happens for declarations like "i as int"
#		out.write('// ')
#		.genCS(out)
#		out.write(';\n')


class CallExpr
	inherits Expr

	var _name as String
	var _args as List<of Expr>
	var _definition as ClassMember?

	def construct(token as IToken, name as String, args as List<of Expr>)
		base.construct(token)
		_name = name
		_args = args
		_definition = nil

	def _bindImp is override
		base._bindImp()

		for arg in _args
			arg.bindImp()

		definition as ClassMember?
		type as IType?

		if _definition is nil  or  _type is nil
			if _superNode inherits BinaryOpExpr
				if _superNode.op=='DOT' and this is _superNode.right
					# handle foo.bar() where this is the `bar()` part
					possibleDefinition = _superNode.left.memberForName(_name)
					if possibleDefinition is nil
						type = .compiler.passThroughType
					else
						if not possibleDefinition inherits ClassMember
							assert not possibleDefinition.isCallable
							_error('Cannot call "[_name]" because it is a "[possibleDefinition.englishName]".')
						definition = possibleDefinition to ClassMember
						type = definition.resultType
			if definition is nil
				# TODO this needs to be an error in the long term
				type = .compiler.passThroughType
			else
				if definition inherits ClassMember
					type = definition.resultType  # NOTE: used to have .namedType at the end
					if definition inherits MemberOverload
						pass  # TODO handle overloads (1)
					else
						args = _args
						if definition.hasVariParams
							# TODO handle variable number of args (4)
							pass
						else
							check = true
							if not definition.hasParams
								if args.count
									_error('The method is expecting 0 arguments, but [args.count] are being supplied in this call.')
							else
								paramsx = definition.params  # CC: rename paramsx to params
								if args.count<>paramsx.count
									if _name=='toString'  # TODO because many structs like Decimal have a toString() overload which cannot currently be expressed in SystemInterfaces.cobra
										check = false
									else
										_error('The method is expecting [paramsx.count] arguments, but [args.count] are being supplied in this call.')
								if check
									for i = 0 .. args.count
										arg = args[i]
										paramx = paramsx[i]  # CC: rename paramx to param
										assert arg.didBindImp
										assert paramx.didBindInt
										if not arg.type.isAssignableTo(paramx.type)
		# TODO
		#									if paramx.type.__class__.__name__.startswith('GenericParam')
		#										# TODO support generic params (2)
		#										pass
		#									else
											if true
												_error('Argument [i+1] of method "[_name]" expects type [paramx.type.name], but the call is supplying type [arg.type.name].')
				else
					assert false, definition

			_definition = definition
			_type = type

		assert _type, 'this=[this], def=[_definition]'
		_type.bindImp()

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_name)
		sb.append('(')
		sep = ''
		for arg in _args
			sb.append(sep)
			sb.append(arg.toCobraSource())
			sep = ', '
		sb.append(')')
		return sb.toString()

#	def genCS(out, genParens=false)
#		if .isNew
#			if genParens
#				out.write('(')
#			out.write('new ')
#		name = .isDotted and capped(.name) or .name
#		out.write('%s(' % name)
#		genCSBinaryOpStack.push('(')  # on order to make .isDotted false for the args inside the call
#		try
#			sep = ''
#			for arg in .args
#				out.write(sep)
#				arg.genCS(out)
#				sep = ', '
#			out.write(')')
#		finally
#			genCSBinaryOpStack.pop()
#		if .isNew
#			if genParens
#				out.write(')')


class BinaryOpExpr
	inherits Expr

	var _op as String
	var _left as Expr
	var _right as Expr
	var _definition as IMember?

	def construct(opToken as IToken, op as String, left as Expr, right as Expr)
		base.construct(opToken)
		_op = op
		_left = left
		_left.superNode = this
		_right = right
		_right.superNode = this

	get op from var

	get left from var

	get right from var

	pro definition from var


class IdentifierExpr
	inherits Expr

	var _text as String
	var _definition as IContainer?

	def construct(token as IToken, text as String, definition as IContainer?)
		base.construct(token)
		_text = text
		_definition = definition
# TODO:
#		if definition is nil:
#			.type = nil
#		else:
#			.type = ._resolveType()

	get definition from var

	def memberForName(name as String) as IMember? is override
		require
			.didBindImp
			.definition
		code
			return _definition.declForName(name)


class IndexExpr
	inherits Expr

	# TODO

	def construct(token as IToken, target as Expr, exprs as List<of Expr>)
		base.construct(token)


class IsNilExpr
	inherits Expr

	def construct(token as IToken, expr as Expr)
		base.construct(token)


class IsNotNilExpr
	inherits Expr

	def construct(token as IToken, expr as Expr)
		base.construct(token)


class MemberExpr
	inherits Expr
	"""
	Example members are fields and properties.
	"""

	var _name as String
	var _definition as IMember?

	def construct(token as IToken, name as String)
		base.construct(token)
		_name = name

	def addMinFields is override
		base.addMinFields()
		.addField('name', _name)

	def addRefFields is override
		base.addRefFields()
		.addField('definition', _definition)

	get binarySuperNode as BinaryOpExpr
		# TODO: move to Expr
		require
			.superNode
			.superNode inherits BinaryOpExpr
		code
			return .superNode to BinaryOpExpr

	def _bindImp is override
		require
			.superNode inherits BinaryOpExpr
			.binarySuperNode.op == 'DOT'
			.binarySuperNode.right is this
		ensure
			.type  # CC: should really be the ensure of Expr
		code
			base._bindImp()
			if _definition is nil or _type is nil
				_definition = .binarySuperNode.left.memberForName(_name)
				if _definition is nil
					if _name=='length'
						# TODO get rid of this total hack to support the vari type (and possibly arrays in general)
						_type = .compiler.intType
						.binarySuperNode.type = .type
						return
					if Utils.isCapped(_name)
						sugg = 'If the name is essentially correct, try the lowercase version ("[Utils.uncapped(_name)]") instead.'
					else
						sugg = ''
					_error('Cannot find a definition for "[_name]" in "[.binarySuperNode.left.type.name]" whose type is "[.binarySuperNode.left.type.name]". [sugg]')
				assert _definition
				if _definition inherits IType
					assert false, 'TODO: handle foo.sometype'
					# TODO:
					# effectiveType = .compiler.typeType  # namespace, class, interface
					receiverType as IType? = _definition to IType  # TODO: should not need "as IType". Type inference is not respecting the if-inherits stack
				else
					effectiveType = _definition.resultType
					receiverType = nil
				# TODO:
				#else
				#	throw FallThroughException(_definition)
				assert effectiveType
				_type = effectiveType
				# TODO: _receiverType = receiverType
				.binarySuperNode.definition = _definition  # TODO: is this needed?
				.binarySuperNode.type = .type  # the type of foo.bar is what bar returns. A MemberExpr is the "bar" part.
				# TODO: .binarySuperNode.receiverType = _receiverType  # TODO: what is this used for?
			assert _type
			_type.bindImp()

	def toCobraSource as String is override
		return _name

# TODO
#	def genCS(out)
#		name = .isDotted and Utils.capped(_name) or _name
#		out.write(name)


class OldExpr
	inherits Expr

	def construct(token as IToken, expr as Expr)
		base.construct(token)

class TruthExpr
	inherits Expr
	"""
	A truth expr wraps an expression such that it can be used where a bool is expected in .NET/C#.
	For example, if passed an integer typed expression, the truth expression will wrap it with a
	comparison 0!=expr.
	"""

	var _useRuntimeService as bool
	var _expr as Expr

	def construct(expr as Expr)
		base.construct(expr.token)
		_useRuntimeService = false
		_expr = expr

#	def addSubFields
#		Expr.addSubFields
#		.addSubField('useRuntimeService', .useRuntimeService)
#		.addSubField('expr', .expr)

	def _bindImp is override
		base._bindImp()
		_expr.bindImp()
		if _expr.type is not .compiler.boolType
# TODO
#			if _expr.isKindOf(tpassthrough)
#				_useRuntimeService = true
#			else if _expr.isKindOf(compiler.numberType)
#				_expr = BinaryOpExpr(nil, 'NE', IntegerLit(0), .expr)
#				_expr.bindImp(compiler)
#			else if _expr NilLiteral)
#				.expr = lfalse
#			else
			if true
				_useRuntimeService = true

	def toCobraSource as String is override
		return _expr.toCobraSource()

#	get asCS as String is override
#		require .didBindImp
#		return _expr.asCS

#	def genCS(out, genParens=true)
#		if .useRuntimeService
#			out.write('CobraImp.IsTrue(')
#			.expr.genCS(out)
#			out.write(')')
#		else
#			.expr.genCS(out, genParens=genParens)


class TypeExpr
	inherits Expr

	var _containedType as IType

	def construct(token as IToken, type as IType)
		base.construct(token)
		_containedType = type
		_receiverType = type

	def _bindImp is override
		base._bindImp()
		_type = .compiler.typeType


class UnaryOpExpr
	inherits Expr

	def construct(token as IToken, op as String, expr as Expr)
		base.construct(token)


##
## Literals
##

class Literal
	inherits Expr

	def construct(token as IToken)
		base.construct(token)

	get asCS as String
		return ''


# TODO:
#	def genCS(self, out, genParens=true):
#		out.write(.asCS())


class AtomicLiteral
	inherits Literal

	var _text as String

	def construct(token as IToken)
		base.construct(token)
		_text = token.text

	def _bindImp is override
		base._bindImp()
		assert _type, this
		_type.bindImp()

	def toCobraSource as String is override
		return _text


class BoolLiteral
	inherits AtomicLiteral

	var _value as bool

	def construct(token as IToken)
		require token.text in ['true', 'false']
		base.construct(token)
		_value = token.text=='true'

	def _bindImp is override
		_type = .compiler.typeForName('bool')
		base._bindImp()

	get asCS as String is override
		return if(_value, 'true', 'false')


class CharLit
	inherits AtomicLiteral

	var _value as String  # TODO: should probably be char

	def construct(token as IToken)
		require
			token.which in ['CHAR_LIT_SINGLE', 'CHAR_LIT_DOUBLE']
			token.value inherits String
		code
			base.construct(token)
			_value = token.value to String

	def _bindImp is override
		base._bindImp()
		_type = .compiler.charType

	get asCS as String is override
		return "'" + _value.toString() + "'"


class DecimalLit
	inherits AtomicLiteral

	var _value as decimal

	def construct(token as IToken)
		require token.value inherits decimal
		base.construct(token)
		_value = token.value to decimal

	get asCS as String is override
		return _value.toString()


class FloatLit
	inherits AtomicLiteral

	var _value as float

	def construct(token as IToken)
		require token.value inherits float
		base.construct(token)
		_value = token.value to float

	get asCS as String is override
		return _value.toString()


class IntegerLit
	inherits AtomicLiteral

	var _value as int

	def construct(token as IToken)
		require token.value inherits int
		base.construct(token)
		_value = token.value to int

	get asCS as String is override
		return _value.toString()


class NilLiteral
	inherits AtomicLiteral

	def construct(token as IToken)
		base.construct(token)

	def _bindImp is override
		_type = .compiler.typeForName('nil')
		base._bindImp()



class StringLit
	inherits AtomicLiteral

	def construct(token as IToken)
		require token.which.startsWith('STRING')
		base.construct(token as IToken)
		# AXE? .text = token.value

	def _bindInt is override
		if not _type
			_type = .compiler.typeForName('String')
		base._bindInt()

	def _bindImp is override
		if not _type
			_type = .compiler.typeForName('String')
		base._bindImp()

#	def toCobraSource(self)
#		return .token.text

#	def asCS(self)
#		.assertType()
#		return .csStringLitFor(.text)


class BaseLit
	inherits AtomicLiteral

	# TODO:

	def construct(token as IToken, box as Box)
		base.construct(token)

# TODO:
#	def genCS(self, out, genParens=false):
#		out.write('base')

	def memberForName(name as String) as IMember? is override
		assert .didBindImp
		assert _type
		assert false, 'TODO'
#		t = .receiverType and .receiverType or .type
#		try:
#			t = t.superType
#		except:
#			pass
#		return t.symbolForName(name, true)
		return nil


class ThisLit
	inherits AtomicLiteral

	# TODO: somewhere it has to be error checked that you're not assigning to
	# "this" (unless C# allows that)

	def construct(token as IToken, box as Box)
		base.construct(token)
# TODO:		_type = theClass

# TODO
#	def genCS(self, out, genParens=false):
#		out.write('this')
